---
title: EventLoop Source
date: 2020-07-24 11:49:24
tags:
- source
categories:
- Node
---
# eventLoop
ä¹‹å‰ä¹Ÿæœ‰è¿‡ç« èŠ‚
[nodeæ•´ç†](/2020/04/10/2020-04-10-eventloop/)
[Node.js](/Nodejs/)

æœ‰çœ‹åˆ°[çŸ³å¢¨æŠ€æœ¯æ–‡æ¡£](https://zhuanlan.zhihu.com/p/34182184)

[cnodeæŠ€æœ¯æ–‡æ¡£](https://cnodejs.org/topic/5a9108d78d6e16e56bb80882)ï¼Œä½œè€…ï¼šyouth7

è®°å½•ä»¥ä¸‹çŸ¥è¯†ç‚¹ï¼š

- **nodejsçš„eventæ˜¯åŸºäºlibuv**ï¼Œ**æµè§ˆå™¨çš„event loopåˆ™åœ¨[html5çš„è§„èŒƒ](https://www.w3.org/TR/html5/webappapis.html#event-loops)ä¸­æ˜ç¡®å®šä¹‰**ï¼Œä¸¤ä¸ªäº‹ç‰©æœ‰æ˜æ˜¾çš„åŒºåˆ«
- `process.nextTick()`åœ¨6ä¸ªé˜¶æ®µç»“æŸçš„æ—¶å€™éƒ½ä¼šæ‰§è¡Œ

## eventLoop

| timers          | æ‰§è¡Œ`setTimeout()` å’Œ `setInterval()`ä¸­åˆ°æœŸçš„callback        |
| --------------- | ------------------------------------------------------------ |
| I/O callbacks   | ä¸Šä¸€è½®å¾ªç¯ä¸­æœ‰å°‘æ•°çš„I/Ocallbackä¼šè¢«å»¶è¿Ÿåˆ°è¿™ä¸€è½®çš„è¿™ä¸€é˜¶æ®µæ‰§è¡Œ |
| idle, prepare   | ä»…å†…éƒ¨ä½¿ç”¨                                                   |
| poll            | æœ€ä¸ºé‡è¦çš„é˜¶æ®µï¼Œæ‰§è¡ŒI/O callbackï¼Œåœ¨é€‚å½“çš„æ¡ä»¶ä¸‹ä¼šé˜»å¡åœ¨è¿™ä¸ªé˜¶æ®µ |
| check           | æ‰§è¡ŒsetImmediateçš„callback                                   |
| close callbacks | æ‰§è¡Œcloseäº‹ä»¶çš„callbackï¼Œä¾‹å¦‚`socket.on("close",func)`       |



```C
   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”Œâ”€>â”‚        timers         â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  â”‚     I/O callbacks     â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  â”‚     idle, prepare     â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”‚   incoming:   â”‚
â”‚  â”‚         poll          â”‚<â”€â”€â”€â”€â”€â”¤  connections, â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â”‚   data, etc.  â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
â”‚  â”‚        check          â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â””â”€â”€â”¤    close callbacks    â”‚
   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```



```c++
# /deps/uv/src/unix/core.c
int uv_run(uv_loop_t* loop, uv_run_mode mode) {
  int timeout;
  int r;
  int ran_pending;

  r = uv__loop_alive(loop);
  // if(uv_has_active_hanles||uv_has_active_reqs || lop->closing_handles!=NULL)retrun true 
  if (!r)
    uv__update_time(loop);

  while (r != 0 && loop->stop_flag == 0) {
    uv__update_time(loop);
    // main
    uv__run_timers(loop);//timer phase
    ran_pending = uv__run_pending(loop);//IO callback pharse
    uv__run_idle(loop);//idle phase
    uv__run_prepare(loop);// prepare phase
    // main end

    timeout = 0;
    if ((mode == UV_RUN_ONCE && !ran_pending) || mode == UV_RUN_DEFAULT)
      timeout = uv_backend_timeout(loop);

    uv__io_poll(loop, timeout);//poll phase
    uv__run_check(loop);//check phase
    uv__run_closing_handles(loop);//closing pharse

    if (mode == UV_RUN_ONCE) {
      /* UV_RUN_ONCE implies forward progress: at least one callback must have
       * been invoked when it returns. uv__io_poll() can return without doing
       * I/O (meaning: no callbacks) when its timeout expires - which means we
       * have pending timers that satisfy the forward progress constraint.
       *
       * UV_RUN_NOWAIT makes no guarantees about progress so it's omitted from
       * the check.
       */
      // UV_RUN_ONCE è‡³å°‘æœ‰ä¸€ä¸ªå›è°ƒæ‰§è¡Œ,ä¸ç„¶è¯¥å¾ªç¯å°±ç©ºè½¬äº†ï¼Œæ»¡è¶³å‰è¿›è¦æ±‚
      // è¿™ä¹Ÿæ˜¯[æ–‡ç« ](https://zehai.info/2020/04/10/2020-04-10-eventloop/)ä¸­å†™åˆ°ï¼š
      // pollä¸ºç©ºï¼Œeventloopå°†æ£€æŸ¥timeræ˜¯å¦æœ‰å¿«åˆ°çš„ï¼Œå¦‚æœéœ€è¦æ‰§è¡Œï¼Œeventloopå°†è¦è¿›å…¥timersé˜¶æ®µæ¥é¡ºåºæ‰§è¡Œtimer callback
      uv__update_time(loop);
      uv__run_timers(loop);
    }

    r = uv__loop_alive(loop);
    if (mode == UV_RUN_ONCE || mode == UV_RUN_NOWAIT)
      break;
  }

  /* The if statement lets gcc compile it to a conditional store. Avoids
   * dirtying a cache line.
   */
  if (loop->stop_flag != 0)
    loop->stop_flag = 0;

  return r;
}
```

## timers phase

æ‰§è¡Œ`setTimeout()` å’Œ `setInterval()`ä¸­åˆ°æœŸçš„callback

```c++
void uv__run_timers(uv_loop_t* loop) {
  struct heap_node* heap_node;
  uv_timer_t* handle;

  for (;;) {
    heap_node = heap_min(timer_heap(loop));
    if (heap_node == NULL)
      break;
		// å–å‡ºå †ä¸­æœ€å¿«è¦è¢«æ‰§è¡Œçš„timer
    // #define container_of(ptr, type, member) 
  	// ((type *) ((char *) (ptr) - offsetof(type, member)))
    // æ²¡çœ‹æ‡‚ handleæ˜¯æ€ä¹ˆç”Ÿæˆçš„
    handle = container_of(heap_node, uv_timer_t, heap_node);
    if (handle->timeout > loop->time)//æ‰§è¡Œæ—¶é—´å¤§äºeventloopå¾ªç¯ä¸€æ¬¡æ—¶é—´ï¼Œé€€å‡ºphaseä¸‹æ¬¡å†è¯´
      break;

    uv_timer_stop(handle);// remove handle
    uv_timer_again(handle);// å¤šæ¬¡é‡å¤çš„timerå†å¡è¿›å»
    handle->timer_cb(handle);// invoke callback
  }
}
```

## I/O callbacks

ä¸Šä¸€è½®å¾ªç¯ä¸­æœ‰å°‘æ•°çš„I/Ocallbackä¼šè¢«å»¶è¿Ÿåˆ°è¿™ä¸€è½®çš„è¿™ä¸€é˜¶æ®µæ‰§è¡Œ

```c++
//deps/uv/src/unix/core.c
static int uv__run_pending(uv_loop_t* loop) {
  QUEUE* q;
  QUEUE pq;
  uv__io_t* w;

  if (QUEUE_EMPTY(&loop->pending_queue))//isEmpty
    return 0;

  QUEUE_MOVE(&loop->pending_queue, &pq);//move

  while (!QUEUE_EMPTY(&pq)) {
    q = QUEUE_HEAD(&pq);//find
    QUEUE_REMOVE(q);//pop
    QUEUE_INIT(q);
    w = QUEUE_DATA(q, uv__io_t, pending_queue);
    w->cb(loop, w, POLLOUT);//unitl queue empty
  }

  return 1;
}
```

## Idle and prepare phase

/* loop */

void uv__run_idle(uv_loop_t* loop);

void uv__run_check(uv_loop_t* loop);

void uv__run_prepare(uv_loop_t* loop);

```c++
  void uv__run_##name(uv_loop_t* loop) {
    uv_##name##_t* h;
    QUEUE queue;
    QUEUE* q;
    QUEUE_MOVE(&loop->name##_handles, &queue);//QUEUE_MOVE
    while (!QUEUE_EMPTY(&queue)) {//util empty
      q = QUEUE_HEAD(&queue);//pop
      h = QUEUE_DATA(q, uv_##name##_t, queue);//element->handle
      QUEUE_REMOVE(q);//remove
      QUEUE_INSERT_TAIL(&loop->name##_handles, q);//insert tail
      h->name##_cb(h);//callback
    }
  }   
```



## !!!poll phase!!!

æœ€ä¸ºé‡è¦çš„é˜¶æ®µï¼Œæ‰§è¡ŒI/O callbackï¼Œåœ¨é€‚å½“çš„æ¡ä»¶ä¸‹ä¼šé˜»å¡åœ¨è¿™ä¸ªé˜¶æ®µ

> å¯è§pollé˜¶æ®µçš„ä»»åŠ¡å°±æ˜¯é˜»å¡ç­‰å¾…ç›‘å¬çš„äº‹ä»¶æ¥ä¸´ï¼Œç„¶åæ‰§è¡Œå¯¹åº”çš„callbackï¼Œå…¶ä¸­é˜»å¡æ˜¯å¸¦æœ‰è¶…æ—¶æ—¶é—´çš„ï¼Œä»¥ä¸‹å‡ ç§æƒ…å†µéƒ½ä¼šä½¿å¾—è¶…æ—¶æ—¶é—´ä¸º0
>
> - uv_runå¤„äºUV_RUN_NOWAITæ¨¡å¼ä¸‹
> - `uv_stop()`è¢«è°ƒç”¨
> - æ²¡æœ‰æ´»è·ƒçš„handleså’Œrequest
> - æœ‰æ´»è·ƒçš„idle handles
> - æœ‰ç­‰å¾…å…³é—­çš„handles
>
> å¦‚æœä¸Šè¿°éƒ½ä¸ç¬¦åˆï¼Œåˆ™è¶…æ—¶æ—¶é—´ä¸ºè·ç¦»ç°åœ¨æœ€è¿‘çš„timerï¼›å¦‚æœæ²¡æœ‰timeråˆ™pollé˜¶æ®µä¼šä¸€ç›´é˜»å¡ä¸‹å»

ä¸ªäººç†è§£nodejsçš„æœåŠ¡ï¼Œå¤§éƒ¨åˆ†æ—¶é—´ä¼šè¢«é˜»å¡åœ¨è¿™ä¸ªé˜¶æ®µï¼Œè€Œä¸å»æ‰§è¡Œclosing

```c++
// ä¸è¡Œäº†ï¼Œçœ‹ä¸æ‡‚äº†
void uv__io_poll(uv_loop_t* loop, int timeout) {
  struct pollfd events[1024];
  struct pollfd pqry;
  struct pollfd* pe;
  struct poll_ctl pc;
  QUEUE* q;
  uv__io_t* w;
  uint64_t base;
  uint64_t diff;
  int have_signals;
  int nevents;
  int count;
  int nfds;
  int i;
  int rc;
  int add_failed;

  if (loop->nfds == 0) {
    assert(QUEUE_EMPTY(&loop->watcher_queue));
    return;
  }

  while (!QUEUE_EMPTY(&loop->watcher_queue)) {//until watcher queue empty
    q = QUEUE_HEAD(&loop->watcher_queue);
    QUEUE_REMOVE(q);
    QUEUE_INIT(q);

    w = QUEUE_DATA(q, uv__io_t, watcher_queue);
    assert(w->pevents != 0);
    assert(w->fd >= 0);
    assert(w->fd < (int) loop->nwatchers);

    pc.events = w->pevents;
    pc.fd = w->fd;

    add_failed = 0;
    if (w->events == 0) {
      pc.cmd = PS_ADD;
      if (pollset_ctl(loop->backend_fd, &pc, 1)) {
        if (errno != EINVAL) {
          assert(0 && "Failed to add file descriptor (pc.fd) to pollset");
          abort();
        }
        /* Check if the fd is already in the pollset */
        pqry.fd = pc.fd;
        rc = pollset_query(loop->backend_fd, &pqry);
        switch (rc) {
        case -1:
          assert(0 && "Failed to query pollset for file descriptor");
          abort();
        case 0:
          assert(0 && "Pollset does not contain file descriptor");
          abort();
        }
        /* If we got here then the pollset already contained the file descriptor even though
         * we didn't think it should. This probably shouldn't happen, but we can continue. */
        add_failed = 1;
      }
    }
    if (w->events != 0 || add_failed) {
      /* Modify, potentially removing events -- need to delete then add.
       * Could maybe mod if we knew for sure no events are removed, but
       * content of w->events is handled above as not reliable (falls back)
       * so may require a pollset_query() which would have to be pretty cheap
       * compared to a PS_DELETE to be worth optimizing. Alternatively, could
       * lazily remove events, squelching them in the mean time. */
      pc.cmd = PS_DELETE;
      if (pollset_ctl(loop->backend_fd, &pc, 1)) {
        assert(0 && "Failed to delete file descriptor (pc.fd) from pollset");
        abort();
      }
      pc.cmd = PS_ADD;
      if (pollset_ctl(loop->backend_fd, &pc, 1)) {
        assert(0 && "Failed to add file descriptor (pc.fd) to pollset");
        abort();
      }
    }

    w->events = w->pevents;
  }

  assert(timeout >= -1);
  base = loop->time;
  count = 48; /* Benchmarks suggest this gives the best throughput. */

  for (;;) {
    nfds = pollset_poll(loop->backend_fd,
                        events,
                        ARRAY_SIZE(events),
                        timeout);

    /* Update loop->time unconditionally. It's tempting to skip the update when
     * timeout == 0 (i.e. non-blocking poll) but there is no guarantee that the
     * operating system didn't reschedule our process while in the syscall.
     */
    SAVE_ERRNO(uv__update_time(loop));

    if (nfds == 0) {
      assert(timeout != -1);
      return;
    }

    if (nfds == -1) {
      if (errno != EINTR) {
        abort();
      }

      if (timeout == -1)
        continue;

      if (timeout == 0)
        return;

      /* Interrupted by a signal. Update timeout and poll again. */
      goto update_timeout;
    }

    have_signals = 0;
    nevents = 0;

    assert(loop->watchers != NULL);
    loop->watchers[loop->nwatchers] = (void*) events;
    loop->watchers[loop->nwatchers + 1] = (void*) (uintptr_t) nfds;

    for (i = 0; i < nfds; i++) {
      pe = events + i;
      pc.cmd = PS_DELETE;
      pc.fd = pe->fd;

      /* Skip invalidated events, see uv__platform_invalidate_fd */
      if (pc.fd == -1)
        continue;

      assert(pc.fd >= 0);
      assert((unsigned) pc.fd < loop->nwatchers);

      w = loop->watchers[pc.fd];

      if (w == NULL) {
        /* File descriptor that we've stopped watching, disarm it.
         *
         * Ignore all errors because we may be racing with another thread
         * when the file descriptor is closed.
         */
        pollset_ctl(loop->backend_fd, &pc, 1);
        continue;
      }

      /* Run signal watchers last.  This also affects child process watchers
       * because those are implemented in terms of signal watchers.
       */
      if (w == &loop->signal_io_watcher)
        have_signals = 1;
      else
        w->cb(loop, w, pe->revents);

      nevents++;
    }

    if (have_signals != 0)
      loop->signal_io_watcher.cb(loop, &loop->signal_io_watcher, POLLIN);

    loop->watchers[loop->nwatchers] = NULL;
    loop->watchers[loop->nwatchers + 1] = NULL;

    if (have_signals != 0)
      return;  /* Event loop should cycle now so don't poll again. */

    if (nevents != 0) {
      if (nfds == ARRAY_SIZE(events) && --count != 0) {
        /* Poll for more events but don't block this time. */
        timeout = 0;
        continue;
      }
      return;
    }

    if (timeout == 0)
      return;

    if (timeout == -1)
      continue;

update_timeout:
    assert(timeout > 0);

    diff = loop->time - base;
    if (diff >= (uint64_t) timeout)
      return;

    timeout -= diff;
  }
}

```

## check phase

è§idle prepare

## close

å…³é—­handle

```c++
static void uv__run_closing_handles(uv_loop_t* loop) {
  uv_handle_t* p;
  uv_handle_t* q;

  p = loop->closing_handles;
  loop->closing_handles = NULL;

  while (p) {
    q = p->next_closing;
    uv__finish_close(p);
    p = q;
  }
}
```

## where is process.nextTick

```js
//lib/internal/process/task_queues.js
// `nextTick()` will not enqueue any callback when the process is about to
// exit since the callback would not have a chance to be executed.
// æ„æ€å°±æ˜¯nextTickåœ¨è¿›ç¨‹å¿«è¦ç»“æŸæ—¶ä¸ä¼šæ’é˜Ÿcallback,å› ä¸ºæ²¡æœ‰æœºä¼šæ‰§è¡Œ
// ä½ ä»¬çœ‹å¼•ç”¨çš„æ–‡æ¡£å§ï¼Œæˆ‘çœ‹ä¸ä¸‹å»äº†ğŸ˜­
// ä¸»è¦çš„æ€è·¯æ˜¯JSæ‰§è¡Œprocess.nexTick()ï¼Œç„¶åå°†callbackäº¤ç»™c++æ‰§è¡Œ
function nextTick(callback) {
  if (typeof callback !== 'function')
    throw new ERR_INVALID_CALLBACK(callback);

  if (process._exiting)
    return;

  let args;
  switch (arguments.length) {
    case 1: break;
    case 2: args = [arguments[1]]; break;
    case 3: args = [arguments[1], arguments[2]]; break;
    case 4: args = [arguments[1], arguments[2], arguments[3]]; break;
    default:
      args = new Array(arguments.length - 1);
      for (let i = 1; i < arguments.length; i++)
        args[i - 1] = arguments[i];
  }

  if (queue.isEmpty())
    setHasTickScheduled(true);
  const asyncId = newAsyncId();
  const triggerAsyncId = getDefaultTriggerAsyncId();
  const tickObject = {
    [async_id_symbol]: asyncId,
    [trigger_async_id_symbol]: triggerAsyncId,
    callback,
    args
  };
  if (initHooksExist())
    emitInit(asyncId, 'TickObject', triggerAsyncId, tickObject);
  queue.push(tickObject);//å°è£…callback push
  //è¿›å…¥c
}
```

## question

### 1.setTimeout vs setImmediate

- phaseæ‰§è¡Œé¡ºåº
- expireè®¾ç½®0æ˜¯ä¸æ˜¯ç«‹åˆ»æ‰§è¡Œ

```js
setTimeout(() => {
  console.log('setTimeout')
}, 0)

setImmediate(() => {
  console.log('setImmediate')
})
```

- setTimeout/setInterval çš„ç¬¬äºŒä¸ªå‚æ•°å–å€¼èŒƒå›´æ˜¯ï¼š[1, 2^31 - 1]ï¼Œå¦‚æœ**è¶…è¿‡è¿™ä¸ªèŒƒå›´**åˆ™ä¼š**åˆå§‹åŒ–ä¸º 1**ï¼Œå³ setTimeout(fn, 0) === setTimeout(fn, 1)ã€‚
- setTimeout çš„å›è°ƒå‡½æ•°åœ¨ timer é˜¶æ®µæ‰§è¡Œï¼ŒsetImmediate çš„å›è°ƒå‡½æ•°åœ¨ check é˜¶æ®µæ‰§è¡Œï¼Œevent loop çš„å¼€å§‹ä¼šå…ˆæ£€æŸ¥ timer é˜¶æ®µï¼Œä½†æ˜¯åœ¨å¼€å§‹ä¹‹å‰åˆ° timer é˜¶æ®µä¼šæ¶ˆè€—ä¸€å®šæ—¶é—´ï¼Œæ‰€ä»¥å°±ä¼šå‡ºç°ä¸¤ç§æƒ…å†µï¼š
  - timer å‰çš„å‡†å¤‡æ—¶é—´è¶…è¿‡ 1msï¼Œæ»¡è¶³ loop->time >= 1ï¼Œåˆ™æ‰§è¡Œ timer é˜¶æ®µï¼ˆsetTimeoutï¼‰çš„å›è°ƒå‡½æ•°
  - timer å‰çš„å‡†å¤‡æ—¶é—´å°äº 1msï¼Œåˆ™å…ˆæ‰§è¡Œ check é˜¶æ®µï¼ˆsetImmediateï¼‰çš„å›è°ƒå‡½æ•°ï¼Œä¸‹ä¸€æ¬¡ event loop æ‰§è¡Œ timer é˜¶æ®µï¼ˆsetTimeoutï¼‰çš„å›è°ƒå‡½æ•°

åœ¨ä¸¾ä¾‹ï¼š

```js
setTimeout(() => {
  console.log('setTimeout')
}, 0)

setImmediate(() => {
  console.log('setImmediate')
})

const start = Date.now()
while (Date.now() - start < 10);//å‡†å¤‡æ—¶é—´è¶…è¿‡1msï¼Œåˆ™ç›´æ¥æ‰§è¡Œtimer
```

### 2.setTimeout vs setImmediate 2

```js
const fs = require('fs')

fs.readFile(__filename, () => {
  setTimeout(() => {
    console.log('setTimeout')
  }, 0)

  setImmediate(() => {
    console.log('setImmediate')
  })
})
//setImmediate
//setTimeout
```

åœ¨å¼•ç”¨ä¸€ä¸‹å®˜æ–¹å¯¹äºcheck phaseçš„ä»‹ç»

> This phase allows a person to execute callbacks immediately after the **poll** phase has completed. If the **poll** phase becomes idle and scripts have been queued with `setImmediate()`, the event loop may continue to the **check** phase rather than waiting.
>
> `setImmediate()` is actually a special timer that runs in a separate phase of the event loop. It uses a libuv API that schedules callbacks to execute after the **poll** phase has completed.
>
> Generally, as the code is executed, the event loop will eventually hit the **poll** phase where it will wait for an incoming connection, request, etc. However, if a callback has been scheduled with `setImmediate()` and the **poll** phase becomes idle, it will end and continue to the **check** phase rather than waiting for **poll** events.

fs.readFile çš„å›è°ƒå‡½æ•°æ‰§è¡Œå®Œåï¼š

1. æ³¨å†Œ setTimeout çš„å›è°ƒå‡½æ•°åˆ° timer é˜¶æ®µ
2. æ³¨å†Œ setImmediate çš„å›è°ƒå‡½æ•°åˆ° check é˜¶æ®µ
3. event loop ä» pool é˜¶æ®µå‡ºæ¥ç»§ç»­å¾€ä¸‹ä¸€ä¸ªé˜¶æ®µæ‰§è¡Œï¼Œæ°å¥½æ˜¯ check é˜¶æ®µï¼Œæ‰€ä»¥ setImmediate çš„å›è°ƒå‡½æ•°å…ˆæ‰§è¡Œ
4. æœ¬æ¬¡ event loop ç»“æŸåï¼Œè¿›å…¥**ä¸‹ä¸€æ¬¡ event loop**ï¼Œæ‰§è¡Œ setTimeout çš„å›è°ƒå‡½æ•°

æ‰€ä»¥ï¼Œåœ¨ I/O Callbacks ä¸­æ³¨å†Œçš„ setTimeout å’Œ setImmediateï¼Œæ°¸è¿œéƒ½æ˜¯ setImmediate å…ˆæ‰§è¡Œã€‚

### 3.process.nextTick()

```js
setInterval(() => {
  console.log('setInterval')
}, 100)

process.nextTick(function tick () {
  process.nextTick(tick)
})
//note
setImmediate(function immediate () {
  console.log('111');//ä¼šç›´æ¥æ‰“å°å‡ºå¾ˆå¤šæ¬¡111
  setImmediate(immediate)
})
```

è¿è¡Œç»“æœï¼šsetInterval **æ°¸è¿œä¸ä¼šæ‰“å°å‡ºæ¥**ã€‚

//è¿™ä¸ªåœ¨node[å®˜æ–¹æ–‡æ¡£](https://nodejs.org/en/docs/guides/event-loop-timers-and-nexttick/#process-nexttick)ä¹Ÿæœ‰ç›¸å…³çš„æè¿°

//æˆ‘åœ¨è¿™é‡Œä¹Ÿè¿›è¡Œäº†[ç¬”è®°](**https://zehai.info/2020/04/10/2020-04-10-eventloop/**)è®°å½•

//*å…è®¸ç”¨æˆ·å¤„ç†errorsï¼Œæ¸…ç†ä¸éœ€è¦çš„èµ„æºï¼Œäº‹ä»¶å¾ªç¯å‰ å°è¯•é‡æ–°è¿æ¥*

//*æœ‰æ—¶æœ‰å¿…è¦åœ¨eventloopç»§ç»­ä¹‹å‰ï¼Œåœ¨call stack unwoundä¹‹åï¼Œè®©callbackæ‰§è¡Œ*

**è§£é‡Š**ï¼šprocess.nextTick ä¼šæ— é™å¾ªç¯ï¼Œå°† event loop é˜»å¡åœ¨ microtask é˜¶æ®µï¼Œå¯¼è‡´ event loop ä¸Šå…¶ä»– macrotask é˜¶æ®µçš„å›è°ƒå‡½æ•°æ²¡æœ‰æœºä¼šæ‰§è¡Œã€‚//`è¿™æ®µè§£é‡Šæ˜¯å‰ç«¯çš„ï¼Œåç«¯æ˜¯æ²¡æœ‰microtaskçš„å®é™…é˜Ÿåˆ—çš„`

è§£å†³æ–¹æ³•é€šå¸¸æ˜¯ç”¨ setImmediate æ›¿ä»£ process.nextTickï¼Œå¦‚ä¸‹ï¼š

```js
setInterval(() => {
  console.log('setInterval')
}, 100)

setImmediate(function immediate () {
  setImmediate(immediate)
})
```

è¿è¡Œç»“æœï¼šæ¯ 100ms æ‰“å°ä¸€æ¬¡ setIntervalã€‚

**è§£é‡Š**ï¼šprocess.nextTick å†…æ‰§è¡Œ process.nextTick ä»ç„¶å°† tick å‡½æ•°æ³¨å†Œåˆ°å½“å‰ microtask çš„å°¾éƒ¨ï¼Œæ‰€ä»¥å¯¼è‡´ microtask æ°¸è¿œæ‰§è¡Œä¸å®Œï¼› setImmediate å†…æ‰§è¡Œ setImmediate ä¼šå°† immediate å‡½æ•°æ³¨å†Œåˆ°ä¸‹ä¸€æ¬¡ event loop çš„ check é˜¶æ®µï¼Œè€Œä¸æ˜¯å½“å‰æ­£åœ¨æ‰§è¡Œçš„ check é˜¶æ®µï¼Œæ‰€ä»¥ç»™äº† event loop ä¸Šå…¶ä»– macrotask æ‰§è¡Œçš„æœºä¼šã€‚



å†çœ‹ä¸ªä¾‹å­ï¼š

```js
setImmediate(() => {
  console.log('setImmediate1')
  setImmediate(() => {
    console.log('setImmediate2')
  })
  process.nextTick(() => {
    console.log('nextTick')
  })
})

setImmediate(() => {
  console.log('setImmediate3')
})
```

è¿è¡Œç»“æœï¼š

```text
setImmediate1
setImmediate3
nextTick
setImmediate2
```

**æ³¨æ„**ï¼šå¹¶**ä¸æ˜¯è¯´ setImmediate å¯ä»¥å®Œå…¨æ›¿ä»£ process.nextTick**ï¼Œprocess.nextTick åœ¨ç‰¹å®šåœºæ™¯ä¸‹è¿˜æ˜¯æ— æ³•è¢«æ›¿ä»£çš„ï¼Œæ¯”å¦‚æˆ‘ä»¬å°±æƒ³å°†ä¸€äº›æ“ä½œæ”¾åˆ°æœ€è¿‘çš„ microtask é‡Œæ‰§è¡Œã€‚

### 4.promise

```js
const promise = Promise.resolve()
  .then(() => {
    return promise
  })
promise.catch(console.error)
```

è¿è¡Œç»“æœï¼š

```text
TypeError: Chaining cycle detected for promise #<Promise>
    at <anonymous>
    at process._tickCallback (internal/process/next_tick.js:188:7)
    at Function.Module.runMain (module.js:667:11)
    at startup (bootstrap_node.js:187:16)
    at bootstrap_node.js:607:3
```

**è§£é‡Š**ï¼špromise.then ç±»ä¼¼äº process.nextTickï¼Œéƒ½ä¼šå°†å›è°ƒå‡½æ•°æ³¨å†Œåˆ° microtask é˜¶æ®µã€‚ä¸Šé¢ä»£ç ä¼šå¯¼è‡´æ­»å¾ªç¯ï¼Œç±»ä¼¼å‰é¢æåˆ°çš„ï¼š

```js
process.nextTick(function tick () {
  process.nextTick(tick)
})
```

å†çœ‹ä¸ªä¾‹å­ï¼š

```js
const promise = Promise.resolve()

promise.then(() => {
  console.log('promise')
})

process.nextTick(() => {
  console.log('nextTick')
})
```

è¿è¡Œç»“æœï¼š

```text
nextTick
promise
```

**è§£é‡Š**ï¼špromise.then è™½ç„¶å’Œ process.nextTick ä¸€æ ·ï¼Œéƒ½å°†å›è°ƒå‡½æ•°æ³¨å†Œåˆ° microtaskï¼Œä½†ä¼˜å…ˆçº§ä¸ä¸€æ ·ã€‚process.nextTick çš„ microtask queue æ€»æ˜¯ä¼˜å…ˆäº promise çš„ microtask queue æ‰§è¡Œã€‚

### 5.promiseæ‰§è¡Œé¡ºåº

```js
setTimeout(() => {
  console.log(1)
}, 0)

new Promise((resolve, reject) => {
  console.log(2)
  for (let i = 0; i < 10000; i++) {
    i === 9999 && resolve()
  }
  console.log(3)
}).then(() => {
  console.log(4)
})
console.log(5)
```

è¿è¡Œç»“æœï¼š

```text
2
3
5
4
1
```

**è§£é‡Š**ï¼šPromise æ„é€ å‡½æ•°æ˜¯åŒæ­¥æ‰§è¡Œçš„ï¼Œæ‰€ä»¥å…ˆæ‰“å° 2ã€3ï¼Œç„¶åæ‰“å° 5ï¼Œæ¥ä¸‹æ¥ event loop è¿›å…¥æ‰§è¡Œ microtask é˜¶æ®µï¼Œæ‰§è¡Œ promise.then çš„å›è°ƒå‡½æ•°æ‰“å°å‡º 4ï¼Œç„¶åæ‰§è¡Œä¸‹ä¸€ä¸ª macrotaskï¼Œæ°å¥½æ˜¯ timer é˜¶æ®µçš„ setTimeout çš„å›è°ƒå‡½æ•°ï¼Œæ‰“å°å‡º 1ã€‚

### 6.ç»¼åˆ

```js
setImmediate(() => {
  console.log(1)
  setTimeout(() => {
    console.log(2)
  }, 100)
  setImmediate(() => {
    console.log(3)
  })
  process.nextTick(() => {
    console.log(4)
  })
})
process.nextTick(() => {
  console.log(5)
  setTimeout(() => {
    console.log(6)
  }, 100)
  setImmediate(() => {
    console.log(7)
  })
  process.nextTick(() => {
    console.log(8)
  })
})
console.log(9)
```

è¿è¡Œç»“æœï¼š

```text
9
5
8
1
7
4
3
6
2
```

process.nextTickã€setTimeout å’Œ setImmediate çš„ç»„åˆï¼Œè¯·è¯»è€…è‡ªå·±æ¨ç†å§ã€‚

# other source code

## setTimeout()

```js
//lib/timers/promises.js
//setTimeout(function(){},expire)
function setTimeout(after, value, options = {}) {
  const args = value !== undefined ? [value] : value;
  if (options == null || typeof options !== 'object') {
    return PromiseReject(
      new ERR_INVALID_ARG_TYPE(
        'options',
        'Object',
        options));
  }
  const { signal, ref = true } = options;
  if (signal !== undefined &&
      (signal === null ||
       typeof signal !== 'object' ||
       !('aborted' in signal))) {
    return PromiseReject(
      new ERR_INVALID_ARG_TYPE(
        'options.signal',
        'AbortSignal',
        signal));
  }
  if (typeof ref !== 'boolean') {
    return PromiseReject(
      new ERR_INVALID_ARG_TYPE(
        'options.ref',
        'boolean',
        ref));
  }
  // TODO(@jasnell): If a decision is made that this cannot be backported
  // to 12.x, then this can be converted to use optional chaining to
  // simplify the check.
  if (signal && signal.aborted)
    return PromiseReject(lazyDOMException('AbortError'));
  return new Promise((resolve, reject) => {
    const timeout = new Timeout(resolve, after, args, false, true);
    if (!ref) timeout.unref();
    insert(timeout, timeout._idleTimeout);
    if (signal) {
      signal.addEventListener('abort', () => {
        if (!timeout._destroyed) {
          // eslint-disable-next-line no-undef
          clearTimeout(timeout);
          reject(lazyDOMException('AbortError'));
        }
      }, { once: true });
    }
  });
}
```

