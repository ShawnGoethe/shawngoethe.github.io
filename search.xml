<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[prototype]]></title>
    <url>%2F2021%2F03%2F07%2F2021-03-07-prototype%2F</url>
    <content type="text"><![CDATA[Prototype含义：proto（/ˈproʊtə/）原始, 原型, 原始的 目的：补充JavaScript对于对象的支持，通过protype来实现class中的method 过程：熟悉实例对象构造函数原型 三者之间的关系 1234567//构造函数 创建对象function Dog() &#123;&#125;var dog = new Dog();//Person 为构造函数,person为实例对象dog.name = &#x27;柯基&#x27;;console.log(dog.name) // 柯基 构造函数通过prototype访问原型（一个类的属性，对象都可以访问） 实例对象通过 _proto_ 访问原型 === 构造函数通过prototype访问原型（原型也有_proto_） 实例原型通过constructor访问构造函数(Dog=== Dog.prototype.constructor) 原型遵循向上原则，即找不到就不断向上（prototype）查询 原型因为不停延长形成链，称作原型链，但是 Object.prototype.__proto__ 的值为 null 跟 Object.prototype 没有原型 原型链大概实现了类（Class）以及继承（Extend）的问题，但它并不是复制，是建立一种关联，通过prototype/_proto_ 来访问其他对象的属性和方法，属于委托/借用 Extend一共分为6种 原型链继承 借用构造函数（经典继承） 组合继承 原型式继承 寄生式继承 寄生组合式继承 原型链继承123456789101112131415function Parent () &#123; this.names = [&#x27;kevin&#x27;, &#x27;daisy&#x27;];&#125;function Child () &#123;&#125;Child.prototype = new Parent();var child1 = new Child();child1.names.push(&#x27;yayu&#x27;);console.log(child1.names); // [&quot;kevin&quot;, &quot;daisy&quot;, &quot;yayu&quot;]var child2 = new Child();console.log(child2.names); // [&quot;kevin&quot;, &quot;daisy&quot;, &quot;yayu&quot;] 问题： 属性被所有child共享 创建child实例时，不能向parent传参 借用构造函数123456789101112131415function Parent (name) &#123; this.name = name;&#125;function Child (name) &#123; Parent.call(this, name);&#125;var child1 = new Child(&#x27;kevin&#x27;);console.log(child1.name); // kevinvar child2 = new Child(&#x27;daisy&#x27;);console.log(child2.name); // daisy 有点： 避免引用类型的属性被所有实例共享 可以在Child中间parent传参 缺点： 方法在构造函数中定义，每次创建势力都会创建一遍方法 组合继承以上两种方法的组合,为最常用的继承方式 1234567891011121314151617181920212223242526272829function Parent (name) &#123; this.name = name; this.colors = [&#x27;red&#x27;, &#x27;blue&#x27;, &#x27;green&#x27;];&#125;Parent.prototype.getName = function () &#123; console.log(this.name)&#125;function Child (name, age) &#123; Parent.call(this, name); this.age = age;&#125;Child.prototype = new Parent();Child.prototype.constructor = Child;var child1 = new Child(&#x27;kevin&#x27;, &#x27;18&#x27;);child1.colors.push(&#x27;black&#x27;);console.log(child1.name); // kevinconsole.log(child1.age); // 18console.log(child1.colors); // [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;, &quot;black&quot;]var child2 = new Child(&#x27;daisy&#x27;, &#x27;20&#x27;);console.log(child2.name); // daisyconsole.log(child2.age); // 20console.log(child2.colors); // [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;]]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>prototype</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[dockerMysql]]></title>
    <url>%2F2021%2F02%2F10%2F2021-02-10-dockerMysql%2F</url>
    <content type="text"><![CDATA[link:mysql-docker 支持标签 8.0.23, 8.0, 8, latest 5.7.33, 5.7, 5 5.6.51, 5.6 快速手册 issues: https://github.com/docker-library/mysql/issues 支持平台: (more info) amd64 发布image 详情: repo-info repo’s repos/mysql/ directory (history) (image metadata, transfer size, etc) Image 更新: official-images repo’s library/mysql labelofficial-images repo’s library/mysql file (history) 描述来源: docs repo’s mysql/ directory (history) 什么是 MySQL?MySQL 是最受欢迎的，开源的数据库. 凭借被验证过的性能表现，可靠性，易用性, MySQL已经成为基于web的应用程序的 主要选择,包括完整得个人项目和网站项目（电子上午，信息服务）,也包括优秀的Facebook Facebook, Twitter, YouTube, Yahoo! 如何使用mysql image创建 mysql 服务实例启动 MySQL 比较简单: 1$ docker run --name some-mysql -e MYSQL_ROOT_PASSWORD=my-secret-pw -d mysql:tag some-mysql 容器名称 my-secret-pw 是root账户的密码 tag 是mysql的版本 通过mysql命令行连接mysql以下命令可以启动mysql容器并运行终端，执行SQL语句 1$ docker run -it --network some-network --rm mysql mysql -hsome-mysql -uexample-user -p some-mysql 容器名称 some-network 连接网络（方便容器间访问） 也可以直接运行客户端，访问远程数据库 1$ docker run -it --rm mysql mysql -hsome.mysql.host -usome-mysql-user -p 更多命令请访问 MySQL documentation 使用docker stack 或docker-compose部署示例stack.yml 12345678910111213141516# Use root/example as user/password credentialsversion: &#x27;3.1&#x27;services: db: image: mysql command: --default-authentication-plugin=mysql_native_password restart: always environment: MYSQL_ROOT_PASSWORD: example adminer: image: adminer restart: always ports: - 8080:8080 docker stack deploy -c stack.yml mysql docker-compose -f stack.yml up 启动后, 访问 http://swarm-ip:8080, http://localhost:8080, or http://host-ip:8080 shell访问查看 MySQL 日志使用 docker exec 可以让你在容器内执行命令，命令如下 1$ docker exec -it some-mysql bash 容器日志: 1$ docker logs some-mysql 自定义 MySQL 配置文件mysql默认配置文件在 /etc/mysql/my.cnf, 也可能指定了额外文件如： /etc/mysql/conf.d or /etc/mysql/mysql.conf.d. 请检查mysqlimage本身的相关文件和目录以了解更多信息 如果 /my/custom/config-file.cnf 是你自定义的文件未知和名字, 你可以这样启动你的mysql 容器 1$ docker run --name some-mysql -v /my/custom:/etc/mysql/conf.d -e MYSQL_ROOT_PASSWORD=my-secret-pw -d mysql:tag 你会启动一个用你自定义配置 /etc/mysql/my.cnf and /etc/mysql/conf.d/config-file.cnf, 的mysql容器 不使用cnf 文件配置很多配置都可以传给 mysqld. 使你自定义容器而不需要 cnf 文件. 如当你想改变默认编码和排序规则，使用 UTF-8 (utf8mb4) 只需要执行如下命令: 1$ docker run --name some-mysql -e MYSQL_ROOT_PASSWORD=my-secret-pw -d mysql:tag --character-set-server=utf8mb4 --collation-server=utf8mb4_unicode_ci 如果你想看到所有的配置项，只需要执行: 1$ docker run -it --rm mysql:tag --verbose --help 环境变量docker run 时，可以一个或多个参数进行配置. 不过需要注意，如果使用已经包含数据库的数据目录启动容器，以下变量不会产生影响，在启动时，任何预先存在的数据库都保持不变，任何之前存在的数据库在容器启动时将保持不变. MYSQL_ROOT_PASSWORD该变量是必须的，是root账户的密码. MYSQL_DATABASE该变量可选，允许在启动时，指定数据库的名称. 如果提供了用户名/密码，用户会被赋予超级权限. MYSQL_USER, MYSQL_PASSWORD可选变量，用于创建新用户和密码，用户将获得超级管理员权限，两个参数都是必须的. 注意：不需要使用该机制来创建root超级用户，默认使用 MYSQL_ROOT_PASSWORD 来创建密码 MYSQL_ALLOW_EMPTY_PASSWORD可选变量，设置非空值（如yes），允许root用户无密码启动容器. 注意: 除非你知道你在做什么，否则不建议设置为 yes ,因为这将使mysql实例完全不受保护,允许所有人获得完全的超级用户权限. MYSQL_RANDOM_ROOT_PASSWORD可选变量，设置非空值（如yes）,使用pwgen , 为root用户随机生成密码 .密码将被打印. MYSQL_ONETIME_PASSWORD设置用户 初始化完成后过期，在首次登录时候强制修改密码. 任何非空值将激活这个配置，注意：仅支持5.6+版本，以下版本会报错 MYSQL_INITDB_SKIP_TZINFO默认，entrypoint脚本自动加载CONVERT_TZ()函数需要的时区数据，如果不需要，任何非空值都将禁用时区加载 Docker Secrets通过环境变量传递敏感信息，还有另一种方法, _FILE 可以附加到前面列的环境变量，使得可以从文件中的变量初始化脚本，特别是，这可以用于存在/run/secrets/&lt;secret_name&gt;中的docker screts从加载密码, 如 ： 1$ docker run --name some-mysql -e MYSQL_ROOT_PASSWORD_FILE=/run/secrets/mysql-root -d mysql:tag 目前仅支持： MYSQL_ROOT_PASSWORD, MYSQL_ROOT_HOST, MYSQL_DATABASE, MYSQL_USER, 和MYSQL_PASSWORD. 初始化新实例刚启动容器,指定名字的新数据库会被创建，并且根据提供的变量初始化. 此外,它将执行扩展名为.sh, .sql 和 .sql.gz （ /docker-entrypoint-initdb.d文件夹中）.文件将按照字幕顺序执行. 你可以轻松使用dump备份填充，. 默认情况下，sql文件将被保存在 MYSQL_DATABASE 指定的数据库中. Caveats//告诫数据存储在哪里重要内容：有几种方式在容器运行时存储数据. 我们推荐 mysql 用户熟悉可用的选项,包括: 让docker使用自己的内部volume 将数据库文件写入主机系统上的磁盘（而不在容器内）从而管理数据库数据的存储。这也是默认的配置，也非常简单透明。缺点是相比直接部署找文件困难. 在主机上创建一个数据目录，并将其装载到容器内部的一个目录中，使得数据库文件放置在主机已知的位置上，更轻松访问文件，缺点是需要确保目录存在，且有权限和安全机制 Docker 文档是理解不同存储选项和变量的最好起步，并且有很多博客论坛讨论并提供建议，我们将简单展示基本过程: 创建文件夹在主机如 /my/own/datadir. 启动 mysql 容器 1$ docker run --name some-mysql -v /my/own/datadir:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=my-secret-pw -d mysql:tag -v /my/own/datadir:/var/lib/mysql 将 /my/own/datadir 目录从主机装入容器中作为 /var/lib/mysql 默认不传-v情况下，mysql将写入其他数据文件. 直到初始化完成才有连接如果容器启动没有初始化数据库，则创建默认数据库. 初始化完成之前不会接受传入连接. 在使用自动化工具如 docker-compose同时启动多个容器时,这可能会导致问题. 如果应用尝试连接不提供服务的mysql，需要继续重试等待连接成功. 官方示例, 详见 WordPress or Bonita. 现用数据库使用如果在一个有mysql数据目录的volume启动mqsql，应省略 $MYSQL_ROOT_PASSWORD命令; 及时填写也不会生效, 且不会更改预先存在的数据库. 以任意用户身份运行如果你正确设置了目录权限，或者你需要使用特定的uid/gid运行mysqld，则可以通过 --user 设为任意值（root/0外）来实现所需的权限/配置: 1234$ mkdir data$ ls -lnd datadrwxr-xr-x 2 1000 1000 4096 Aug 27 15:54 data$ docker run -v &quot;$PWD/data&quot;:/var/lib/mysql --user 1000:1000 --name some-mysql -e MYSQL_ROOT_PASSWORD=my-secret-pw -d mysql:tag 创建备份大多数工具都会正常工作,尽管他们的使用在某些情况下可能有点复杂， 以确保可以访问mysqld服务器，确保这一点的一个简单方法是使用 docker exec 并从同一容器运行工具，如: 1$ docker exec some-mysql sh -c &#x27;exec mysqldump --all-databases -uroot -p&quot;$MYSQL_ROOT_PASSWORD&quot;&#x27; &gt; /some/path/on/your/host/all-databases.sql 从备份还原数据1$ docker exec -i some-mysql sh -c &#x27;exec mysql -uroot -p&quot;$MYSQL_ROOT_PASSWORD&quot;&#x27; &lt; /some/path/on/your/host/all-databases.sqlwith any relevant licenses for all software contained within.1]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[currying]]></title>
    <url>%2F2021%2F01%2F15%2F2021-01-15-currying%2F</url>
    <content type="text"><![CDATA[柯里化是一种将使用多个参数的一个函数转换成一系列使用一个参数的函数的技术 12345678910function add(a, b) &#123; return a + b;&#125;// 执行 add 函数，一次传入两个参数即可add(1, 2) // 3// 假设有一个 curry 函数可以做到柯里化var addCurry = curry(add);addCurry(1)(2) // 3]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>currying</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[closure]]></title>
    <url>%2F2021%2F01%2F08%2F2021-01-08-closure%2F</url>
    <content type="text"><![CDATA[前置知识：JavaScript是静态作用域 闭包：访问自由变量的函数 1234567var a = 1;//既不是foo的局部变量，也不是foo函数的参数，a为自由变量function foo() &#123; console.log(a);&#125;foo();//1 即使上下文被销毁，它仍然存在，因为在作用域链上被引用了，是js的一个特性，目前如PHP，Java不会原生支持 面试题 常见的新手面试题，我遇到过好几次（作用域+闭包考点） 123456789101112131415161718192021222324252627var data = [];for (var i = 0; i &lt; 3; i++) &#123; data[i] = function () &#123; console.log(i); &#125;;&#125;data[0]();data[1]();data[2]();//closure var data = [];for (var i = 0; i &lt; 3; i++) &#123; data[i] = (function (i) &#123; return function()&#123; console.log(i); &#125; &#125;)(i);&#125;data[0]();//不用找global的idata[1]();data[2]();]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>closure</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vscode访问服务器文件]]></title>
    <url>%2F2021%2F01%2F05%2F2021-01-05-vscoderemote%2F</url>
    <content type="text"><![CDATA[1.install remote ssh in vscode 2.click remote explorer and select ssh targets 3.click remote ssh configure or press F1 and input remote-ssh:Open configuration file 4.selete path ~/.ssh/config,and modify config file if you dont have rsa ,please generate keys before 123456//optionalssh-keygen# passphrase can be empty and then generate keys in `~/.ssh`# put *.pub (public key) to your server (~/.ssh/) and excute `cat id_rsa.pub &gt;&gt; authorized_keys` to merge Previous file# now rsa keys are ready 1234567Host alias HostName 8.888.88.8 User root IdentityFile ~&#x2F;.ssh&#x2F;id_rsa RSAAuthentication yes PubkeyAuthentication yes PasswordAuthentication no Host alias–&gt;your remote server name hostName–&gt;server ip User–&gt;login username IdentityFile–&gt;private key path RSAAuthentication–&gt;optional PubkeyAuthentication–&gt;optional PasswordAuthentication–&gt;no password login 5.login without password ready]]></content>
      <categories>
        <category>skills</category>
      </categories>
      <tags>
        <tag>vscode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2020-10-16-promise用法]]></title>
    <url>%2F2020%2F10%2F16%2F2020-10-16-promise%E7%94%A8%E6%B3%95%2F</url>
    <content type="text"><![CDATA[WhatECMAscript 6 原生提供了 Promise 对象。 Promise 对象代表了未来将要发生的事件，用来传递异步操作的消息。 Promise 对象有以下两个特点:1、对象的状态不受外界影响。Promise 对象代表一个异步操作，有三种状态： pending: 初始状态，不是成功或失败状态。 fulfilled: 意味着操作成功完成。 rejected: 意味着操作失败。 只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。这也是 Promise 这个名字的由来，它的英语意思就是「承诺」，表示其他手段无法改变。 2、一旦状态改变，就不会再变，任何时候都可以得到这个结果。Promise 对象的状态改变，只有两种可能：从 Pending 变为 Resolved 和从 Pending 变为 Rejected。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果。就算改变已经发生了，你再对 Promise 对象添加回调函数，也会立即得到这个结果。这与事件（Event）完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的。 1234var promise &#x3D; new Promise(function(resolve, reject) &#123; &#x2F;&#x2F; 异步处理 &#x2F;&#x2F; 处理结束后、调用resolve 或 reject&#125;); 以上来自:菜鸟https://www.runoob.com/w3cnote/javascript-promise-object.html Why因为在2020年01月07日有一篇文章讲了使用promise实现延时队列的一道面试题，因为之前写业务没有用到过所以一直以为用处不大，但今天对接阿里的录音文件识别转文字的接口中，示例代码是一个setInterval轮询得到结果的一种方式，但是他带来了一个很严重的问题 ！！没有办法返回前端转文字的结果！！ 大概代码如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051//url:https://help.aliyun.com/document_detail/94242.html?spm=a2c4g.11174283.6.601.15eb7275a8rq00// 这段代码会异步执行，可以得到结果，但是直接用这个代码返回给前端client.submitTask(taskParams, options).then((response) =&gt; &#123; console.log(response); // 服务端响应信息的状态描述StatusText。 var statusText = response.StatusText; if (statusText != &#x27;SUCCESS&#x27;) &#123; console.log(&#x27;录音文件识别请求响应失败!&#x27;) return; &#125; console.log(&#x27;录音文件识别请求响应成功!&#x27;); // 获取录音文件识别请求任务的TaskId，以供识别结果查询使用。 var taskId = response.TaskId; /** * 以TaskId为查询参数，提交识别结果查询请求。 * 以轮询的方式进行识别结果的查询，直到服务端返回的状态描述为&quot;SUCCESS&quot;、SUCCESS_WITH_NO_VALID_FRAGMENT， * 或者为错误描述，则结束轮询。 */ var taskIdParams = &#123; TaskId : taskId &#125;; var timer = setInterval(() =&gt; &#123; client.getTaskResult(taskIdParams).then((response) =&gt; &#123; console.log(&#x27;识别结果查询响应：&#x27;); console.log(response); var statusText = response.StatusText; if (statusText == &#x27;RUNNING&#x27; || statusText == &#x27;QUEUEING&#x27;) &#123; // 继续轮询，注意间隔周期。 &#125; else &#123; if (statusText == &#x27;SUCCESS&#x27; || statusText == &#x27;SUCCESS_WITH_NO_VALID_FRAGMENT&#x27;) &#123; console.log(&#x27;录音文件识别成功：&#x27;); var sentences = response.Result; console.log(sentences); &#125; else &#123; console.log(&#x27;录音文件识别失败!&#x27;); &#125; // 退出轮询 clearInterval(timer); &#125; &#125;).catch((error) =&gt; &#123; console.error(error); // 异常情况，退出轮询。 clearInterval(timer); &#125;); &#125;, 10000); &#125;).catch((error) =&gt; &#123; console.error(error); &#125;);&#125; How使用promise进行包裹，等到promise内部的函数取到了结果在返回 12345678if (statusText == &#x27;SUCCESS&#x27; || statusText == &#x27;SUCCESS_WITH_NO_VALID_FRAGMENT&#x27;) &#123; console.log(&#x27;录音文件识别成功：&#x27;); var sentences = response.Result; console.log(sentences); //这里新增resolve&#125; else &#123; console.log(&#x27;录音文件识别失败!&#x27;);&#125; 外层通过如下代码实现 1234var promise &#x3D; new Promise(function(resolve, reject) &#123; &#x2F;&#x2F; 异步处理 &#x2F;&#x2F; 处理结束后、调用resolve 或 reject&#125;); 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465async function getWords() &#123; return new Promise((resolve, reject) =&gt; &#123; client .submitTask(taskParams, options) .then(response =&gt; &#123; console.log(response); // 服务端响应信息的状态描述StatusText。 const statusText = response.StatusText; if (statusText != &#x27;SUCCESS&#x27;) &#123; console.log(&#x27;录音文件识别请求响应失败!&#x27;); &#125; console.log(&#x27;录音文件识别请求响应成功!&#x27;); // 获取录音文件识别请求任务的TaskId，以供识别结果查询使用。 const taskId = response.TaskId; /** * 以TaskId为查询参数，提交识别结果查询请求。 * 以轮询的方式进行识别结果的查询，直到服务端返回的状态描述为&quot;SUCCESS&quot;、SUCCESS_WITH_NO_VALID_FRAGMENT， * 或者为错误描述，则结束轮询。 */ const taskIdParams = &#123; TaskId: taskId, &#125;; const timer = setInterval(() =&gt; &#123; client .getTaskResult(taskIdParams) .then(response =&gt; &#123; console.log(&#x27;识别结果查询响应：&#x27;); console.log(response); const statusText = response.StatusText; if (statusText == &#x27;RUNNING&#x27; || statusText == &#x27;QUEUEING&#x27;) &#123; // 继续轮询，注意间隔周期。 &#125; else &#123; if ( statusText == &#x27;SUCCESS&#x27; || statusText == &#x27;SUCCESS_WITH_NO_VALID_FRAGMENT&#x27; ) &#123; console.log(&#x27;录音文件识别成功：&#x27;); let sentences = &#x27;&#x27;; for (const s of response.Result.Sentences) &#123; sentences += s.Text; &#125; console.log(response.Result); resolve(sentences);//**重点**// // return sentences; &#125; else &#123; console.log(&#x27;录音文件识别失败!&#x27;); &#125; // 退出轮询 clearInterval(timer); &#125; &#125;) .catch(error =&gt; &#123; console.error(error); // 异常情况，退出轮询。 clearInterval(timer); &#125;); &#125;, 10000); &#125;) .catch(error =&gt; &#123; console.error(error); &#125;); &#125;); &#125; return await getWords();//返回前端，翻译结果 另外记录一件事情，左侧单元图标地址：https://fontawesome.com/v4.7.0/icons/]]></content>
  </entry>
  <entry>
    <title><![CDATA[NodeJS]]></title>
    <url>%2F2020%2F09%2F27%2F2020-09-27-NodeJS%2F</url>
    <content type="text"><![CDATA[https://github.com/theanarkh/understand-nodejs 文档还是不错的]]></content>
  </entry>
  <entry>
    <title><![CDATA[Jupyter]]></title>
    <url>%2F2020%2F09%2F25%2F2020-09-25-Jupyter%2F</url>
    <content type="text"><![CDATA[whatJupiter = Julia + Python + R Jupyter notebook（http://jupyter.org/） 是一种 Web 应用，能让用户将说明文本、数学方程、代码和可视化内容全部组合到一个易于共享的文档中。 why 将代码和文档结合在一起，更直观的编写人工智能，大数据的代码 分块运行 直接运行shell不需要切换环境 so on how Download images 12$docker pull jupyter jupyter&#x2F;scipy-notebook:latest$docker run -itd --rm -p 1000:8888 -e JUPYTER_ENABLE_LAB&#x3D;yes -v &#x2F;home&#x2F;zehai&#x2F;jupyter:&#x2F;home&#x2F;jovyan&#x2F;work --name jupyter jupyter&#x2F;scipy-notebook:latest docker logs -f container’s ID and find token 12345To access the notebook, open this file in a browser: file:&#x2F;&#x2F;&#x2F;home&#x2F;jovyan&#x2F;.local&#x2F;share&#x2F;jupyter&#x2F;runtime&#x2F;nbserver-6-open.htmlOr copy and paste one of these URLs: http:&#x2F;&#x2F;896bb1e66101:8888&#x2F;?token&#x3D;fda8565a9b5cd5b8c621b45322ee72f716fd7ddea089fb51 or http:&#x2F;&#x2F;127.0.0.1:8888&#x2F;?token&#x3D;fda8565a9b5cd5b8c621b45322ee72f716fd7ddea089fb51 more info visit official docs enjoy (pics powered by cherevero)]]></content>
  </entry>
  <entry>
    <title><![CDATA[chevereto]]></title>
    <url>%2F2020%2F09%2F15%2F2020-09-15-Chevereto%2F</url>
    <content type="text"><![CDATA[whatTo solve some problems some web only use markdown and can’t upload pictures,such as v2ex.com some pics you don’t want to give it to others for long time,such as your interesting story give your blog’s can speed when download bigger pics and so on Picture Bed can offer you a excellent platform to share your pictures and protect them, however it has a problem that you need a server to run the service,even though you can use 七牛云,alioss,weibo for free. whyChevereto is aim what I find dockerhub has chevereto images Combined with ShareX (only for windows😢),chevereto can write markdown essay easily it has api ,you can make it stronger Chevereto Free v1.2.2 now Something others you can discover by yourself howChevereto is a php project , I use docker to run it 12345678910docker pull nmtan/chevereto:latest//use docker-compose.yml(next block)// or docker run docker run -it --name chevereto -d -p 8000:80 -v &quot;/home/xxx/images&quot;:/var/www/html/images -e &quot;CHEVERETO_DB_HOST=127.0.0.1&quot; -e &quot;CHEVERETO_DB_USERNAME=root&quot; -e &quot;CHEVERETO_DB_PASSWORD=rootpass&quot; -e &quot;CHEVERETO_DB_NAME=chevereto&quot; -e &quot;CHEVERETO_DB_PREFIX=chv_&quot; nmtan/chevereto//-v save photos in server instead of container//-e mysql:5.7.31 host,username,password,db_name(db must exist first)//open chrome and input 127.0.0.1:8000 12345678910111213141516171819202122232425262728293031323334353637383940414243&#x2F;&#x2F;this is docker-compose.ymlversion: &#39;3&#39;services: db: image: mariadb volumes: - .&#x2F;database:&#x2F;var&#x2F;lib&#x2F;mysql:rw restart: always networks: - private environment: MYSQL_ROOT_PASSWORD: xxxxx MYSQL_DATABASE: xxxxx MYSQL_USER: xxxxx MYSQL_PASSWORD: xxxxx chevereto: depends_on: - db image: nmtan&#x2F;chevereto restart: always networks: - private environment: CHEVERETO_DB_HOST: db CHEVERETO_DB_USERNAME: xxxxxx CHEVERETO_DB_PASSWORD: xxxxx CHEVERETO_DB_NAME: xxxxx CHEVERETO_DB_PREFIX: chv_ volumes: - .&#x2F;images:&#x2F;var&#x2F;www&#x2F;html&#x2F;images:rw - .&#x2F;php.ini:&#x2F;usr&#x2F;local&#x2F;etc&#x2F;php&#x2F;php.ini:ro ports: - 8080:80networks: private:&#x2F;&#x2F; start commandnohup docker-compose up &amp;&gt; run.log &amp;disown You maybe run into a stone wall when you first visit 127.0.0.1:8000 Before you can use docker exec -it chevereto bash into container /var/www/html no permission write phots to /home/xxx/images,you can use chmod -R 777 /home/xxx/images no permission update chevereto from 1.1.4 to1.2.2 ,no update possible: /app/install/update/temp/ path,that is no temp folder in /app/install/update/ under version 1.2.0,you can mkdir temp and then chmod -R 777 ./temp and then refresh the webpage ,the prics bed will update successfully So , you can use ip address to visit your chevereto . However , we usually use domain name such as example.com to visit web, a https isn ecessary as well 1.Use aliyun to apply a free ssl license for a domain name such as pics.example.com 2.Download pem and keys to your server and put it in nginx conf folder 3.Use the conf as follows 12345678910111213141516171819202122232425262728293031323334server &#123; listen 80; server_name pics.example.com; return 301 https:&#x2F;&#x2F;pics.example.com$request_uri; &#125; server &#123; listen 443 ssl; server_name pics.example.com; gzip on; ssl_certificate cert&#x2F;xxxxxx9_pics.example.com.pem; # pem&#39;s filename ssl_certificate_key cert&#x2F;xxxxxx9_pics.example.com.key;# key&#39;s filename location &#x2F; &#123; proxy_redirect off; proxy_pass http:&#x2F;&#x2F;dockername; proxy_set_header Host $http_host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-Ssl on; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header X-Forwarded-Proto $scheme; proxy_set_header X-Frame-Options SAMEORIGIN; client_max_body_size 100m; client_body_buffer_size 128k; proxy_buffer_size 4k; proxy_buffers 4 32k; proxy_busy_buffers_size 64k; proxy_temp_file_write_size 64k; &#125; &#125; And then you can visit https://pics.example.com That‘s my story that building pics bed ,and hope to help you. 2020-09-28 append use picgo，upload pictures in typora to chevereto GitHub download picgo,mac use .dmp,and then install it open 插件设置,search chevereto and install chevereto 1.0.0 Open 图床设置&gt;Chevereto Uploader and put in params, Url is your upload service ip/domain Key is chevereto api in Dashboard&gt;Settings&gt;API&gt;API v1 key param is not in use now 12Url:https:&#x2F;&#x2F;example.com&#x2F;api&#x2F;1&#x2F;uploadKey:xxx Click 确定 and 设为默认图库 make sure server is on PicGo设置&gt;设置Server&gt;点击设置,if it is on ,noting should be done and then we modify config in typaro Open Typora and open ‘preferences&gt;Images` Choose Upload images in when Insert and check apply above rules to local images and apply above rules to online images in option, and I suggest you check both of them to approve all pics managed by chevereto Choose PicGo.app in images Uploader and click Test Uploader to test your upload pictures automatically for more information ,youcan visit PicGo and PicGo-Core Upload your pictures in personal album instead of visitors’ albulm Chevereto API thanks Chevereto ShareX ioiox’s blog dana5haw’s blog]]></content>
      <categories>
        <category>Chevereto</category>
      </categories>
      <tags>
        <tag>pictureBed</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RabbitMQ]]></title>
    <url>%2F2020%2F09%2F14%2F2020-09-14-RabbitMQ%2F</url>
    <content type="text"><![CDATA[whatMQ-message queue 三足鼎立 rocketmq​​ -Made by Java 吞吐量高一些 阿里中间件 rabbitmq -Made by Erlang Kafka- 以后有更多的了解再补充性能/功能差距 why功能：解耦(双方通过mq交互)、异步、削峰 应用： 阿里双11 问题： 处理好新增的复杂性 处理好系统可用性 how之所以选择rabbitmq是因为rocketmq的nameserver所需要的内存太大了，更何况boker，对于1C2G的乞丐机器来说根本跑不起来 1.docker runBecause of rocketmq need more than 123456789docker pull rabbitmq:managementdocker run -dit --name rabbitmq -e RABBITMQ_DEFAULT_USER=admin -e RABBITMQ_DEFAULT_PASS=admin -p 15672:15672 -p 5672:5672 rabbitmq:management--name containername-e RABBITMQ_DEFAULT_USER 参数用户名，密码同理-p 端口映射，主机：容器，15672-UI，5672-servicerabbitmq:management image&#x27;s name 2.Usage1.open chrome and input ‘localhost:15672’ or ‘192.168.1.1:15672’ then you can touch rabbitmq UI Overview–the queued msg, msg rate in your server, some global counts, your nodes stats (if u use the above method,you only see one node in the screen ),you also can build a cluster with more nodes Connections– Channels– Exchanges–direct,fanout,headers,match,trace,topic Queses– Admin–users management with passport &amp;&amp; permission 2.use 5672 in your code 12345678amqp.connect(&#123; protocol: &#x27;amqp&#x27;, hostname: &#x27;example.com&#x27;,//localhost port: &#x27;5672&#x27;, username: &#x27;admin&#x27;, password: &#x27;xxx&#x27;, vhost: &#x27;/&#x27;,//important &#125;) more in official docs–&gt; I’m doc or some blogs–&gt;I’m blog or my GitHub–&gt;click here]]></content>
      <categories>
        <category>MQ</category>
      </categories>
      <tags>
        <tag>basic</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[EventLoop Source]]></title>
    <url>%2F2020%2F07%2F24%2F2020-07-23-EventLoop2%2F</url>
    <content type="text"><![CDATA[eventLoop之前也有过章节node整理Node.js 有看到石墨技术文档 cnode技术文档，作者：youth7 记录以下知识点： nodejs的event是基于libuv，浏览器的event loop则在html5的规范中明确定义，两个事物有明显的区别 process.nextTick()在6个阶段结束的时候都会执行 eventLoop timers 执行setTimeout() 和 setInterval()中到期的callback I/O callbacks 上一轮循环中有少数的I/Ocallback会被延迟到这一轮的这一阶段执行 idle, prepare 仅内部使用 poll 最为重要的阶段，执行I/O callback，在适当的条件下会阻塞在这个阶段 check 执行setImmediate的callback close callbacks 执行close事件的callback，例如socket.on(&quot;close&quot;,func) 123456789101112131415161718 ┌───────────────────────┐┌─&gt;│ timers ││ └──────────┬────────────┘│ ┌──────────┴────────────┐│ │ I/O callbacks ││ └──────────┬────────────┘│ ┌──────────┴────────────┐│ │ idle, prepare ││ └──────────┬────────────┘ ┌───────────────┐│ ┌──────────┴────────────┐ │ incoming: ││ │ poll │&lt;─────┤ connections, ││ └──────────┬────────────┘ │ data, etc. ││ ┌──────────┴────────────┐ └───────────────┘│ │ check ││ └──────────┬────────────┘│ ┌──────────┴────────────┐└──┤ close callbacks │ └───────────────────────┘ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657# /deps/uv/src/unix/core.cint uv_run(uv_loop_t* loop, uv_run_mode mode) &#123; int timeout; int r; int ran_pending; r = uv__loop_alive(loop); // if(uv_has_active_hanles||uv_has_active_reqs || lop-&gt;closing_handles!=NULL)retrun true if (!r) uv__update_time(loop); while (r != 0 &amp;&amp; loop-&gt;stop_flag == 0) &#123; uv__update_time(loop); // main uv__run_timers(loop);//timer phase ran_pending = uv__run_pending(loop);//IO callback pharse uv__run_idle(loop);//idle phase uv__run_prepare(loop);// prepare phase // main end timeout = 0; if ((mode == UV_RUN_ONCE &amp;&amp; !ran_pending) || mode == UV_RUN_DEFAULT) timeout = uv_backend_timeout(loop); uv__io_poll(loop, timeout);//poll phase uv__run_check(loop);//check phase uv__run_closing_handles(loop);//closing pharse if (mode == UV_RUN_ONCE) &#123; /* UV_RUN_ONCE implies forward progress: at least one callback must have * been invoked when it returns. uv__io_poll() can return without doing * I/O (meaning: no callbacks) when its timeout expires - which means we * have pending timers that satisfy the forward progress constraint. * * UV_RUN_NOWAIT makes no guarantees about progress so it&#x27;s omitted from * the check. */ // UV_RUN_ONCE 至少有一个回调执行,不然该循环就空转了，满足前进要求 // 这也是[文章](https://zehai.info/2020/04/10/2020-04-10-eventloop/)中写到： // poll为空，eventloop将检查timer是否有快到的，如果需要执行，eventloop将要进入timers阶段来顺序执行timer callback uv__update_time(loop); uv__run_timers(loop); &#125; r = uv__loop_alive(loop); if (mode == UV_RUN_ONCE || mode == UV_RUN_NOWAIT) break; &#125; /* The if statement lets gcc compile it to a conditional store. Avoids * dirtying a cache line. */ if (loop-&gt;stop_flag != 0) loop-&gt;stop_flag = 0; return r;&#125; timers phase执行setTimeout() 和 setInterval()中到期的callback 123456789101112131415161718192021void uv__run_timers(uv_loop_t* loop) &#123; struct heap_node* heap_node; uv_timer_t* handle; for (;;) &#123; heap_node = heap_min(timer_heap(loop)); if (heap_node == NULL) break; // 取出堆中最快要被执行的timer // #define container_of(ptr, type, member) // ((type *) ((char *) (ptr) - offsetof(type, member))) // 没看懂 handle是怎么生成的 handle = container_of(heap_node, uv_timer_t, heap_node); if (handle-&gt;timeout &gt; loop-&gt;time)//执行时间大于eventloop循环一次时间，退出phase下次再说 break; uv_timer_stop(handle);// remove handle uv_timer_again(handle);// 多次重复的timer再塞进去 handle-&gt;timer_cb(handle);// invoke callback &#125;&#125; I/O callbacks上一轮循环中有少数的I/Ocallback会被延迟到这一轮的这一阶段执行 123456789101112131415161718192021//deps/uv/src/unix/core.cstatic int uv__run_pending(uv_loop_t* loop) &#123; QUEUE* q; QUEUE pq; uv__io_t* w; if (QUEUE_EMPTY(&amp;loop-&gt;pending_queue))//isEmpty return 0; QUEUE_MOVE(&amp;loop-&gt;pending_queue, &amp;pq);//move while (!QUEUE_EMPTY(&amp;pq)) &#123; q = QUEUE_HEAD(&amp;pq);//find QUEUE_REMOVE(q);//pop QUEUE_INIT(q); w = QUEUE_DATA(q, uv__io_t, pending_queue); w-&gt;cb(loop, w, POLLOUT);//unitl queue empty &#125; return 1;&#125; Idle and prepare phase/ loop / void uv__run_idle(uv_loop_t* loop); void uv__run_check(uv_loop_t* loop); void uv__run_prepare(uv_loop_t* loop); 12345678910111213void uv__run_##name(uv_loop_t* loop) &#123; uv_##name##_t* h; QUEUE queue; QUEUE* q; QUEUE_MOVE(&amp;loop-&gt;name##_handles, &amp;queue);//QUEUE_MOVE while (!QUEUE_EMPTY(&amp;queue)) &#123;//util empty q = QUEUE_HEAD(&amp;queue);//pop h = QUEUE_DATA(q, uv_##name##_t, queue);//element-&gt;handle QUEUE_REMOVE(q);//remove QUEUE_INSERT_TAIL(&amp;loop-&gt;name##_handles, q);//insert tail h-&gt;name##_cb(h);//callback &#125;&#125; !!!poll phase!!!最为重要的阶段，执行I/O callback，在适当的条件下会阻塞在这个阶段 可见poll阶段的任务就是阻塞等待监听的事件来临，然后执行对应的callback，其中阻塞是带有超时时间的，以下几种情况都会使得超时时间为0 uv_run处于UV_RUN_NOWAIT模式下 uv_stop()被调用 没有活跃的handles和request 有活跃的idle handles 有等待关闭的handles 如果上述都不符合，则超时时间为距离现在最近的timer；如果没有timer则poll阶段会一直阻塞下去 个人理解nodejs的服务，大部分时间会被阻塞在这个阶段，而不去执行closing 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195// 不行了，看不懂了void uv__io_poll(uv_loop_t* loop, int timeout) &#123; struct pollfd events[1024]; struct pollfd pqry; struct pollfd* pe; struct poll_ctl pc; QUEUE* q; uv__io_t* w; uint64_t base; uint64_t diff; int have_signals; int nevents; int count; int nfds; int i; int rc; int add_failed; if (loop-&gt;nfds == 0) &#123; assert(QUEUE_EMPTY(&amp;loop-&gt;watcher_queue)); return; &#125; while (!QUEUE_EMPTY(&amp;loop-&gt;watcher_queue)) &#123;//until watcher queue empty q = QUEUE_HEAD(&amp;loop-&gt;watcher_queue); QUEUE_REMOVE(q); QUEUE_INIT(q); w = QUEUE_DATA(q, uv__io_t, watcher_queue); assert(w-&gt;pevents != 0); assert(w-&gt;fd &gt;= 0); assert(w-&gt;fd &lt; (int) loop-&gt;nwatchers); pc.events = w-&gt;pevents; pc.fd = w-&gt;fd; add_failed = 0; if (w-&gt;events == 0) &#123; pc.cmd = PS_ADD; if (pollset_ctl(loop-&gt;backend_fd, &amp;pc, 1)) &#123; if (errno != EINVAL) &#123; assert(0 &amp;&amp; &quot;Failed to add file descriptor (pc.fd) to pollset&quot;); abort(); &#125; /* Check if the fd is already in the pollset */ pqry.fd = pc.fd; rc = pollset_query(loop-&gt;backend_fd, &amp;pqry); switch (rc) &#123; case -1: assert(0 &amp;&amp; &quot;Failed to query pollset for file descriptor&quot;); abort(); case 0: assert(0 &amp;&amp; &quot;Pollset does not contain file descriptor&quot;); abort(); &#125; /* If we got here then the pollset already contained the file descriptor even though * we didn&#x27;t think it should. This probably shouldn&#x27;t happen, but we can continue. */ add_failed = 1; &#125; &#125; if (w-&gt;events != 0 || add_failed) &#123; /* Modify, potentially removing events -- need to delete then add. * Could maybe mod if we knew for sure no events are removed, but * content of w-&gt;events is handled above as not reliable (falls back) * so may require a pollset_query() which would have to be pretty cheap * compared to a PS_DELETE to be worth optimizing. Alternatively, could * lazily remove events, squelching them in the mean time. */ pc.cmd = PS_DELETE; if (pollset_ctl(loop-&gt;backend_fd, &amp;pc, 1)) &#123; assert(0 &amp;&amp; &quot;Failed to delete file descriptor (pc.fd) from pollset&quot;); abort(); &#125; pc.cmd = PS_ADD; if (pollset_ctl(loop-&gt;backend_fd, &amp;pc, 1)) &#123; assert(0 &amp;&amp; &quot;Failed to add file descriptor (pc.fd) to pollset&quot;); abort(); &#125; &#125; w-&gt;events = w-&gt;pevents; &#125; assert(timeout &gt;= -1); base = loop-&gt;time; count = 48; /* Benchmarks suggest this gives the best throughput. */ for (;;) &#123; nfds = pollset_poll(loop-&gt;backend_fd, events, ARRAY_SIZE(events), timeout); /* Update loop-&gt;time unconditionally. It&#x27;s tempting to skip the update when * timeout == 0 (i.e. non-blocking poll) but there is no guarantee that the * operating system didn&#x27;t reschedule our process while in the syscall. */ SAVE_ERRNO(uv__update_time(loop)); if (nfds == 0) &#123; assert(timeout != -1); return; &#125; if (nfds == -1) &#123; if (errno != EINTR) &#123; abort(); &#125; if (timeout == -1) continue; if (timeout == 0) return; /* Interrupted by a signal. Update timeout and poll again. */ goto update_timeout; &#125; have_signals = 0; nevents = 0; assert(loop-&gt;watchers != NULL); loop-&gt;watchers[loop-&gt;nwatchers] = (void*) events; loop-&gt;watchers[loop-&gt;nwatchers + 1] = (void*) (uintptr_t) nfds; for (i = 0; i &lt; nfds; i++) &#123; pe = events + i; pc.cmd = PS_DELETE; pc.fd = pe-&gt;fd; /* Skip invalidated events, see uv__platform_invalidate_fd */ if (pc.fd == -1) continue; assert(pc.fd &gt;= 0); assert((unsigned) pc.fd &lt; loop-&gt;nwatchers); w = loop-&gt;watchers[pc.fd]; if (w == NULL) &#123; /* File descriptor that we&#x27;ve stopped watching, disarm it. * * Ignore all errors because we may be racing with another thread * when the file descriptor is closed. */ pollset_ctl(loop-&gt;backend_fd, &amp;pc, 1); continue; &#125; /* Run signal watchers last. This also affects child process watchers * because those are implemented in terms of signal watchers. */ if (w == &amp;loop-&gt;signal_io_watcher) have_signals = 1; else w-&gt;cb(loop, w, pe-&gt;revents); nevents++; &#125; if (have_signals != 0) loop-&gt;signal_io_watcher.cb(loop, &amp;loop-&gt;signal_io_watcher, POLLIN); loop-&gt;watchers[loop-&gt;nwatchers] = NULL; loop-&gt;watchers[loop-&gt;nwatchers + 1] = NULL; if (have_signals != 0) return; /* Event loop should cycle now so don&#x27;t poll again. */ if (nevents != 0) &#123; if (nfds == ARRAY_SIZE(events) &amp;&amp; --count != 0) &#123; /* Poll for more events but don&#x27;t block this time. */ timeout = 0; continue; &#125; return; &#125; if (timeout == 0) return; if (timeout == -1) continue;update_timeout: assert(timeout &gt; 0); diff = loop-&gt;time - base; if (diff &gt;= (uint64_t) timeout) return; timeout -= diff; &#125;&#125; check phase见idle prepare close关闭handle 12345678910111213static void uv__run_closing_handles(uv_loop_t* loop) &#123; uv_handle_t* p; uv_handle_t* q; p = loop-&gt;closing_handles; loop-&gt;closing_handles = NULL; while (p) &#123; q = p-&gt;next_closing; uv__finish_close(p); p = q; &#125;&#125; where is process.nextTick12345678910111213141516171819202122232425262728293031323334353637383940//lib/internal/process/task_queues.js// `nextTick()` will not enqueue any callback when the process is about to// exit since the callback would not have a chance to be executed.// 意思就是nextTick在进程快要结束时不会排队callback,因为没有机会执行// 你们看引用的文档吧，我看不下去了😭// 主要的思路是JS执行process.nexTick()，然后将callback交给c++执行function nextTick(callback) &#123; if (typeof callback !== &#x27;function&#x27;) throw new ERR_INVALID_CALLBACK(callback); if (process._exiting) return; let args; switch (arguments.length) &#123; case 1: break; case 2: args = [arguments[1]]; break; case 3: args = [arguments[1], arguments[2]]; break; case 4: args = [arguments[1], arguments[2], arguments[3]]; break; default: args = new Array(arguments.length - 1); for (let i = 1; i &lt; arguments.length; i++) args[i - 1] = arguments[i]; &#125; if (queue.isEmpty()) setHasTickScheduled(true); const asyncId = newAsyncId(); const triggerAsyncId = getDefaultTriggerAsyncId(); const tickObject = &#123; [async_id_symbol]: asyncId, [trigger_async_id_symbol]: triggerAsyncId, callback, args &#125;; if (initHooksExist()) emitInit(asyncId, &#x27;TickObject&#x27;, triggerAsyncId, tickObject); queue.push(tickObject);//封装callback push //进入c&#125; question1.setTimeout vs setImmediate phase执行顺序 expire设置0是不是立刻执行 1234567setTimeout(() =&gt; &#123; console.log(&#x27;setTimeout&#x27;)&#125;, 0)setImmediate(() =&gt; &#123; console.log(&#x27;setImmediate&#x27;)&#125;) setTimeout/setInterval 的第二个参数取值范围是：[1, 2^31 - 1]，如果超过这个范围则会初始化为 1，即 setTimeout(fn, 0) === setTimeout(fn, 1)。 setTimeout 的回调函数在 timer 阶段执行，setImmediate 的回调函数在 check 阶段执行，event loop 的开始会先检查 timer 阶段，但是在开始之前到 timer 阶段会消耗一定时间，所以就会出现两种情况： timer 前的准备时间超过 1ms，满足 loop-&gt;time &gt;= 1，则执行 timer 阶段（setTimeout）的回调函数 timer 前的准备时间小于 1ms，则先执行 check 阶段（setImmediate）的回调函数，下一次 event loop 执行 timer 阶段（setTimeout）的回调函数 在举例： 12345678910setTimeout(() =&gt; &#123; console.log(&#x27;setTimeout&#x27;)&#125;, 0)setImmediate(() =&gt; &#123; console.log(&#x27;setImmediate&#x27;)&#125;)const start = Date.now()while (Date.now() - start &lt; 10);//准备时间超过1ms，则直接执行timer 2.setTimeout vs setImmediate 212345678910111213const fs = require(&#x27;fs&#x27;)fs.readFile(__filename, () =&gt; &#123; setTimeout(() =&gt; &#123; console.log(&#x27;setTimeout&#x27;) &#125;, 0) setImmediate(() =&gt; &#123; console.log(&#x27;setImmediate&#x27;) &#125;)&#125;)//setImmediate//setTimeout 在引用一下官方对于check phase的介绍 This phase allows a person to execute callbacks immediately after the poll phase has completed. If the poll phase becomes idle and scripts have been queued with setImmediate(), the event loop may continue to the check phase rather than waiting. setImmediate() is actually a special timer that runs in a separate phase of the event loop. It uses a libuv API that schedules callbacks to execute after the poll phase has completed. Generally, as the code is executed, the event loop will eventually hit the poll phase where it will wait for an incoming connection, request, etc. However, if a callback has been scheduled with setImmediate() and the poll phase becomes idle, it will end and continue to the check phase rather than waiting for poll events. fs.readFile 的回调函数执行完后： 注册 setTimeout 的回调函数到 timer 阶段 注册 setImmediate 的回调函数到 check 阶段 event loop 从 pool 阶段出来继续往下一个阶段执行，恰好是 check 阶段，所以 setImmediate 的回调函数先执行 本次 event loop 结束后，进入下一次 event loop，执行 setTimeout 的回调函数 所以，在 I/O Callbacks 中注册的 setTimeout 和 setImmediate，永远都是 setImmediate 先执行。 3.process.nextTick()123456789101112setInterval(() =&gt; &#123; console.log(&#x27;setInterval&#x27;)&#125;, 100)process.nextTick(function tick () &#123; process.nextTick(tick)&#125;)//notesetImmediate(function immediate () &#123; console.log(&#x27;111&#x27;);//会直接打印出很多次111 setImmediate(immediate)&#125;) 运行结果：setInterval 永远不会打印出来。 //这个在node官方文档也有相关的描述 //我在这里也进行了笔记记录 //允许用户处理errors，清理不需要的资源，事件循环前 尝试重新连接 //有时有必要在eventloop继续之前，在call stack unwound之后，让callback执行 解释：process.nextTick 会无限循环，将 event loop 阻塞在 microtask 阶段，导致 event loop 上其他 macrotask 阶段的回调函数没有机会执行。//这段解释是前端的，后端是没有microtask的实际队列的 解决方法通常是用 setImmediate 替代 process.nextTick，如下： 1234567setInterval(() =&gt; &#123; console.log(&#x27;setInterval&#x27;)&#125;, 100)setImmediate(function immediate () &#123; setImmediate(immediate)&#125;) 运行结果：每 100ms 打印一次 setInterval。 解释：process.nextTick 内执行 process.nextTick 仍然将 tick 函数注册到当前 microtask 的尾部，所以导致 microtask 永远执行不完； setImmediate 内执行 setImmediate 会将 immediate 函数注册到下一次 event loop 的 check 阶段，而不是当前正在执行的 check 阶段，所以给了 event loop 上其他 macrotask 执行的机会。 再看个例子： 12345678910111213setImmediate(() =&gt; &#123; console.log(&#x27;setImmediate1&#x27;) setImmediate(() =&gt; &#123; console.log(&#x27;setImmediate2&#x27;) &#125;) process.nextTick(() =&gt; &#123; console.log(&#x27;nextTick&#x27;) &#125;)&#125;)setImmediate(() =&gt; &#123; console.log(&#x27;setImmediate3&#x27;)&#125;) 运行结果： 1234setImmediate1setImmediate3nextTicksetImmediate2 注意：并不是说 setImmediate 可以完全替代 process.nextTick，process.nextTick 在特定场景下还是无法被替代的，比如我们就想将一些操作放到最近的 microtask 里执行。 4.promise12345const promise = Promise.resolve() .then(() =&gt; &#123; return promise &#125;)promise.catch(console.error) 运行结果： 123456TypeError: Chaining cycle detected for promise #&lt;Promise&gt; at &lt;anonymous&gt; at process._tickCallback (internal/process/next_tick.js:188:7) at Function.Module.runMain (module.js:667:11) at startup (bootstrap_node.js:187:16) at bootstrap_node.js:607:3 解释：promise.then 类似于 process.nextTick，都会将回调函数注册到 microtask 阶段。上面代码会导致死循环，类似前面提到的： 123process.nextTick(function tick () &#123; process.nextTick(tick)&#125;) 再看个例子： 123456789const promise = Promise.resolve()promise.then(() =&gt; &#123; console.log(&#x27;promise&#x27;)&#125;)process.nextTick(() =&gt; &#123; console.log(&#x27;nextTick&#x27;)&#125;) 运行结果： 12nextTickpromise 解释：promise.then 虽然和 process.nextTick 一样，都将回调函数注册到 microtask，但优先级不一样。process.nextTick 的 microtask queue 总是优先于 promise 的 microtask queue 执行。 5.promise执行顺序1234567891011121314setTimeout(() =&gt; &#123; console.log(1)&#125;, 0)new Promise((resolve, reject) =&gt; &#123; console.log(2) for (let i = 0; i &lt; 10000; i++) &#123; i === 9999 &amp;&amp; resolve() &#125; console.log(3)&#125;).then(() =&gt; &#123; console.log(4)&#125;)console.log(5) 运行结果： 1234523541 解释：Promise 构造函数是同步执行的，所以先打印 2、3，然后打印 5，接下来 event loop 进入执行 microtask 阶段，执行 promise.then 的回调函数打印出 4，然后执行下一个 macrotask，恰好是 timer 阶段的 setTimeout 的回调函数，打印出 1。 6.综合12345678910111213141516171819202122232425setImmediate(() =&gt; &#123; console.log(1) setTimeout(() =&gt; &#123; console.log(2) &#125;, 100) setImmediate(() =&gt; &#123; console.log(3) &#125;) process.nextTick(() =&gt; &#123; console.log(4) &#125;)&#125;)process.nextTick(() =&gt; &#123; console.log(5) setTimeout(() =&gt; &#123; console.log(6) &#125;, 100) setImmediate(() =&gt; &#123; console.log(7) &#125;) process.nextTick(() =&gt; &#123; console.log(8) &#125;)&#125;)console.log(9) 运行结果： 123456789958174362 process.nextTick、setTimeout 和 setImmediate 的组合，请读者自己推理吧。 other source codesetTimeout()12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849//lib/timers/promises.js//setTimeout(function()&#123;&#125;,expire)function setTimeout(after, value, options = &#123;&#125;) &#123; const args = value !== undefined ? [value] : value; if (options == null || typeof options !== &#x27;object&#x27;) &#123; return PromiseReject( new ERR_INVALID_ARG_TYPE( &#x27;options&#x27;, &#x27;Object&#x27;, options)); &#125; const &#123; signal, ref = true &#125; = options; if (signal !== undefined &amp;&amp; (signal === null || typeof signal !== &#x27;object&#x27; || !(&#x27;aborted&#x27; in signal))) &#123; return PromiseReject( new ERR_INVALID_ARG_TYPE( &#x27;options.signal&#x27;, &#x27;AbortSignal&#x27;, signal)); &#125; if (typeof ref !== &#x27;boolean&#x27;) &#123; return PromiseReject( new ERR_INVALID_ARG_TYPE( &#x27;options.ref&#x27;, &#x27;boolean&#x27;, ref)); &#125; // TODO(@jasnell): If a decision is made that this cannot be backported // to 12.x, then this can be converted to use optional chaining to // simplify the check. if (signal &amp;&amp; signal.aborted) return PromiseReject(lazyDOMException(&#x27;AbortError&#x27;)); return new Promise((resolve, reject) =&gt; &#123; const timeout = new Timeout(resolve, after, args, false, true); if (!ref) timeout.unref(); insert(timeout, timeout._idleTimeout); if (signal) &#123; signal.addEventListener(&#x27;abort&#x27;, () =&gt; &#123; if (!timeout._destroyed) &#123; // eslint-disable-next-line no-undef clearTimeout(timeout); reject(lazyDOMException(&#x27;AbortError&#x27;)); &#125; &#125;, &#123; once: true &#125;); &#125; &#125;);&#125;]]></content>
      <categories>
        <category>Node</category>
      </categories>
      <tags>
        <tag>source</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法图解]]></title>
    <url>%2F2020%2F06%2F08%2F2020-06-08-%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[1. 算法简介1.1 二分Why: 复杂度O(n)—&gt;O(logn) 使用限制：有序数组 1.2 大O表示指出算法运行时间的增速，算法需要做的就是把O(n^2)优化到O(n)等 2. 选择排序2.1 数组 链表数组：连续物理空间，可随机访问，增删数据复杂度高 链表：分散无力空间，不可随机访问（只能顺序），增删数据复杂度低 数组 链表 读改 O(1) O(n) 增删 O(n) O(1) 根据互相特性，选择合适的方式，如频繁增删用链表，反之用数组 2.2 选择排序复杂度：O(n^2) 遍历n 个元素选择 最小/大的，遍历n-1个元素选择 最小/大的 3. 递归类比：套娃 :call_me_hand: 性能和易读不可兼得 避免死循环！ 尾递归可以解决部分性能问题 递归调用栈是性能降低的原因，遵循FIFO 4. 快排核心：分而治之divide and conquer，快排只是其中的一个应用 思想：递归的一种应用 快排（递归）是一种函数式编程 快排通过基准值（可以选第一个元素）进行分而治之 5. 散列表实现方式：数组，非链表，检索值key类似数组的下表，可直接访问value 应用：DNS，阻止重复数据(类set集)，作缓存（服务器端） 复杂度 散列平均 散列最糟 数组 链表 查找 1 n 1 n 插入删除 1 n n 1 装填因子（0.4）=散列元素（4）/位置总数（10） 避免冲突：1.良好的散列函数（均匀分布） 2.较低的装填因子（&lt;0.7） 将满时候：1.申请两倍于原来的 新空间 2.hash所有元素到新空间 冲突解决： 开放地址（最简单就是冲突顺延下一位，直到为空） 拉链发（指在某个位子上再拉一条链表，非👖拉链） 6.BFS广度优先搜索breadth first search，解决无加权最短路径问题之一 应用：国际跳棋，拼写检查，人际关系网络 7. Dijkstra正加权有向无环图的解决算法 最短时间内到达的节点 更新该节点临接节点的开销 重复 计算最终路径 解决环： 负加权：bellman ford algorithm 8. Greedy每步最优–&gt;全局最优，得到近似正确的结果 9.DP列出所有可能 10. K最邻近算法11.next树解决了二分查找中，插入删除O(n)降低到O(log n)，但是降低了随机访问能力 树包括：二叉树，平衡二叉树，B树 B+树，，红黑树 反向索引：散列表，用于创建搜索引擎—&gt;应用：傅里叶变换 并行算法，单机并行or分布式，应用：mapreduce，map-&gt;映射 ，reduce-&gt;归并 布隆过滤器：庞大的散列表（如谷歌的上亿条），通常使用redis实现，是一种概率型数据结构（偶尔出错），使用理由，存储空间少 hyperLogLog：类似布隆，是个日志 SHA算法 散列的一种应用 判断两个（超大）文件是否相同（散列值相同） SHA（用户输入密码）？== 数据库存储的SHA值，且拖库后无法还原密码 SHA是一系列算法的统称，包括SHA-0 ,SHA-1 SHA-2 SHA-3 bcrypt etc SHA全局敏感（改动局部，整体全变），SIMhash局部敏感（局部改变，散列值局部改变），后者用于判断网页是否已经搜集，作业是否抄袭，相似度查询 diffie-hellman密钥交换 双方无需知道加密算法，破解难度大 公钥与私钥，client获取公钥后，1.使用公钥加密 2.服务器端使用私钥解密 线性规划：simplex算法]]></content>
      <categories>
        <category>Books</category>
      </categories>
      <tags>
        <tag>算法图解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2020-05-25-FirstUniqueCharacterInAString]]></title>
    <url>%2F2020%2F05%2F30%2F2020-05-25-FirstUniqueCharacterInAString%2F</url>
    <content type="text"><![CDATA[Leetcode-6412345678910Given a string, find the first non-repeating character in it and return it&#39;s index. If it doesn&#39;t exist, return -1.Examples:s &#x3D; &quot;leetcode&quot;return 0.s &#x3D; &quot;loveleetcode&quot;,return 2.Note: You may assume the string contain only lowercase letters. solution12345678910111213141516&#x2F;** * @param &#123;string&#125; s * @return &#123;number&#125; *&#x2F;var firstUniqChar &#x3D; function(s) &#123; for(var i&#x3D;0;i&lt;s.length;i++)&#123; var flag &#x3D; false; for(var j&#x3D;0;j&lt;s.length;j++)&#123; if(i&#x3D;&#x3D;j)continue; if(s[i]&#x3D;&#x3D;s[j])flag&#x3D;true; &#125; if(!flag)return i; &#125; return -1;&#125;; 123456789101112131415161718class Solution &#123; public int firstUniqChar(String s) &#123; HashMap&lt;Character, Integer&gt; count &#x3D; new HashMap&lt;Character, Integer&gt;(); int n &#x3D; s.length(); &#x2F;&#x2F; build hash map : character and how often it appears for (int i &#x3D; 0; i &lt; n; i++) &#123; char c &#x3D; s.charAt(i); count.put(c, count.getOrDefault(c, 0) + 1); &#125; &#x2F;&#x2F; find the index for (int i &#x3D; 0; i &lt; n; i++) &#123; if (count.get(s.charAt(i)) &#x3D;&#x3D; 1) return i; &#125; return -1; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Easy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[monit]]></title>
    <url>%2F2020%2F05%2F13%2F2020-05-13-%E7%9B%91%E6%8E%A7%E8%BD%AF%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[监控 后端prometheus vs zabbix 先对两者的各自特点进行一下对比： Zabbix Prometheus 后端用 C 开发，界面用 PHP 开发，定制化难度很高。 后端用 golang 开发，前端是 Grafana，JSON 编辑即可解决。定制化难度较低。 集群规模上限为 10000 个节点。 支持更大的集群规模，速度也更快。 更适合监控物理机环境。 更适合云环境的监控，对 OpenStack，Kubernetes 有更好的集成。 监控数据存储在关系型数据库内，如 MySQL，很难从现有数据中扩展维度。 监控数据存储在基于时间序列(TSDB)的数据库内，便于对已有数据进行新的聚合。 安装简单，zabbix-server 一个软件包中包括了所有的服务端功能。 安装相对复杂，监控、告警和界面都分属于不同的组件。 图形化界面比较成熟，界面上基本上能完成全部的配置操作。 界面相对较弱，很多配置需要修改配置文件。 发展时间更长，对于很多监控场景，都有现成的解决方案。 2015 年后开始快速发展，但发展时间较短，成熟度不及 Zabbix。 由于最后敲定了Prometheus方案，对于zabbix就云评测了，欢迎指正 虽然图形化界面弱化，很多配置走yml文件，但图形化界面真的没有必要 时序数据库，高并发下好于mysql（不然干嘛开发tsdb应对监控场景） prom支持pull和push模型，可以支持k8s，swarm等服务发现 前端Performance？webVitals？以后用到再补充 主要关注性能，pv，redirect，err等问题 页面是否可用阿里云-云监控控制台 可提供网址监控，包括cookie, headers 等自定义的简单配置，进行电话，邮件，短信，旺旺等报警]]></content>
      <categories>
        <category>monit</category>
      </categories>
      <tags>
        <tag>intro</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Node.JSv14]]></title>
    <url>%2F2020%2F04%2F22%2F2020-04-22-Node14%2F</url>
    <content type="text"><![CDATA[newmod今天看到Node Current更新了14的版本，看看都有些什么东西 前置了解了一下doc中提到的semver，是一个语义化版本semantic versioning，实现版本和版本规范的解析，计算，比较，用以解决在大型项目中对依赖的版本失去控制的问题，Node.js 的包管理工具 npm 也完全基于 Semantic Versioning 来管理依赖的版本。 参考资料：semver：语义化版本规范在 Node.js 中的实现 deprecationssermver弃用一部分功能 (SEMVER-MAJOR) crypto: move pbkdf2 without digest to EOL (James M Snell) (SEMVER-MAJOR) fs: deprecate closing FileHandle on garbage collection (James M Snell) (SEMVER-MAJOR) http: move OutboundMessage.prototype.flush to EOL (James M Snell) (SEMVER-MAJOR) lib: move GLOBAL and root aliases to EOL (James M Snell) (SEMVER-MAJOR) os: move tmpDir() to EOL (James M Snell) (SEMVER-MAJOR) src: remove deprecated wasm type check (Clemens Backes) (SEMVER-MAJOR) stream: move _writableState.buffer to EOL (James M Snell) (SEMVER-MINOR) doc: deprecate process.mainModule (Antoine du HAMEL) (SEMVER-MINOR) doc: deprecate process.umask() with no arguments (Colin Ihrig) ECMAScript Modules在 v13 中，需要调用 --experimental-modules 来开启 ESM module 支持， 而且还会有警告，但目前已经移除警告（还是需要手动开启）仍在实验中，但是其已经非常完善，移除警告迈向了stable的重要一步 New V8 ArrayBuffer APIv8不再支持多个ArrayBuffer指向相同的base address Toolchain and Compiler Upgrades//没看懂 (SEMVER-MAJOR) build: update macos deployment target to 10.13 for 14.x (AshCripps) #32454 (SEMVER-MAJOR) doc: update cross compiler machine for Linux armv7 (Richard Lau) #32812 (SEMVER-MAJOR) doc: update Centos/RHEL releases use devtoolset-8 (Richard Lau) #32812 (SEMVER-MAJOR) doc: remove SmartOS from official binaries (Richard Lau) #32812 (SEMVER-MAJOR) win: block running on EOL Windows versions (João Reis) #31954 It is expected that there will be an ABI mismatch on ARM between the Node.js binary and native addons. Native addons are only broken if they interact with std::shared_ptr. This is expected to be fixed in a later version of Node.js 14. Update to V8 8.1Others cli, report: move –report-on-fatalerror to stable (Colin Ihrig) deps: upgrade to libuv 1.37.0 (Colin Ihrig) fs: add fs/promises alias module]]></content>
      <categories>
        <category>Node</category>
      </categories>
      <tags>
        <tag>14</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCodeWeek2]]></title>
    <url>%2F2020%2F04%2F19%2F2020-04-19-LeetCodeWeek1%2F</url>
    <content type="text"><![CDATA[Problem Product of Array Except SelfGiven an array nums of n integers where n &gt; 1, return an array output such that output[i] is equal to the product of all the elements of nums except nums[i]. Example: 12Input: [1,2,3,4]Output: [24,12,8,6] Constraint: It’s guaranteed that the product of the elements of any prefix or suffix of the array (including the whole array) fits in a 32 bit integer. Note: Please solve it without division and in O(n). Follow up:Could you solve it with constant space complexity? (The output array does not count as extra space for the purpose of space complexity analysis.) keysolution1234567891011121314151617181920212223242526272829&#x2F;&#x2F;3msclass Solution &#123; public int[] productExceptSelf(int[] nums) &#123; int sum &#x3D;1; int hasZero &#x3D;0; for(int num :nums)&#123; if(num!&#x3D;0)&#123; sum*&#x3D;num; &#125;else&#123; hasZero++; &#125; &#125; for(int i&#x3D;0;i&lt;nums.length;i++)&#123; if(hasZero&gt;&#x3D;2)&#123; nums[i]&#x3D;0; &#125;else if(hasZero&#x3D;&#x3D;1)&#123; if(nums[i]&#x3D;&#x3D;0)&#123; nums[i]&#x3D;sum; &#125;else&#123; nums[i]&#x3D;0; &#125; &#125;else&#123; nums[i]&#x3D;sum&#x2F;nums[i]; &#125; &#125; return nums; &#125;&#125; 1234567891011121314151617&#x2F;&#x2F;1msclass Solution &#123; public int[] productExceptSelf(int[] nums) &#123; int n &#x3D; nums.length; int[] left &#x3D; new int[n]; left[0] &#x3D; 1; for (int i &#x3D; 1; i &lt; n; i++) &#123; left[i] &#x3D; left[i-1] * nums[i-1]; &#125; int product &#x3D; 1; for (int i &#x3D; n - 1; i &gt;&#x3D; 0; i--) &#123; left[i] *&#x3D; product; product *&#x3D; nums[i]; &#125; return left; &#125;&#125; Problem-678Valid Parenthesis StringMedium Given a string containing only three types of characters: ‘(‘, ‘)’ and ‘*’, write a function to check whether this string is valid. We define the validity of a string by these rules: Any left parenthesis &#39;(&#39; must have a corresponding right parenthesis &#39;)&#39;. Any right parenthesis &#39;)&#39; must have a corresponding left parenthesis &#39;(&#39;. Left parenthesis &#39;(&#39; must go before the corresponding right parenthesis &#39;)&#39;. &#39;*&#39; could be treated as a single right parenthesis &#39;)&#39; or a single left parenthesis &#39;(&#39; or an empty string. An empty string is also valid. Example 1: 12Input: &quot;()&quot;Output: True Example 2: 12Input: &quot;(*)&quot;Output: True Example 3: 12Input: &quot;(*))&quot;Output: True Note: The string size will be in the range [1, 100]. keysolution123456789101112131415161718192021222324class Solution &#123; public boolean checkValidString(String s) &#123; if (s.length() == 0) return true; int left = 0;int star=0; char[] c = s.toCharArray(); for (char i : c) &#123; switch (i) &#123; case &#x27;(&#x27;: left++; break; case &#x27;)&#x27;: left--; break; case &#x27;*&#x27;: star++; break; default: break; &#125; &#125; if (left == 0 || left - star == 0 || left + star == 0) return true; return false; &#125;&#125; Brute Force12345678910111213141516171819202122232425262728293031323334 class Solution &#123; boolean ans = false; public boolean checkValidString(String s) &#123; solve(new StringBuilder(s), 0); return ans; &#125; public void solve(StringBuilder sb, int i) &#123; if (i == sb.length()) &#123; ans |= valid(sb); &#125; else if (sb.charAt(i) == &#x27;*&#x27;) &#123; for (char c: &quot;() &quot;.toCharArray()) &#123; sb.setCharAt(i, c); solve(sb, i+1); if (ans) return; &#125; sb.setCharAt(i, &#x27;*&#x27;); &#125; else solve(sb, i + 1); &#125; public boolean valid(StringBuilder sb) &#123; int bal = 0; for (int i = 0; i &lt; sb.length(); i++) &#123; char c = sb.charAt(i); if (c == &#x27;(&#x27;) bal++; if (c == &#x27;)&#x27;) bal--; if (bal &lt; 0) break; &#125; return bal == 0; &#125;&#125; Dynamic Programming123456789101112131415161718192021222324252627282930313233class Solution &#123; public boolean checkValidString(String s) &#123; int n = s.length(); if (n == 0) return true; boolean[][] dp = new boolean[n][n]; for (int i = 0; i &lt; n; i++) &#123; if (s.charAt(i) == &#x27;*&#x27;) dp[i][i] = true; if (i &lt; n-1 &amp;&amp; (s.charAt(i) == &#x27;(&#x27; || s.charAt(i) == &#x27;*&#x27;) &amp;&amp; (s.charAt(i+1) == &#x27;)&#x27; || s.charAt(i+1) == &#x27;*&#x27;)) &#123; dp[i][i+1] = true; &#125; &#125; for (int size = 2; size &lt; n; size++) &#123; for (int i = 0; i + size &lt; n; i++) &#123; if (s.charAt(i) == &#x27;*&#x27; &amp;&amp; dp[i+1][i+size] == true) &#123; dp[i][i+size] = true; &#125; else if (s.charAt(i) == &#x27;(&#x27; || s.charAt(i) == &#x27;*&#x27;) &#123; for (int k = i+1; k &lt;= i+size; k++) &#123; if ((s.charAt(k) == &#x27;)&#x27; || s.charAt(k) == &#x27;*&#x27;) &amp;&amp; (k == i+1 || dp[i+1][k-1]) &amp;&amp; (k == i+size || dp[k+1][i+size])) &#123; dp[i][i+size] = true; &#125; &#125; &#125; &#125; &#125; return dp[0][n-1]; &#125;&#125; Greedy123456789101112class Solution &#123; public boolean checkValidString(String s) &#123; int lo = 0, hi = 0; for (char c: s.toCharArray()) &#123; lo += c == &#x27;(&#x27; ? 1 : -1; hi += c != &#x27;)&#x27; ? 1 : -1; if (hi &lt; 0) break; lo = Math.max(lo, 0); &#125; return lo == 0; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Easy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[同一宿主机下docker互相访问]]></title>
    <url>%2F2020%2F04%2F16%2F2020-04-16-%E5%90%8C%E4%B8%80%E5%AE%BF%E4%B8%BB%E6%9C%BA%E4%B8%8Bdocker%E4%BA%92%E7%9B%B8%E8%AE%BF%E9%97%AE%2F</url>
    <content type="text"><![CDATA[what该文档解决：docker下，altermanager收不到prometheus消息 事因，我在一个宿主机下建立了多个docker容器 node-exporter prometheus grafana alertmanager timonwong/prometheus-webhook-dingtalk 这些服务之间会有一些互相访问，如prometheus可以发送数据给alertmanager来发送报警信息，alertmanager通过规则处理可以发送邮件，发送钉钉等方式告知用户，问题就出在prometheus的yml配置文档中： 1234567891011alerting: alertmanagers: - static_configs: - targets: [&#x27;localhost:9002&#x27;] ###############修改后：alerting: alertmanagers: - static_configs: - targets: [&#x27;10.10.10.10:9002&#x27;] 问题出在了prometheus的配置中访问了localhost端口，但这个并不是访问宿主机的9002的端口，而是访问的是docker内部的9002端口 找到问题后，使用了宿主机ip+port的方式进行访问 how查询了资料后，发现解决该问题的方法有： 宿主ip：port访问 容器ip访问 link建立通信网络(单向，不推荐)–link xxx user-defined networks（docker dns server/bridge） 前两种不太推荐，因为如果容器ip更改或者宿主机ip更改就需要更新配置文档，第三种方法不太推荐，run 时候link只是单向的建立连接，第四种docker network create： 1234&#x2F;&#x2F;创建网络docker network create -d bridge my-bridge-network&#x2F;&#x2F;run时候加入网络docker run -it --network test-network --network-alias mysql -e MYSQL_ROOT_PASSWORD&#x3D;123 mysql:5.7]]></content>
      <categories>
        <category>Question</category>
      </categories>
      <tags>
        <tag>整理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[node整理]]></title>
    <url>%2F2020%2F04%2F10%2F2020-04-10-eventloop%2F</url>
    <content type="text"><![CDATA[Whateventloop使得单线程机制的node实现非阻塞I/O的机制，将任务通过libuv分发给线程池后，交由系统内核完成（多线程），完成后内核通知nodejs，将回调放入poll队列执行 启动nodejs时，eventloop初始化，进程会输入很多script，包括： async API calls 定时器 process.nextTick() eventloop有六个队列 timers pending callbacks idle,prepare poll(connections,data,etc) check close callbacks 这些队列被称作phase,每个phase都是一个可以放callback的FIFO队列，当进入一个phase时，队列将执行完phase中的callback或者执行最大数目的callback后将进入另一个phase timers：执行定时器，包括setTimeout，setInerval pending callbacks 执行延迟到下一个循环的I/O callback idle，prepare 处理系统内部 poll：检查新的I/O事件，执行I/O回调,node会适当的在此阻塞 check:setImmediate() close：关闭回调函数，如：socket.on(‘close’,foo()) DetailTimers设定延迟后，timers会在规定的时间执行，但存在情况延迟，如poll phase执行回调，超过了timer设定的时间。因为poll必须完成一个任务后才可以检查最近的定时器，没到时间就执行下一个callback，执行callback期间无法中断 可以得出结论：poll控制着定时器何时执行 另外为了防止poll phase 变成恶汉，libuv 制定了一个依赖于系统的硬性最大值，来停止轮询获取更多事件 pending callbacks该队列在系统错误时执行回调（如TCP err），如TCP socket尝试重连收到了ECONNREFUSED，系统需要这些错误报告，那这个错误报告回调就会放在pending callbacks中等待被执行 poll最重要的阶段，poll主要包含两个功能： 计算阻塞和轮询的IO时间 执行poll 队列里的events 当eventloop进入poll阶段，并没有timers的时候 poll不为空，顺序同步执行任务，直到为空或达到处理数量上限 poll为空：如果有setImmediate()，则进入check phase，反之就在poll等客人 一但poll为空，eventlopp将会检查计时器是否有快到的，如果有需要执行的，eventloop将要进入timers阶段来顺序执行timer callback check这个phase可以在poll执行完成时开始执行setImmediate()回调。他其实是特殊的定时器队列，使用libuv API在poll完成的阶段执行（这也是他存在的原因）。 close callbackssocket.desroy()等执行关闭event时候会进入该phase，否则会被process.nextTick()触发 setImmedate() vs setTimeout()相似却又不同 setImmediate()是poll执行完成后执行的script setTimeout()是定时执行的 执行哪个收到上下文的约束，如果两个都被主模块调用，那么进程性能将会收到约束（影响其他app运行） 1234567891011121314151617181920212223242526272829303132without IOsetTimeout(() &#x3D;&gt; &#123; console.log(&#39;timeout&#39;);&#125;, 0);setImmediate(() &#x3D;&gt; &#123; console.log(&#39;immediate&#39;);&#125;);&#x2F;&#x2F;$ node timeout_vs_immediate.jstimeoutimmediate$ node timeout_vs_immediate.jsimmediatetimeoutwith IO&#x2F;&#x2F; timeout_vs_immediate.jsconst fs &#x3D; require(&#39;fs&#39;);fs.readFile(__filename, () &#x3D;&gt; &#123; setTimeout(() &#x3D;&gt; &#123; console.log(&#39;timeout&#39;); &#125;, 0); setImmediate(() &#x3D;&gt; &#123; console.log(&#39;immediate&#39;); &#125;);&#125;);&#x2F;&#x2F;immediatetimeout setImmediate()好处在于，如果有IO时会比setTimeout先执行 process.nextTick()它是个异步API，并没有出现在六个phase中，他并不属于eventloop的一部分，当操作完成后处理nextTickQueue而不管eventloop执行到哪个阶段，这个异步API依赖于C/C++处理 JavaScript 他的callbakcs会立即执行，直到执行完，eventloop才会正常工作（如果nextTick递归调用则会死循环） 为什么会出现这种设计？ 出于所有接口都应该异步的设计思路 12345function apiCall(arg, callback) &#123; if (typeof arg !&#x3D;&#x3D; &#39;string&#39;) return process.nextTick(callback, new TypeError(&#39;argument should be string&#39;));&#125; 代码段会校验参数，如果不正确，它将会把错误传递给回调。该API最近更新，允许传任何参给process.nextTick(),所以你不需要嵌套。仅在剩余代码执行之后我们会把错误反馈给用户，通过nextTick，我们保证apiCal()始终在用户胜于代码之后及eventloop继续之前，执行。为了达到这个目标，JS栈内存允许展开并且立即执行提供的callback，似的nextTick递归不会有报错。 process.nextTick() vs setImmediate() process.nextTick()立刻执行 setImmediate()下次tick执行 为什么需要process.nextTick() 允许用户处理errors，清理不需要的资源，事件循环前 尝试重新连接 有时有必要在eventloop继续之前，在call stack unwound之后，让callback执行 12345const server &#x3D; net.createServer();server.on(&#39;connection&#39;, (conn) &#x3D;&gt; &#123; &#125;);server.listen(8080);server.on(&#39;listening&#39;, () &#x3D;&gt; &#123; &#125;); listen()的callback调用的是setImmiate()，除非传递Hostname，否则立即绑定端口。为了保证eventloop继续，他必须进入poll phase，这意味着，存在可能已经收到了连接，从而允许在侦听事件之前触发连接事件]]></content>
      <categories>
        <category>Node</category>
      </categories>
      <tags>
        <tag>整理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCodeWeek2]]></title>
    <url>%2F2020%2F04%2F08%2F2020-04-08-LeetCodeWeek2%2F</url>
    <content type="text"><![CDATA[Prolem876-Submission DetailGiven a non-empty, singly linked list with head node head, return a middle node of linked list. If there are two middle nodes, return the second middle node. Example 1: 12345Input: [1,2,3,4,5]Output: Node 3 from this list (Serialization: [3,4,5])The returned node has value 3. (The judge&#39;s serialization of this node is [3,4,5]).Note that we returned a ListNode object ans, such that:ans.val &#x3D; 3, ans.next.val &#x3D; 4, ans.next.next.val &#x3D; 5, and ans.next.next.next &#x3D; NULL. Example 2: 123Input: [1,2,3,4,5,6]Output: Node 4 from this list (Serialization: [4,5,6])Since the list has two middle nodes with values 3 and 4, we return the second one. Note: The number of nodes in the given list will be between 1 and 100. key题目输出单向链表的中间元素，有这么几个思路 O(N)–&gt;遍历放数组，1/2输出return A[t / 2] O(N)–&gt;根据中间特点，mid前进一格，end前进两格 Solution第一次提交:0ms 12345678910111213141516171819202122class Solution &#123; public ListNode middleNode(ListNode head) &#123; ListNode mid = head; ListNode end = head; int i=0; while(end.next!=null)&#123; mid = head.next; ListNode tmp = mid; i++; int j=i; while(j&gt;0)&#123;//搞复杂了 if(tmp.next==null)return mid; end = tmp.next; tmp=tmp.next; j--; &#125; head=head.next; &#125; return mid; &#125;&#125; 第二次参考其他代码-提交： 12345678910class Solution &#123; public ListNode middleNode(ListNode head) &#123; ListNode mid &#x3D; head, end &#x3D; head; while (mid !&#x3D; null &amp;&amp; end.next !&#x3D; null) &#123; mid &#x3D; mid.next; end &#x3D; end.next.next; &#125; return mid; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Easy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCodeWeek1]]></title>
    <url>%2F2020%2F04%2F05%2F2020-04-05-LeetCodeWeek1%2F</url>
    <content type="text"><![CDATA[Problem Single Number好久没有刷题了，刚好遇到LeetCode，30天计划，打算强迫自己完成 Given a non-empty array of integers, every element appears twice except for one. Find that single one. Note: Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory? Example 1: 12Input: [2,2,1]Output: 1 Example 2: 12Input: [4,1,2,1,2]Output: 4 Key思路 第一个思路O(n^2)去做类似于冒泡遍历的办法 借助Array.sort()可以迅速排序，然后O(n)的办法遍历得到结果 （以上是自己的思路，以下为LeetCode代码思考） 通过异或操作迅速比较 通过 Arrays.stream(nums).reduce(0, (x, y) -&gt; x ^ y)来更快迭代每个元素 Array.steam()以下参考CSDN Stream 不是集合元素，它不是数据结构并不保存数据，它是有关算法和计算的，它更像一个高级版本的 Iterator。原始版本的 Iterator，用户只能显式地一个一个遍历元素并对其执行某些操作；高级版本的 Stream，用户只要给出需要对其包含的元素执行什么操作，比如 “过滤掉长度大于 10 的字符串”、“获取每个字符串的首字母”等，Stream 会隐式地在内部进行遍历，做出相应的数据转换。 Stream 就如同一个迭代器（Iterator），单向，不可往复，数据只能遍历一次，遍历过一次后即用尽了，就好比流水从面前流过，一去不复返。 而和迭代器又不同的是，Stream 可以并行化操作，迭代器只能命令式地、串行化操作。顾名思义，当使用串行方式去遍历时，每个 item 读完后再读下一个 item。而使用并行去遍历时，数据会被分成多个段，其中每一个都在不同的线程中处理，然后将结果一起输出。Stream 的并行操作依赖于 Java7 中引入的 Fork/Join 框架（JSR166y）来拆分任务和加速处理过程 简单说，对 Stream 的使用就是实现一个 filter-map-reduce 过程，产生一个最终结果，或者导致一个副作用（side effect）。 （以下为个人理解） 相对于Java中的Stream流，Java中也有，比如Array.reduce(),Array.foreach()等，通过回调函数的方式进行， 异或|=：两个二进制对应位都为0时，结果等于0，否则结果等于1； &amp;=：两个二进制的对应位都为1时，结果为1，否则结果等于0； ^=：两个二进制的对应位相同，结果为0，否则结果为1。 对于这道题来说，[2,2,1] 第零次遍历：init res=0,题目要求找出出现一次的数，所以这个数肯定存在 第一次遍历：res=2 第二次遍历：res=0，因为res^=2（即res=res^2） 第三次遍历：res=1结束遍历 综上：常用^= 以及&gt;&gt;位运算符，C级别的性能 Solution 对于异或方法（0ms） 12345678910class Solution &#123; public int singleNumber(int[] nums) &#123; int result = 0; for (int n : nums) &#123; result ^= n; &#125; return result; &#125;&#125; 自己的方法就不贴了。。==感觉好蠢==写了半天。 Problem Move ZeroesGiven an array nums, write a function to move all 0‘s to the end of it while maintaining the relative order of the non-zero elements. Example: 12Input: [0,1,0,3,12]Output: [1,3,12,0,0] Note: You must do this in-place without making a copy of the array. Minimize the total number of operations. Solution第一版： 123456789101112class Solution &#123; public void moveZeroes(int[] nums) &#123; for(int i=0;i&lt;nums.length;i++)&#123; if(nums[i]==0)&#123; for(int j=i;j&lt;nums.length-1;j++)&#123; nums[j]=nums[j+1]; &#125; nums[nums.length-1]=0; &#125; &#125; &#125;&#125; 原本根据题目的意思，想法就是找到一个0，整体往前移动一位，一把梭，但写完发现，本身没有必要整体前移，因为我的判断是num[i]是不是为0，所以只需要将0的个数记录下来，非0的元素前移，最后补0就可以了 第二版 1234567891011121314class Solution &#123; public void moveZeroes(int[] nums) &#123; if (nums &#x3D;&#x3D; null || nums.length &#x3D;&#x3D; 0) return; int insertPos &#x3D; 0; for (int num: nums) &#123; if (num !&#x3D; 0) nums[insertPos++] &#x3D; num; &#125; while (insertPos &lt; nums.length) &#123; nums[insertPos++] &#x3D; 0; &#125; &#125;&#125; Problem Best Time to Buy and Sell Stock IISay you have an array for which the ith element is the price of a given stock on day i. Design an algorithm to find the maximum profit. You may complete as many transactions as you like (i.e., buy one and sell one share of the stock multiple times). Note: You may not engage in multiple transactions at the same time (i.e., you must sell the stock before you buy again). Example 1: Input: [7,1,5,3,6,4]Output: 7Explanation: Buy on day 2 (price = 1) and sell on day 3 (price = 5), profit = 5-1 = 4. Then buy on day 4 (price = 3) and sell on day 5 (price = 6), profit = 6-3 = 3.Example 2: Input: [1,2,3,4,5]Output: 4Explanation: Buy on day 1 (price = 1) and sell on day 5 (price = 5), profit = 5-1 = 4. Note that you cannot buy on day 1, buy on day 2 and sell them later, as you are engaging multiple transactions at the same time. You must sell before buying again.Example 3: Input: [7,6,4,3,1]Output: 0Explanation: In this case, no transaction is done, i.e. max profit = 0. key题目获取最大利润，本以为是通过动态规划DP来做，但是仔细一想，差值就能解决问题1234567891011class Solution &#123; public int maxProfit(int[] prices) &#123; int res &#x3D; 0; for (int i &#x3D; 0; i &lt; prices.length - 1; ++i) &#123; if (prices[i] &lt; prices[i + 1]) &#123; res +&#x3D; prices[i + 1] - prices[i]; &#125; &#125; return res; &#125;&#125; Problem happy NumberWrite an algorithm to determine if a number is “happy”. A happy number is a number defined by the following process: Starting with any positive integer, replace the number by the sum of the squares of its digits, and repeat the process until the number equals 1 (where it will stay), or it loops endlessly in a cycle which does not include 1. Those numbers for which this process ends in 1 are happy numbers. Example: 1234567Input: 19Output: trueExplanation: 12 + 92 &#x3D; 8282 + 22 &#x3D; 6862 + 82 &#x3D; 10012 + 02 + 02 &#x3D; 1 Solution第一版 123456789101112131415161718class Solution &#123; public boolean isHappy(int n) &#123; int sum &#x3D;0; while (sum !&#x3D; 1) &#123; if(sum!&#x3D;0)&#123; n&#x3D;sum;sum&#x3D;0; &#125; while (n &gt; 0) &#123; int t &#x3D; n % 10; sum +&#x3D; t * t; n &#x2F;&#x3D; 10; &#125; if(sum&#x3D;&#x3D;0)return false; &#125; return true; &#125;&#125; 其实写完这个框架我就想起来了，可能在计算上存在死循环，就比如 如果这样的题目就进入了死循环，所以干脆直接通过hashset的方式进行过滤 添加了 12345if(set.contains(sum))&#123; return false;&#125;else&#123; set.add(sum);&#125; 整体代码如下： Runtime: 5 ms, faster than 9.41% of Java online submissions for Happy Number. 12345678910111213141516171819202122public boolean isHappy(int n) &#123; Set&lt;Integer&gt; set = new HashSet&lt;&gt;(); int sum =0; while (sum != 1) &#123; if(sum!=0)&#123; n=sum;sum=0; &#125; while (n &gt; 0) &#123; int t = n % 10; sum += t * t; n /= 10; &#125; if(sum==0)return false; if(set.contains(sum))&#123; return false; &#125;else&#123; set.add(sum); &#125; &#125; return true;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Easy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UniqueBinarySearchTrees]]></title>
    <url>%2F2020%2F03%2F22%2F2020-03-22-UniqueBinarySearchTrees%2F</url>
    <content type="text"><![CDATA[Problem 96Given n, how many structurally unique BST’s (binary search trees) that store values 1 … n? Example: 12345678910Input: 3Output: 5Explanation:Given n &#x3D; 3, there are a total of 5 unique BST&#39;s: 1 3 3 2 1 \ &#x2F; &#x2F; &#x2F; \ \ 3 2 1 1 3 2 &#x2F; &#x2F; \ \ 2 1 2 3 Solution题目其实相对比较简单，给出1~n，给出能够成的BST的数目，题目一开始的想法是用1~n去生成BST，看一下有多少种情况，然后做了很多无用功=.= 越写越不对劲后来查了一下，这道题是有数学规律的 BST有几个特点 中序遍历依次增（大于等于） 左右自述也是BST（recursion） 所以在i作为根节点时，左子树i-1个节点，右子树n-i个节点 数学的思想在于唯一二叉树的个数为左子树结点的个数乘以右子树的个数。而根节点可以从1到n 中选择，所以有 for(int i=1;i&lt;=n;++i) sum+=numTrees(i-1)*numTrees(n-i); 再加上边际控制n&lt;=1–&gt;sum=1 就有了解题的代码： 12345678910class Solution &#123; public int numTrees(int n) &#123; if(n&lt;=1) return 1; int sum=0; for(int i=1;i&lt;=n;++i) sum+=numTrees(i-1)*numTrees(n-i); return sum; &#125;&#125; Solution 95 Unique Binary Search Trees II万幸，自己折腾的生成BST的代码没白写 Given an integer n, generate all structurally unique BST’s (binary search trees) that store values 1 … n. Example: 1234567891011121314151617Input: 3Output:[ [1,null,3,2], [3,2,null,1], [3,1,null,null,2], [2,1,3], [1,null,2,null,3]]Explanation:The above output corresponds to the 5 unique BST&#39;s shown below: 1 3 3 2 1 \ &#x2F; &#x2F; &#x2F; \ \ 3 2 1 1 3 2 &#x2F; &#x2F; \ \ 2 1 2 3 看题目是前序遍历,我们从上向下查找，外面一层大循环遍历根节点 for(int i=start ;i&lt;=end;i++){} 确定了i节点后可以通过递归写出根节点i的情况下的左右子树 List leftChild = recursion(start, i - 1); List rightChild = recursion(i + 1, end); 然后遍历左右子树的每个元素，两层for循环嵌套 for(TreeNode left : leftChild) { for(TreeNode right : rightChild) { TreeNode root = new TreeNode(i); root.left = left; root.right = right; res.add(root); } } 得到最后的res进行返回，以及处理一下start&gt;end的边际条件就完成了 123456789101112131415161718192021222324252627282930313233343536/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public List&lt;TreeNode&gt; generateTrees(int n) &#123; if(n &lt; 1) return new ArrayList&lt;TreeNode&gt;(); return recursion(1, n); &#125; public List&lt;TreeNode&gt; recursion(int start,int end)&#123; List&lt;TreeNode&gt; res = new ArrayList(); if(start &gt; end) &#123; res.add(null); return res; &#125; for(int i = start;i&lt;=end;i++)&#123; List&lt;TreeNode&gt; leftChild = recursion(start, i - 1); List&lt;TreeNode&gt; rightChild = recursion(i + 1, end); for(TreeNode left : leftChild) &#123; for(TreeNode right : rightChild) &#123; TreeNode root = new TreeNode(i); root.left = left; root.right = right; res.add(root); &#125; &#125; &#125; return res; &#125;&#125; 问题当时卡在 List leftChild = recursion(start, i - 1);List rightChild = recursion(i + 1, end); 当然采用recursion虽然简洁易懂，但两条题目的复杂度都相对较高，是递归的压栈造成的，很多可能相同点的地方可能计算了两遍，导致了两道题目都是打败了5%的solution，当然我们可以通过dp(来自LeetCode)的方式来进行完成 12345678910111213141516171819202122232425262728293031323334class Solution &#123; public List&lt;TreeNode&gt; generateTrees(int n) &#123; if(n == 0) return new ArrayList&lt;&gt;(); List&lt;TreeNode&gt;[][] dp = new ArrayList[n][n]; return helper(1, n, dp); &#125; private List&lt;TreeNode&gt; helper(int start, int end, List&lt;TreeNode&gt;[][] dp)&#123; List&lt;TreeNode&gt; res = new ArrayList&lt;&gt;(); if(start &gt; end)&#123; res.add(null); return res; &#125; if(dp[start - 1][end - 1] != null &amp;&amp; !dp[start - 1][end - 1].isEmpty())&#123; return dp[start - 1][end - 1]; &#125; for (int i = start ; i &lt;= end ; i++) &#123; List&lt;TreeNode&gt; left = helper(start, i - 1, dp); List&lt;TreeNode&gt; right = helper(i + 1, end, dp); for(TreeNode a : left)&#123; for(TreeNode b : right)&#123; TreeNode node = new TreeNode(i); node.left = a; node.right = b; res.add(node); &#125; &#125; &#125; return dp[start - 1][end - 1] = res; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Medium</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[QUIC]]></title>
    <url>%2F2020%2F03%2F16%2F2020-03-16-QUIC%2F</url>
    <content type="text"><![CDATA[What快速UDP网络连接（Quick UDP Internet Connections，QUIC） 是一种实验性的传输层网络传输协议，由Google开发，在2013年实现。QUIC使用UDP协议，它在两个端点间创建连线，且支持多路复用连线。在设计之初，QUIC希望能够提供等同于SSL/TLS层级的网络安全保护，减少数据传输及创建连线时的延迟时间，双向控制带宽，以避免网络拥塞。Google希望使用这个协议来取代TCP协议，使网页传输速度加快。2018年10月，IETF的HTTP及QUIC工作小组正式将基于QUIC协议的HTTP（HTTP over QUIC）重命名为HTTP/3以为确立下一代规范做准备。 Featurecompared with HTTP2+TCP+TLS 无TCP握手及TLS握手–&gt;快 改进的拥塞控制 避免队头阻塞的多路复用 前向冗余纠错 Reason 中间设备僵化（防火墙，NAT等硬件设备固话443，80端口，NAT擦写地址，抛弃不认识的选项字段等旧规则） 依赖操作系统实现导致的协议僵化（依赖底层TCP很难快迭代） 建立连接的握手延迟大（HTTPS/2 use TSL 使得TCP，TLS握手时间较长） 队头阻塞（序号顺序接受，前面丢了后面接受直接丢弃） WhyRTT0RTT (0次Round-Trip Time,0次往返)建连可以说是 QUIC 相比 HTTP2 最大的性能优势。那什么是 0RTT 建连呢？这里面有两层含义。 传输层 0RTT 就能建立连接。 加密层 0RTT 就能建立加密连接。 一个完整的 TLS 握手需要两次： Client 发送 ClientHello；Server 回复 ServerHello Client 回复最终确定的 Key，Finished；Server 回复 Finished 握手完毕，Client 发送加密后的 HTTP 请求；Server 回复加密后的 HTTP 响应 TLS Session Resumption Client 发送 ClientHello（包含 Session ID）；Server 回复 ServerHello 和 Finished 握手完毕，Client 发送加密后的 HTTP 请求；Server 回复加密后的 HTTP 响应 TLS 0RTT 0 RTT 是 TLSv1.3 的可选功能。客户端和服务器第一次建立会话时，会生成一个 PSK（pre-shared key）。服务器会用 ticket key 去加密 PSK，作为 Session Ticket 返回。 客户端再次和服务器建立会话时，会先用 PSK 去加密 HTTP 请求，然后把加密后的内容发给服务器。服务器解密 PSK，然后再用 PSK 去解密 HTTP 请求，并加密 HTTP 响应。 HTTPS 握手已经跟 HTTP 请求合并到一起 ​ 1.Client 发送 ClientHello（包含 PSK）和加密后的 HTTP 请求；Server 回复 ServerHello 和 Finished 和加密后的 HTTP 响应。 congestion controlTCP采用了 慢启动 拥塞避免 快重传 快恢复 QUCI默认支持Cubic，另外支持CubicBytes,Reno,RenoBytes,BBR,PCC Pluggable可插拔，即灵活生效不需要重启或改变底层 应用层实现不同的拥塞控制算法，不需要底层支持 单个应用程序的不同连接支持不同的拥塞控制，如BBR，Cubic 应用程序无需变动直接变更拥塞控制，reload生效 STGW在配置层面进行了优化，针对不同业务，不同网络芝士，不同RTT，使用不同拥塞控制 单递增的Packet Number为了保障TCP的可靠性，使用Seq（sequenceNumber 序号）和ack来确认,N丢失，重传N（问题：N如果重传两次，收到一个ACK，不知道是哪个的ACK） QUIC使用PacketNumber代替seq，并且packetnumber严格递增，也就是说就算 Packet N 丢失了，重传的 Packet N 的 Packet Number 已经不是 N，而是一个比 N 大的值,另外支持Stream offset更好支持多个packet传输 不允许Renegingreneging：TCP通信时，如果发送序列中间某个数据包丢失，TCP会通过重传最后确认的包开始的后续包，这样原先已经正确传输的包也可能重复发送，急剧降低了TCP性能。 为改善这种情况，发展出SACK(Selective Acknowledgment, 选择性确认)技术，使TCP只重新发送丢失的包，不用发送后续所有的包，而且提供相应机制使接收方能告诉发送方哪些数据丢失，哪些数据重发了，哪些数据已经提前收到等 QUIC禁止reneging 更多的ack块TCP 的 Sack 选项能够告诉发送方已经接收到的连续 Segment 的范围，方便发送方进行选择性重传。 由于 TCP 头部最大只有 60 个字节，标准头部占用了 20 字节，所以 Tcp Option 最大长度只有 40 字节，再加上 Tcp Timestamp option 占用了 10 个字节 [25]，所以留给 Sack 选项的只有 30 个字节。 每一个 Sack Block 的长度是 8 个，加上 Sack Option 头部 2 个字节，也就意味着 Tcp Sack Option 最大只能提供 3 个 Block。 但是 Quic Ack Frame 可以同时提供 256 个 Ack Block，在丢包率比较高的网络下，更多的 Sack Block 可以提升网络的恢复速度，减少重传量。 ack delay时间收到客户端请求到响应的过程时间成为ack delay,QUIC的RTT需要减掉ack delay（计算我是没看懂。。。） 基于stream和connection级别的流量控制作用： stream可以认为是一条HTTP请求 Connection可以类比一条TCP连接，在connection上存在多条stream tcp承载多个http请求 window_update告诉对方自己接受的字节数 blockFrame告诉对方由于流量控制被阻塞，无法发送数据 stream可用窗口=最大窗口数-收到的最大偏移数 connection可用窗口=$\sum$streams可用窗口 没有队头阻塞的多路复用QUIC 的多路复用和 HTTP2 类似。在一条 QUIC 连接上可以并发发送多个 HTTP 请求 (stream)。但是 QUIC 的多路复用相比 HTTP2 有一个很大的优势。 QUIC 一个连接上的多个 stream 之间没有依赖。这样假如 stream2 丢了一个 udp packet，也只会影响 stream2 的处理。不会影响 stream2 之前及之后的 stream 的处理。 这也就在很大程度上缓解甚至消除了队头阻塞的影响。 HTTP2 在一个 TCP 连接上同时发送 4 个 Stream。其中 Stream1 已经正确到达，并被应用层读取。但是 Stream2 的第三个 tcp segment 丢失了，TCP 为了保证数据的可靠性，需要发送端重传第 3 个 segment 才能通知应用层读取接下去的数据，虽然这个时候 Stream3 和 Stream4 的全部数据已经到达了接收端，但都被阻塞住了。 不仅如此，由于 HTTP2 强制使用 TLS，还存在一个 TLS 协议层面的队头阻塞 Record 是 TLS 协议处理的最小单位，最大不能超过 16K，一些服务器比如 Nginx 默认的大小就是 16K。由于一个 record 必须经过数据一致性校验才能进行加解密，所以一个 16K 的 record，就算丢了一个字节，也会导致已经接收到的 15.99K 数据无法处理，因为它不完整。 那 QUIC 多路复用为什么能避免上述问题呢？ QUIC 最基本的传输单元是 Packet，不会超过 MTU 的大小，整个加密和认证过程都是基于 Packet 的，不会跨越多个 Packet。这样就能避免 TLS 协议存在的队头阻塞。 Stream 之间相互独立，比如 Stream2 丢了一个 Pakcet，不会影响 Stream3 和 Stream4。不存在 TCP 队头阻塞。 当然，并不是所有的 QUIC 数据都不会受到队头阻塞的影响，比如 QUIC 当前也是使用 Hpack 压缩算法 [10]，由于算法的限制，丢失一个头部数据时，可能遇到队头阻塞。 总体来说，QUIC 在传输大量数据时，比如视频，受到队头阻塞的影响很小。 加密认证的报文TCP 协议头部没有经过任何加密和认证，所以在传输过程中很容易被中间网络设备篡改，注入和窃听。比如修改序列号、滑动窗口。这些行为有可能是出于性能优化，也有可能是主动攻击。 但是 QUIC 的 packet 可以说是武装到了牙齿。除了个别报文比如 PUBLIC_RESET 和 CHLO，所有报文头部都是经过认证的，报文 Body 都是经过加密的。 这样只要对 QUIC 报文任何修改，接收端都能够及时发现，有效地降低了安全风险。 连接迁移一条 TCP 连接 [17] 是由四元组标识的（源 IP，源端口，目的 IP，目的端口）,当其中任何一个元素发生变化时，这条连接依然维持着，能够保持业务逻辑不中断 比如大家使用手机在 WIFI 和 4G 移动网络切换时，客户端的 IP 肯定会发生变化，需要重新建立和服务端的 TCP 连接。 又比如大家使用公共 NAT 出口时，有些连接竞争时需要重新绑定端口，导致客户端的端口发生变化，同样需要重新建立 TCP 连接。 针对 TCP 的连接变化，MPTCP[5] 其实已经有了解决方案，但是由于 MPTCP 需要操作系统及网络协议栈支持，部署阻力非常大，目前并不适用。 所以从 TCP 连接的角度来讲，这个问题是无解的。 那 QUIC 是如何做到连接迁移呢？很简单，任何一条 QUIC 连接不再以 IP 及端口四元组标识，而是以一个64 位的随机数作为 ID 来标识，这样就算 IP 或者端口发生变化时，只要 ID 不变，这条连接依然维持着，上层业务逻辑感知不到变化，不会中断，也就不需要重连。 由于这个 ID 是客户端随机产生的，并且长度有 64 位，所以冲突概率非常低。 其他此外，QUIC 还能实现前向冗余纠错，在重要的包比如握手消息发生丢失时，能够根据冗余信息还原出握手消息。 QUIC 还能实现证书压缩，减少证书传输量，针对包头进行验证等。]]></content>
      <categories>
        <category>Introduction</category>
      </categories>
      <tags>
        <tag>QUIC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Traversal]]></title>
    <url>%2F2020%2F03%2F15%2F2020-03-15-BinaryTreeLevelOrderTraversal%2F</url>
    <content type="text"><![CDATA[Problem 102 107Given a binary tree, return the level order traversal of its nodes’ values. (ie, from left to right, level by level). For example:Given binary tree [3,9,20,null,null,15,7], 12345 3 &#x2F; \9 20 &#x2F; \ 15 7 return its level order traversal as: 12345[ [3], [9,20], [15,7]] Solutionkey： 层序遍历 递归 在Java中可以先定义一个List保存结果,List里面再嵌入ArrayList来记录每一层的数据 List&lt;List&gt; res = new ArrayList&lt;&gt;(); res.add(new ArrayList&lt;&gt;()); 将递归中的root节点追加进入res.get(level)的数组中 res.get(level).add(root.val); 通过递归完成算法 travelsal(root.left,level+1);travelsal(root.right,level+1); 12345678910111213141516171819202122232425262728/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123; travelsal(root, 0); return res; &#125; private void travelsal(TreeNode root,int level) &#123; if(root==null)&#123; return; &#125; if(level==res.size())&#123; res.add(new ArrayList&lt;&gt;()); &#125; res.get(level).add(root.val); travelsal(root.left,level+1); travelsal(root.right,level+1); &#125;&#125; 接下来是107，是102的变种，改成了叶节点开始遍历 difficulty：Easy Given a binary tree, return the bottom-up level order traversal of its nodes’ values. (ie, from left to right, level by level from leaf to root). For example:Given binary tree [3,9,20,null,null,15,7], 12345 3 &#x2F; \9 20 &#x2F; \ 15 7 return its bottom-up level order traversal as: 123456[ [15,7], [9,20], [3]] key题目本身没有设置太多的难度，我们只需要将level实现数组的内层数组的倒序就可以了 res.get(level).add(root.val); change this code to res.get(res.size()-i-1).add(root.val); 原本判断新增数组的语句变成在第0个位置新增一个数组 if(i &gt;= res.size()){ res.add(0,new ArrayList());}]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Medium</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Egg插件到底封装了啥]]></title>
    <url>%2F2020%2F03%2F13%2F2020-03-13-Egg%E6%8F%92%E4%BB%B6%E5%88%B0%E5%BA%95%E5%B0%81%E8%A3%85%E4%BA%86%E5%95%A5%2F</url>
    <content type="text"><![CDATA[迫于比较好奇，下载了egg-redis，看看他如何将node直接可以引用的包，封装成为egg的插件 核心代码通过]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2020%2F03%2F11%2F2020-03-11-MaximumDepthOfBinaryTree%2F</url>
    <content type="text"><![CDATA[Prolem 104Given a binary tree, find its maximum depth. The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node. Note: A leaf is a node with no children. Example: Given binary tree [3,9,20,null,null,15,7], 12345 3 &#x2F; \9 20 &#x2F; \ 15 7 return its depth = 3. key判断树的深浅，采用 int left = max(root.left);int right = max(root.right);return Math.max(left,right) + 1; //或者简写 return Math.max(max(root.left) + 1, max(root.right) + 1); 进行递归 Runtime: 0 ms, faster than 100.00% of Java online submissions for Maximum Depth of Binary Tree. Memory Usage: 39.2 MB, less than 94.62% of Java online submissions for Maximum Depth of Binary Tree. 1234567891011121314151617181920/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public int maxDepth(TreeNode root) &#123; return max(root); &#125; public int max(TreeNode root)&#123; if (root == null) &#123; return 0; &#125; return Math.max(max(root.left) + 1, max(root.right) + 1); &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Easy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SymmetricTree]]></title>
    <url>%2F2020%2F03%2F10%2F2020-03-10-SymmetricTree%2F</url>
    <content type="text"><![CDATA[Problem101Given a binary tree, check whether it is a mirror of itself (ie, symmetric around its center). For example, this binary tree [1,2,2,3,4,4,3] is symmetric: 12345 1 &#x2F; \ 2 2 &#x2F; \ &#x2F; \3 4 4 3 But the following [1,2,2,null,3,null,3] is not: 12345 1 &#x2F; \2 2 \ \ 3 3 Note:Bonus points if you could solve it both recursively and iteratively. key一道验证树是否是对称的问题，主要采取递归的方法 1234567891011121314151617181920&#x2F;** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val &#x3D; x; &#125; * &#125; *&#x2F;class Solution &#123; public boolean isSymmetric(TreeNode root) &#123; return isMirror(root,root); &#125; public boolean isMirror(TreeNode root,TreeNode self)&#123; if(root&#x3D;&#x3D;null &amp;&amp; self&#x3D;&#x3D;null)return true; if(root&#x3D;&#x3D;null ||self&#x3D;&#x3D;null) return false; return root.val&#x3D;&#x3D;self.val &amp;&amp; isMirror(root.left,self.right)&amp;&amp;isMirror(root.right,self.left); &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Easy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AMDvsCMD]]></title>
    <url>%2F2020%2F03%2F09%2F2020-03-09-AMDvsCMD%2F</url>
    <content type="text"><![CDATA[AMD:Asynchronous Module Definition (RequireJS) CMD:Common Module Definition（SeaJS） AMD CMD 1. 提前执行 延迟执行（类似饿汉模式） 2. 依赖前置 依赖就近 3. 浏览器（加载缓慢，异步load更好） 服务器端 4. 异步模块定义 通用模块定义 AMD待补充，import-export CMDdefine Function一个文件就是一个模块，在我们的代码外层，会套上一层CMD规范,这也就是为什么我们可以直接引用require,export,module的原因 123define(function(require, exports, module) &#123; &#x2F;&#x2F; code&#125;); 单个参数 1234define(factory)param--&gt;factory:funtion|Object|Stringdefine(&#123; &quot;foo&quot;: &quot;bar&quot; &#125;);define(&#39;I am a template. My name is &#123;&#123;name&#125;&#125;.&#39;); 多个参数define define(id?, deps?, factory) 12345define(&#39;hello&#39;, [&#39;jquery&#39;], function(require, exports, module) &#123; &#x2F;&#x2F; code&#125;);id：String模块标识deps：Array模块依赖 define.cmd Object 1234if (typeof define &#x3D;&#x3D;&#x3D; &quot;function&quot; &amp;&amp; define.cmd) &#123; &#x2F;&#x2F; 有 Sea.js 等 CMD 模块加载器存在&#125;&#x2F;&#x2F;用来判断当前页面是否有CMD模块加载器 require Function同步加载 123456789define(function(require, exports) &#123; &#x2F;&#x2F; 获取模块 a 的接口 var a &#x3D; require(&#39;.&#x2F;a&#39;); &#x2F;&#x2F; 调用模块 a 的方法 a.doSomething();&#125;); require.async Function异步加载 1234567891011121314define(function(require, exports, module) &#123; &#x2F;&#x2F; 异步加载一个模块，在加载完成时，执行回调 require.async(&#39;.&#x2F;b&#39;, function(b) &#123; b.doSomething(); &#125;); &#x2F;&#x2F; 异步加载多个模块，在加载完成时，执行回调 require.async([&#39;.&#x2F;c&#39;, &#39;.&#x2F;d&#39;], function(c, d) &#123; c.doSomething(); d.doSomething(); &#125;);&#125;); require.resolve返回解析后的绝对路径 exprotsreturn Object，对外提供接口 1234567891011121314151617181920212223242526define(function(require, exports) &#123; &#x2F;&#x2F; 对外提供 foo 属性 exports.foo &#x3D; &#39;bar&#39;; &#x2F;&#x2F; 对外提供 doSomething 方法 exports.doSomething &#x3D; function() &#123;&#125;;&#125;);retrun可以实现同等效果define(function(require) &#123; &#x2F;&#x2F; 通过 return 直接提供接口 return &#123; foo: &#39;bar&#39;, doSomething: function() &#123;&#125; &#125;;&#125;);以及个人不太喜欢的缩略写法define(&#123; foo: &#39;bar&#39;, doSomething: function() &#123;&#125;&#125;); 但以下写法是错误的 123456789define(function(require, exports) &#123; &#x2F;&#x2F; 错误用法！！! exports &#x3D; &#123; foo: &#39;bar&#39;, doSomething: function() &#123;&#125; &#125;;&#125;); exports 仅仅是 module.exports 的一个引用。在 factory 内部给 exports 重新赋值时，并不会改变 module.exports 的值。因此给 exports 赋值是无效的，不能用来更改模块接口。 我说句简单的话：exports和module.exports，都是地址，指向同一个内容，如果你给exports赋值了一个新对象，他指向的内容就完全变了，和module.exprots就指向不是同一个地方了 modulemodeule是一个对象，存储与当前模块相关联的一些属性和方法，默认为{} module:function module.id:String模块标识 module.url：String返回绝对路径（默认id=url，除非手写id） module.dependencies:Array模块依赖 module.export:Object 大部分情况下和exports通用，但如果模块是一个类，就应该直接赋值给module.exports，这样调用就是一个类的构造器，可以直接new实例 12345678module.exports&#x3D;new Person();const p &#x3D; require(.&#x2F;xxx.js);p.say();&#x2F;&#x2F;orexports.p &#x3D; new Person();const &#123;p&#125; &#x3D; require(.&#x2F;xxxjs);p.say();]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>other</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Construct Binary Tree from Preorder and Inorder Traversal]]></title>
    <url>%2F2020%2F03%2F08%2F2020-03-08-Construct%20Binary%20Tree%20from%20Preorder%20and%20Inorder%20Traversal%2F</url>
    <content type="text"><![CDATA[Problem105Given preorder and inorder traversal of a tree, construct the binary tree. Note:You may assume that duplicates do not exist in the tree. For example, given 12preorder &#x3D; [3,9,20,15,7]inorder &#x3D; [9,3,15,20,7] Return the following binary tree: 12345 3 &#x2F; \9 20 &#x2F; \ 15 7 key 题目是一个根据前序中序，生成二叉树的题目 前序遍历有个特点：根节点在前面，root -left-right 则遍历到3作为root，根据中序可以知道左子树是9，右子树是15 20 7 然后遍历9作为root，根据中序得到没有左子树，没有右子树 然后遍历20作为root，依次类推可以得到 123TreeNode root &#x3D; new TreeNode(rootVal);root.left &#x3D; buildTree(pre, preStart+1, preStart+len, in, inStart, rootIndex-1);root.right &#x3D; buildTree(pre, preStart+len+1, preEnd, in, rootIndex+1, inEnd); 其中insort比较好理解，确定root后 左子树在inStart, rootIndex-1之间 右子树在rootIndex+1, inEnd之间 对于presort int len = rootIndex - inStart;获得root的左子树长度（根据中序获取rootIndex） 左子树在preStart+1, preStart+len之间 右子树在preStart+len+1, preEnd之间 Solution12345678910111213141516171819202122232425262728293031323334/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public TreeNode buildTree(int[] preorder, int[] inorder) &#123; return buildTree(preorder, 0, preorder.length-1, inorder, 0, inorder.length-1); &#125; public TreeNode buildTree(int[] pre, int preStart, int preEnd, int[] in, int inStart, int inEnd)&#123; if(inStart &gt; inEnd || preStart &gt; preEnd) return null; int rootVal = pre[preStart]; int rootIndex = 0; for(int i = inStart; i &lt;= inEnd; i++)&#123; if(in[i] == rootVal)&#123; rootIndex = i; break; &#125; &#125; int len = rootIndex - inStart; TreeNode root = new TreeNode(rootVal); root.left = buildTree(pre, preStart+1, preStart+len, in, inStart, rootIndex-1); root.right = buildTree(pre, preStart+len+1, preEnd, in, rootIndex+1, inEnd); return root; &#125;&#125; tip参考于百度，在递归条件乱了]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Medium</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BinaryTreeInorderTraversal]]></title>
    <url>%2F2020%2F03%2F06%2F2020-03-06-BinaryTreeInorderTraversal%2F</url>
    <content type="text"><![CDATA[Problem94Given a binary tree, return the inorder traversal of its nodes’ values. 给定一二叉树，中序遍历输出 ps:preorder,inorder,postorder，前中后 Keyrecursive approach利用递归解决B树的遍历问题，这种问题的代码其实大同小异，前中后的遍历输出，只需要调整递归部分即可 12345678910111213141516171819202122232425262728//preorderpublic void preorder(node t) if (t != null) &#123; System.out.print(t.value + &quot; &quot;); preorder(t.left); preorder(t.right); &#125;&#125;//inorderpublic void inorder(node t)&#123; if (t != null) &#123; inorder(t.left); System.out.print(t.value + &quot; &quot;); inorder(t.right); &#125;&#125;//postorderpublic void postorder(node t)&#123; if (t != null) &#123; postorder(t.left); postorder(t.right); System.out.print(t.value + &quot; &quot;); &#125;&#125;//leverorder Solution Runtime: 0 ms, faster than 100.00% of Java online submissions for Binary Tree Inorder Traversal. Memory Usage: 37.9 MB, less than 5.11% of Java online submissions for Binary Tree Inorder Traversal. 1234567891011121314151617181920212223/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public List&lt;Integer&gt; inorderTraversal(TreeNode root) &#123; List &lt; Integer &gt; res = new ArrayList &lt; &gt; (); inorder(root, res); return res; &#125; public void inorder(TreeNode root, List &lt; Integer &gt; res) &#123; if (root != null) &#123; inorder(root.left, res); res.add(root.val); inorder(root.right, res); &#125; &#125;&#125; Complexity Analysis Time complexity : O(n)O(n). The time complexity is O(n)O(n) because the recursive function is T(n) = 2 \cdot T(n/2)+1T(n)=2⋅T(n/2)+1. Space complexity : The worst case space required is O(n)O(n), and in the average case it’s O(\log n)O(logn) where nn is number of nodes. stacksolution还提供了另外一种方法通过stack pop的方式来完成： https://leetcode.com/problems/binary-tree-inorder-traversal/solution/ Morris同上]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Medium</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2020-03-05-hexoNexTv7.7.2]]></title>
    <url>%2F2020%2F03%2F05%2F2020-03-05-hexoNexTv7-7-2%2F</url>
    <content type="text"><![CDATA[I find hexo’s theme:nexT v7.7.2 has some new features native dark modewe can set 1darkmode:true to open native dark mode and there are other features like support MathJax v3.0,we use $$ add next_config helper how to update newest version1.git clone https://github.com/theme-next/hexo-theme-next themes/next or in releases to download newest source code 2.copy file to hexo/theme/ such as : /themes/hexo-theme-next-7.7.2/ 3.open hexo’s _config.yml,and change theme’s value to hexo-theme-next-7.7.2 and u change your them successfully 4.update /themes/hexo-theme-next-7.7.2/_config.yml Last , u can create new post to log your daily life 1yarn upgrade caniuse-lite browserslist and these days ,zehai.info ,may Expired ,sad]]></content>
      <categories>
        <category>others</category>
      </categories>
      <tags>
        <tag>NexT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2020-02-28-关于今天的一些思考]]></title>
    <url>%2F2020%2F02%2F28%2F2020-02-28-%E5%85%B3%E4%BA%8E%E4%BB%8A%E5%A4%A9%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%9D%E8%80%83%2F</url>
    <content type="text"><![CDATA[今天确实发生了一些事情，避之不谈 让我想起来了之前我在bili遇到的一件事情，一个up主癌症，自己经济能力不是很好，拍了一些很粗糙，没有剪辑过的视频，大意交代了自己得病，没有钱，拍了病历本，化验单，希望大家有能力的捐一点，后来up大概是拿到了一部分钱，具体多少我不太清楚，后来不知道发生了什么，画风开始转变 up视频的下面出现了很多评论 评论up有两个手机，家里有钱，然后up就对焦给大家看了他的两个手机，我记得两个都是红米类似的便宜机器，而且买了很久了 后来又人评论他家多有钱，然后up就拍下了回家和奶奶在一起的场面（当时已经没钱住院，就回家筹钱换医院试试） 后来又有人评论up主根本就没病，出来骗人钱，up就拍视频给人看治疗过程中的病历，化验单，至少我看不出来造假的证据 后来up出院了，买了张车票回家，和一个月前相比头发掉了很多，弹幕里面各种质疑，评论里面一片质疑， 亲身经历，环顾整个过程，我没有给up捐赠一分钱，也没有给予他任何帮助，就看了他整个生病的过程，从开始的加油，变成了一个‘骗子’，人们存在于网络之后，确实可以发表自己对于一件事情的看法，我想我如果是那个up，深陷其中一定很无奈 陈述结束 最后疫情一定会过去的]]></content>
  </entry>
  <entry>
    <title><![CDATA[2020-02-28-JS相关技术名词]]></title>
    <url>%2F2020%2F02%2F28%2F2020-02-28-JS%E7%9B%B8%E5%85%B3%E6%8A%80%E6%9C%AF%E5%90%8D%E8%AF%8D%2F</url>
    <content type="text"><![CDATA[今天中午有收到Egg团队公开的文件调查，提及了很多技术名词，虽然不一定用到，但我也觉得列举出来会方便大家了解和比较，后续可能更新我用过的部分 代码检查工具 ESLint JSCS JSHint JSDoc Standard TSLint Flow 引入目的：规范代码 ESLint 通过extend继承某一个大类，然后配置rules来进行代码规范 JSCS JSHint JSDoc Standard TSLint Flow 使用感受解决了以下问题 node是一门弱语言，进行校验（非变量类型校验，仅校验变量是否声明，是否可改等） node在use strict模式下，eslint可以校验 团队合作，防止队友挖坑 其实ESLint只是一种语法校验，更多的还有流程上的规范，就像网传阿里的开发规范一样，就好比node中你可以用类的语法糖，也可以用原型，当一件事情有多种实现方式时，需要规范来选择一个普遍公用的，易维护，易扩展的方案 除去语法校验，还有TS的类型校验，比如GIT的分支规范，如master,staging,backup,develop,other branch 转义语言 TS ClojureScript CoffeeScript Dart Elm Scala.js Haxe Nim PureScript Reason 转移语言是2019年聊的比较多的，解决问题： 类型校验，能够很好解决JS开发中，你不知道这个object里面有什么key，或者某个对象里面有什么方法（egg.js实际开发过程中，ctx.service.v1.handlexxx()就ctrl跳转不了，也不会有提示） WEB框架 Express Koa Egg Nest.js Next.js Fastify.js Hapi.js Restify.js Loopback.io Sails.js Midway.js 面试常被问到框架的问题，因为很多公司不会将项目搭建在原生的node服务上 缺少约束，合作模式下，个人有个人的风格 项目配置繁琐，很多东西配置零散堆放 重复造轮子，框架提供较好的轮子 安全事宜，框架处理 etc 一个好的框架事半功倍，express是一个非常轻量的框架 fast unopinionated(干净的) minimalist Egg是一个企业级框架，约定大于配置 Provide capability to customizd framework base on Egg（可扩展） Highly extensible plugin mechanism（插件牛逼） Built-in cluster（多进程牛逼） Based on Koa with high performance（企业级别性能优异） Stable core framework with high test coverage（稳定） Progressive development（业务迭代，代码可以渐进继承） 数据库 MySQL PostgreSql Redis MongoDB SQL Server SQLLite influxdb HBASE TiDB Oracle DB2 数据库是仅此于语言本身，另外的考点了，因为没有一个服务不涉猎存储，而数据库作为系统的数据基础，不仅重要也成为了面试的重点 mysql等关系型数据库，范式，事务，innodb，读写分离，分表 Mongo,Redis等非关系型数据基础类型，聚合等 反向代理 Nginx Tomcat [ ] Apache 解决负载均衡 预处理一些请求，如过滤重复请求 进程管理 Docker PM2 forever naught node-supervisor Supervisord(Unix) docker集大成者，在微服务等场景应用较多 RPC方式 HTTP Thrift gRPC dubbo MQ 开发场景 服务端API SSR应用 Proxy层 BFF层 代码片段，如Spark代码片段 CLI &amp; 工具 tips]]></content>
      <tags>
        <tag>List</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2020-01-31-JS设计模式]]></title>
    <url>%2F2020%2F01%2F31%2F2020-01-31-JS%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[模式共计八种： 单例模式 构造器模式 建造者模式 代理模式 外观模式 观察者模式 策略模式 迭代器模式 设计模式的提出，为了更好的解耦，可拓展，服务可靠，不限定某种语言的实现 单例模式概念一个类只有一个实例，如果存在就不实例化，如果不存在则new，以保证一个类只有一个实例 作用 模块间通信 保证某个类的对象的唯一性 防止变量污染 注意 this的使用 闭包容易stack over flow需要及时清理 创建新对象成本较高 实际案例如网站的计数器，多线程的线程池 1234567891011121314151617181920212223242526(function()&#123; // 养鱼游戏 let fish = null function catchFish() &#123; // 如果鱼存在,则直接返回 if(fish) &#123; return fish &#125;else &#123; // 如果鱼不存在,则获取鱼再返回 fish = document.querySelector(&#x27;#cat&#x27;) return &#123; fish, water: function() &#123; let water = this.fish.getAttribute(&#x27;weight&#x27;) this.fish.setAttribute(&#x27;weight&#x27;, ++water) &#125; &#125; &#125; &#125; // 每隔3小时喂一次水 setInterval(() =&gt; &#123; catchFish().water() &#125;, 3*60*60*1000)&#125;)() 构造器模式]]></content>
  </entry>
  <entry>
    <title><![CDATA[2020-01-31-RomanToInteger]]></title>
    <url>%2F2020%2F01%2F31%2F2020-01-31-RomanToInteger%2F</url>
    <content type="text"><![CDATA[Leetcode13Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M. Symbol ValueI 1V 5X 10L 50C 100D 500M 1000For example, two is written as II in Roman numeral, just two one’s added together. Twelve is written as, XII, which is simply X + II. The number twenty seven is written as XXVII, which is XX + V + II. Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used: I can be placed before V (5) and X (10) to make 4 and 9.X can be placed before L (50) and C (100) to make 40 and 90.C can be placed before D (500) and M (1000) to make 400 and 900.Given a roman numeral, convert it to an integer. Input is guaranteed to be within the range from 1 to 3999. Example 1: Input: “III”Output: 3Example 2: Input: “IV”Output: 4Example 3: Input: “IX”Output: 9Example 4: Input: “LVIII”Output: 58Explanation: L = 50, V= 5, III = 3.Example 5: Input: “MCMXCIV”Output: 1994Explanation: M = 1000, CM = 900, XC = 90 and IV = 4. Solution题目意思其实很简单，掌握了计算方法其实很简单 1234567891011121314151617181920212223242526272829303132333435363738class Solution &#123; public int romanToInt(String s) &#123; int nums[]=new int[s.length()]; for(int i=0;i&lt;s.length();i++)&#123; switch (s.charAt(i))&#123; case &#x27;M&#x27;: nums[i]=1000; break; case &#x27;D&#x27;: nums[i]=500; break; case &#x27;C&#x27;: nums[i]=100; break; case &#x27;L&#x27;: nums[i]=50; break; case &#x27;X&#x27; : nums[i]=10; break; case &#x27;V&#x27;: nums[i]=5; break; case &#x27;I&#x27;: nums[i]=1; break; &#125; &#125; int sum=0; for(int i=0;i&lt;nums.length-1;i++)&#123; if(nums[i]&lt;nums[i+1]) sum-=nums[i]; else sum+=nums[i]; &#125; return sum+nums[nums.length-1]; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Easy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2020-01-31-内网穿透]]></title>
    <url>%2F2020%2F01%2F31%2F2020-01-31-%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F%2F</url>
    <content type="text"><![CDATA[why解决公网访问自己的内网设备（大部分公司，小区都是在内网中，IPv4历史原因导致），解决方案： 路由器新增端口映射 花生壳动态解析软件 natapp等免费软件提供的内网映射服务 基于ngrok（不荐）或者frp自建内网映射服务 how目前推荐使用frp搭建穿透服务，支持HTTP，SSH,TCP UDP FTP]]></content>
  </entry>
  <entry>
    <title><![CDATA[2020-01-18-plugins]]></title>
    <url>%2F2020%2F01%2F18%2F2020-01-18-plugins%2F</url>
    <content type="text"><![CDATA[最近更新hexo比较频繁，发现频繁性的推送master分支以及source源文件备份，比较繁琐，查询了官方文档，可以写一些监听函数，实现一些自动化部署，hexo默认将脚本放置在scripts文件夹下，以下代码可以在hexo new的时候自动打开默认编辑软件 12345var spawn &#x3D; require(&#39;child_process&#39;).exec;hexo.on(&#39;new&#39;, function(data)&#123; spawn(&#39;start &quot;markdown编辑器绝对路径.exe&quot; &#39; + data.path);&#125;); 非常的方便，省去了我打开typora的时间 以及以下的代码可以实现自动部署source分支 123456789101112131415161718192021222324252627282930313233343536require(&#39;shelljs&#x2F;global&#39;);&#x2F;&#x2F;记得安装包try &#123; hexo.on(&#39;deployAfter&#39;, function() &#123;&#x2F;&#x2F;当deploy完成后执行备份 run(); &#125;);&#125; catch (e) &#123; console.log(&quot;You make a wrong：&quot; + e.toString());&#125;function run() &#123; if (!which(&#39;git&#39;)) &#123; echo(&#39;Sorry, this script requires git&#39;); exit(1); &#125; else &#123; echo(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;Auto Backup Begin&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;); cd(&#39;.&#x2F;&#39;); if (exec(&#39;git add --all&#39;).code !&#x3D;&#x3D; 0) &#123; echo(&#39;Error: Git add failed&#39;); exit(1); &#125; if (exec(&#39;git commit -am &quot;Form auto backup script\&#39;s commit&quot;&#39;).code !&#x3D;&#x3D; 0) &#123; echo(&#39;Error: Git commit failed&#39;); exit(1); &#125; if (exec(&#39;git push origin source&#39;).code !&#x3D;&#x3D; 0) &#123; echo(&#39;Error: Git push failed&#39;); exit(1); &#125; echo(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;Auto Backup Complete&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;) &#125;&#125; 参考文献https://hexo.io/zh-cn/docs/plugins#%E5%B7%A5%E5%85%B7]]></content>
  </entry>
  <entry>
    <title><![CDATA[2020-01-17-ImplementStr]]></title>
    <url>%2F2020%2F01%2F17%2F2020-01-17-ImplementStr%2F</url>
    <content type="text"><![CDATA[LeetCode28Implement strStr(). Return the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack. Example 1: Input: haystack = “hello”, needle = “ll”Output: 2Example 2: Input: haystack = “aaaaa”, needle = “bba”Output: -1Clarification: What should we return when needle is an empty string? This is a great question to ask during an interview. For the purpose of this problem, we will return 0 when needle is an empty string. This is consistent to C’s strstr() and Java’s indexOf(). Solution如果不考虑java偷懒的写法当然可以想到indexof的想法123456class Solution &#123; public int strStr(String haystack, String needle) &#123; return haystack.indexOf(needle); &#125;&#125;Runtime: 1 ms先按照题意写了如下代码：1234567891011121314151617181920212223242526272829class Solution &#123; public int strStr(String haystack, String needle) &#123; if(needle.length()==0)return 0; if(haystack.length()==0)return -1; int index =-1; boolean flag = true; for(int i=0;i&lt;haystack.length();i++)&#123; if(haystack.charAt(i)==needle.charAt(0))&#123; flag=true; for(int j =0;j&lt;needle.length();j++)&#123; if(i+j&gt;=haystack.length())&#123; return -1; &#125; if(haystack.charAt(i+j)!=needle.charAt(j))&#123; flag=false; break; &#125;; &#125; if(flag)&#123; return i; &#125; &#125; &#125; return index; &#125;&#125;Runtime: 4 msMemory Usage: 42.7 MB]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Easy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2020-01-15-sqrtx]]></title>
    <url>%2F2020%2F01%2F15%2F2020-01-15-sqrtx%2F</url>
    <content type="text"><![CDATA[LeetCode-69Implement int sqrt(int x). Compute and return the square root of x, where x is guaranteed to be a non-negative integer. Since the return type is an integer, the decimal digits are truncated and only the integer part of the result is returned. Example 1: Input: 4Output: 2Example 2: Input: 8Output: 2Explanation: The square root of 8 is 2.82842…, and since the decimal part is truncated, 2 is returned. Solution就是手写一个根号源码，首先想到的就是通过平方来做 12345678910public int mySqrt(int x) &#123; for(int i=46340;i&lt;46341;i++)&#123; if(x&gt;=(long)i*i&amp;&amp;x&lt;(long)(i+1)*(i+1))&#123; return i; &#125; &#125; return x; &#125;Runtime: 22 msMemory Usage: 34 MB 如果不遵循题目的要求，使用Math函数，所以我们的目标大概是3ms附近 1234public int mySqrt(int x) &#123; return (int)Math.sqrt(Double.parseDouble(String.valueOf(x))); &#125;Runtime: 3 ms 解法粗暴，遇到大数的时候会从0重新开始计算，复杂度O(N) 第一次优化思路就是避免做两次乘法然后去比较，这个地方可以去优化 12345678910class Solution &#123; public int mySqrt(int x) &#123; long n &#x3D; 1; while(n * n &lt;&#x3D; x) &#123; n++; &#125; return (int) n - 1; &#125;&#125;Runtime: 11 ms 第二次优化可以使用二分法来逐步逼近i，没有必要从1开始顺序遍历 12345678910111213141516171819202122class Solution &#123; public int mySqrt(int x) &#123; if (x == 0 || x == 1) return x; int left = 1; int right = x; while (left &lt; right) &#123; int midPoint = (left + right) / 2; if (midPoint == x / midPoint) &#123; return midPoint; &#125; else if (midPoint &gt; x / midPoint) &#123; right = midPoint; &#125; else if (midPoint &lt; x / midPoint) &#123; left = midPoint + 1; &#125; &#125; return left - 1; &#125;&#125;Runtime: 1 ms]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Easy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2020-01-11-SameTree]]></title>
    <url>%2F2020%2F01%2F11%2F2020-01-11-SameTree%2F</url>
    <content type="text"><![CDATA[LeetCode 10012345678910111213141516171819202122232425262728293031Given two binary trees, write a function to check if they are the same or not.Two binary trees are considered the same if they are structurally identical and the nodes have the same value.Example 1:Input: 1 1 &#x2F; \ &#x2F; \ 2 3 2 3 [1,2,3], [1,2,3]Output: trueExample 2:Input: 1 1 &#x2F; \ 2 2 [1,2], [1,null,2]Output: falseExample 3:Input: 1 1 &#x2F; \ &#x2F; \ 2 1 1 2 [1,2,1], [1,1,2]Output: false Solution题目其实很简单的一个递归Recursion,我们很轻松可以通过递归来解决1234567891011class Solution &#123; public boolean isSameTree(TreeNode p, TreeNode q) &#123; &#x2F;&#x2F; p and q are both null if (p &#x3D;&#x3D; null &amp;&amp; q &#x3D;&#x3D; null) return true; &#x2F;&#x2F; one of p and q is null if (q &#x3D;&#x3D; null || p &#x3D;&#x3D; null) return false; if (p.val !&#x3D; q.val) return false; return isSameTree(p.right, q.right) &amp;&amp; isSameTree(p.left, q.left); &#125;&#125;时间复杂度为O(n)，控件复杂度为O(logn)~O(n)之间，这道题就不考虑其他解法了，recursion目前看来是最优解]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Medium</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2020-01-10-MatrixZero]]></title>
    <url>%2F2020%2F01%2F10%2F2020-01-10-MatrixZero%2F</url>
    <content type="text"><![CDATA[LeetCode 731234567891011121314151617181920212223242526272829303132333435Given a m x n matrix, if an element is 0, set its entire row and column to 0. Do it in-place.Example 1:Input: [ [1,1,1], [1,0,1], [1,1,1]]Output: [ [1,0,1], [0,0,0], [1,0,1]]Example 2:Input: [ [0,1,2,0], [3,4,5,2], [1,3,1,5]]Output: [ [0,0,0,0], [0,4,5,0], [0,3,1,0]]Follow up:A straight forward solution using O(mn) space is probably a bad idea.A simple improvement uses O(m + n) space, but still not the best solution.Could you devise a constant space solution? Solution一开始以为递归可以解决，可以将矩阵一层层拆开，写下了如下的代码：123456789101112131415161718192021222324252627282930313233343536373839public void setZeroes(int[][] matrix) &#123; int rows &#x3D; matrix.length-1; int cols &#x3D; matrix[0].length-1; regression(matrix, rows&gt;&#x3D;cols?cols:rows);&#125;public void regression(int[][] matrix,int index)&#123; if(index&lt;0)&#123; return; &#125; boolean flag &#x3D; false; for(int i &#x3D;index;i&lt;matrix[0].length;i++)&#123; if(matrix[index][i]&#x3D;&#x3D;0) &#123; handleZero(matrix,i); flag&#x3D;true; break; &#125; &#125; if(flag&#x3D;&#x3D;false)&#123; for(int j &#x3D;index;j&lt;matrix.length;j++)&#123; if(matrix[j][index]&#x3D;&#x3D;0) &#123; handleZero(matrix,j); break; &#125; &#125; &#125; regression(matrix, --index);&#125;private void handleZero(int[][] matrix,int pos) &#123; for(int i&#x3D;matrix[0].length-1;i&gt;&#x3D;pos;i--)&#123; matrix[pos][i]&#x3D;0; &#125; for(int j&#x3D;matrix.length-1;j&gt;&#x3D;pos;j--)&#123; matrix[j][pos]&#x3D;0; &#125;&#125;写完后很快发现不能够实现，原因就在于他只能管理到内层，外层标为0后，没办法做额外的标记（其实生产代码可以打一些标记），所以只能抛弃这个本以为很简单的方法，该用了set合集去记录要设置0行列的行号或者列号，这个复杂度并不是很复杂，但是执行完发现代码的效率还是很低，先放代码：12345678910111213141516171819202122232425class Solution &#123; public void setZeroes(int[][] matrix) &#123; int R &#x3D; matrix.length; int C &#x3D; matrix[0].length; Set&lt;Integer&gt; rows &#x3D; new HashSet&lt;Integer&gt;(); Set&lt;Integer&gt; cols &#x3D; new HashSet&lt;Integer&gt;(); for (int i &#x3D; 0; i &lt; R; i++) &#123; for (int j &#x3D; 0; j &lt; C; j++) &#123; if (matrix[i][j] &#x3D;&#x3D; 0) &#123; rows.add(i); cols.add(j); &#125; &#125; &#125; for (int i &#x3D; 0; i &lt; R; i++) &#123; for (int j &#x3D; 0; j &lt; C; j++) &#123; if (rows.contains(i) || cols.contains(j)) &#123; matrix[i][j] &#x3D; 0; &#125; &#125; &#125; &#125;&#125;代码低效的原因在于动用了两层循环，时间复杂度非常低，题目的置0是有规律的，不是无规律的，所以我开始寻求更新简单的方法,先贴最优解，要睡觉了，我的头发啊 123456789101112131415161718192021222324252627282930313233343536373839404142class Solution &#123; public void setZeroes(int[][] matrix) &#123; int R &#x3D; matrix.length; int C &#x3D; matrix[0].length; boolean isCol &#x3D; false; for(int i&#x3D;0; i&lt;R; i++) &#123; if (matrix[i][0] &#x3D;&#x3D; 0) &#123; isCol &#x3D; true; &#125; for(int j&#x3D;1; j&lt;C; j++) &#123; if(matrix[i][j]&#x3D;&#x3D;0) &#123; matrix[0][j] &#x3D; 0; matrix[i][0] &#x3D; 0; &#125; &#125; &#125; &#x2F;&#x2F; Iterate over the array once again and using the first row and first column, update the elements. for(int i&#x3D;1; i&lt;R; i++) &#123; for(int j&#x3D;1; j&lt;C; j++) &#123; if(matrix[i][0]&#x3D;&#x3D;0 || matrix[0][j]&#x3D;&#x3D;0) &#123; matrix[i][j] &#x3D; 0; &#125; &#125; &#125; &#x2F;&#x2F; See if the first row needs to be set to zero as well if(matrix[0][0]&#x3D;&#x3D;0) &#123; for(int j&#x3D;0; j&lt;C; j++) &#123; matrix[0][j] &#x3D; 0; &#125; &#125; &#x2F;&#x2F; See if the first column needs to be set to zero as well if(isCol) &#123; for(int i&#x3D;0; i&lt;R; i++) &#123; matrix[i][0] &#x3D; 0; &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Medium</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2020-01-09-RedisTransaction]]></title>
    <url>%2F2020%2F01%2F09%2F2020-01-09-RidisTransaction%2F</url>
    <content type="text"><![CDATA[官网doc：https://redis.io/topics/transactions 本文纯属阅读笔记，无学术参考价值 what事务（transaction）的本质就是处理好几个动作，要么都成功，要么其中一个失败就全部回滚 每门语言都会有事务的支持，node也有async的方法实现事务几个动作串行，或者并行，一个失败全部回滚，之前写过支付的例子，使用async.waterfall,购买会员后 1.查询支付宝返回支付是否成功 2.获取用户所买会员的等级及相关权限 3.将权益插入用户表中 4.将订单数据记录到订单表中，方便后台查看订单量 大致步骤就是这些 Redis主要使用MULTI ,EXEC,DISCARD WATCH来实现事务的功能 遵循以下原则： 所有命令被序列化后顺序执行，且执行期间不接受其他请求，保证隔离性 EXEC命令触发事务中所有命令的执行，因此，如果客户端调用MULTI命令之前失去连接，则不执行任何操作。如果EXEC命令调用过，则所有的命令都会被执行 howMULTI输入事务以OK答复，此时用户可以发送多个命令，Redis都不会执行，而是排队，一旦调用EXEC，则将会执行所有命令，调用DISCARD将刷新（Flush？清空？重新执行？）事务队列并退出事务 示例代码： 123456789&gt; MULTIOK&gt; INCR fooQUEUED&gt; INCR barQUEUED&gt; EXEC1) (integer) 12) (integer) 1 可以看出EXEC返回一个数组，其中每个元素都是事务中单个命令的答复，其发出顺序与命令相同 当Reids连接处于MULTI的请求时，所有的命令都将以字符串queued答复，当EXEC时，将顺序执行 errors可能存在两种命令错误： 命令可能无法排队，因此在EXEC之前可能有错误（包括命令语法错误） 调用EXEC后，命令执行失败 客户端通过检查已排队（queued）的命令返回值来判断第一种错误，另外从2.6.5开始，服务器将记住在命令排队期间发生的错误，并且拒绝执行事务，返回错误并自动丢弃事务 EXEC执行后错误不会特殊处理，所有的命令都将被执及时有些命令失败 12345678910MULTI+OKSET a abc+QUEUEDLPOP a+QUEUEDEXEC*2+OK-ERR Operation against a key holding the wrong kind of value 即时命令失败，队列里的其他命令也会处理 1234&#123; name:stu time:1&#125;]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Transaction</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2020-01-08-MinimunPathSum]]></title>
    <url>%2F2020%2F01%2F08%2F2020-01-08-MinimumPathSum%2F</url>
    <content type="text"><![CDATA[Leetcode-641234567891011121314Given a m x n grid filled with non-negative numbers, find a path from top left to bottom right which minimizes the sum of all numbers along its path.Note: You can only move either down or right at any point in time.Example:Input:[ [1,3,1], [1,5,1], [4,2,1]]Output: 7Explanation: Because the path 1→3→1→1→1 minimizes the sum. solution解法为简单的动态规划，只要找到比较该元素，上方和左方的值的最小值，然后与该值相加，就可以得到解 123456789101112class Solution &#123; public int minPathSum(int[][] grid) &#123; for(int i&#x3D;1; i&lt;grid.length; i++) grid[i][0] +&#x3D; grid[i-1][0]; for(int j&#x3D;1; j&lt;grid[0].length; j++) grid[0][j] +&#x3D; grid[0][j-1]; for (int i&#x3D;1; i&lt;grid.length; i++) &#123; for (int j&#x3D;1; j&lt;grid[0].length; j++) &#123; grid[i][j] &#x3D; Math.min(grid[i][j-1], grid[i-1][j]) + grid[i][j]; &#125; &#125; return grid[grid.length-1][grid[0].length-1]; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Medium</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2020-01-08-SortColors]]></title>
    <url>%2F2020%2F01%2F08%2F2020-01-08-SortColors%2F</url>
    <content type="text"><![CDATA[Leetcode-75123456789101112131415Given an array with n objects colored red, white or blue, sort them in-place so that objects of the same color are adjacent, with the colors in the order red, white and blue.Here, we will use the integers 0, 1, and 2 to represent the color red, white, and blue respectively.Note: You are not suppose to use the library&#39;s sort function for this problem.Example:Input: [2,0,2,1,1,0]Output: [0,0,1,1,2,2]Follow up:A rather straight forward solution is a two-pass algorithm using counting sort.First, iterate the array counting number of 0&#39;s, 1&#39;s, and 2&#39;s, then overwrite array with total number of 0&#39;s, then 1&#39;s and followed by 2&#39;s.Could you come up with a one-pass algorithm using only constant space? solution题目乍一看非常简单,但确实说使用简单的sort方法以及o(n^2)的排序确实会浪费时间复杂度，本着好奇心，我试了一下，果然成了吊车尾 1234567891011121314class Solution &#123; public void sortColors(int[] nums) &#123; for(int i =0;i&lt;nums.length-1;i++)&#123; for(int j=i+1;j&lt;nums.length;j++)&#123; if(nums[i]&gt;nums[j])&#123; int tmp=nums[i]; nums[i]=nums[j]; nums[j]=tmp; &#125; &#125; &#125; &#125;&#125;Runtime: 1 ms, faster than 6.35% of Java online submissions for Sort Colors. 该题优化的核心位置是该数组是一个一维数组，设置两个指针，左边遍历0，遇到0往左放，遇到2往右放，r和l为左右分界线，index记录最后一个0的位置1234567891011121314151617181920212223242526272829class Solution &#123; public void sortColors(int[] nums) &#123; int l = 0; int r = nums.length - 1; int index = 0; while(l &lt;= r) &#123; if(nums[l] == 0) &#123; if(l &gt; index) &#123; int tmp = nums[index]; nums[index] = nums[l]; nums[l] = tmp; index++; &#125; else &#123; l++; index++; &#125; &#125; else if(nums[l] == 2) &#123; int tmp = nums[r]; nums[r] = 2; nums[l] = tmp; r--; &#125; else l++; &#125; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Medium</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2020-01-07-关于Promise的思考]]></title>
    <url>%2F2020%2F01%2F07%2F2020-01-07-%E5%85%B3%E4%BA%8EPromise%E7%9A%84%E6%80%9D%E8%80%83%2F</url>
    <content type="text"><![CDATA[题目（这道题在互联网上已经有了） 123可以添加任务，任务包含任务数据，任务延迟触发的等待时间。在任务到达触发时间点时，自动触发执行此任务。队列中任务保持先进先出原则：假设 A 任务的触发等待时间为 X，B 任务的触发等待时间为 Y，B 在 A 之后被添加入队列，则 A 的前驱任务执行完成后等待时间 X 后，才执行 A，同理在 A 执行完成后，等待时间 Y，才执行 B。 思路过程1.Java上线读题目就是延时队列的特征，Java有锁，有多线程，写起来多方便 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081import java.util.concurrent.BlockingQueue;import java.util.concurrent.DelayQueue;import java.util.concurrent.Delayed;import java.util.concurrent.TimeUnit;public class HandWritingQueue &#123; public static void main(String[] args) &#123; final BlockingQueue&lt;DelayedElement&gt; deque = new DelayQueue&lt;&gt;(); Runnable producerRunnable = new Runnable() &#123; int i = 10; public void run() &#123; while (true &amp;&amp; i&gt;0) &#123; try &#123; --i; System.out.println(&quot;producing &quot;+i+&quot;,wait &quot;+i+&quot; seconds&quot;); deque.put(new DelayedElement(1000 * i, &quot;i=&quot; + i)); Thread.sleep(200); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;; Runnable customerRunnable = new Runnable() &#123; public void run() &#123; while (true) &#123; try &#123; System.out.println(&quot;consuming:&quot; + deque.take().msg); //Thread.sleep(500); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;; Runnable getSize= new Runnable() &#123; @Override public void run() &#123; while (true) &#123; System.out.println(&quot;size=&quot;+deque.size()); try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;; Thread thread1 = new Thread(producerRunnable); thread1.start(); Thread thread2 = new Thread(customerRunnable); thread2.start(); Thread thread3 = new Thread(getSize); thread3.start(); &#125; static class DelayedElement implements Delayed &#123; private final long expire; private final String msg; public DelayedElement(long delay, String msg) &#123; this.msg = msg; expire = System.currentTimeMillis() + delay; &#125; @Override public long getDelay(TimeUnit unit) &#123; return unit.convert(this.expire - System.currentTimeMillis(), TimeUnit.MILLISECONDS); &#125; @Override public int compareTo(Delayed o) &#123; return -1;//FIFO &#125; &#125;&#125; 2.Node上线被提醒该题目可以用node实现，且不需要借助redis来做，然后我上手就是一把操作： 123456789101112131415161718192021222324&#x27;use strict&#x27;class DelayElement &#123; constructor(data, expire) &#123; this.data = data; this.expire = expire;//second &#125;&#125;const delayArray = [];//push two element in delayArraydelayArray.push(new DelayElement(1, 2));delayArray.push(new DelayElement(2, 1));let length = delayArray.length;let time_cnt = 0;while (delayArray.length &gt; 0) &#123; let de = delayArray.shift(); time_cnt += de.expire;//serial (function () &#123; setTimeout(() =&gt; &#123; console.log(&#x27;expire data is :&#x27; + de.data + &#x27;,expire time is :&#x27; + de.expire); &#125;, time_cnt * 1000); &#125;)();&#125; 我以为设计的考点也就是立即执行函数，延时的使用，但是这里的for循环是个伪串行，实际上是并发的，也为第三步的修改提供了bug 3.Promise时代一开始我是想把async函数放进去，写了如下的代码： 1234567891011121314151617&#x27;use strict&#x27;const delayArray = [];const daPush = (data, expire) =&gt; &#123; delayArray.push(async () =&gt; &#123; setTimeout(() =&gt; &#123; console.log(&#x27;data is &#x27; + data + &#x27; and expire is &#x27; + expire); &#125;, expire * 1000); &#125;);&#125;daPush(1, 4);//2 secondsdaPush(2, 5);(async () =&gt; &#123; for (const da of delayArray) &#123; await da(); &#125;&#125;)(); 发现代码还是串行的，然后查了一下可能的问题（以下为个人猜测，欢迎指正）async声明的函数会包装成Promise不假，但是for循环会并发去执行await中的async 4.正解 promise执行会阻塞主线程 Macrotasks和Microtasks 都属于上述的异步任务中的一种，他们分别有如下API：macrotasks: setTimeout, setInterval, setImmediate, I/O, UI renderingmicrotasks: process.nextTick, Promise, MutationObserver 任务队列中，在每一次事件循环中，macrotask只会提取一个执行，而microtask会一直提取，直到microsoft队列为空为止。 也就是说如果某个microtask任务被推入到执行中，那么当主线程任务执行完成后，会循环调用该队列任务中的下一个任务来执行，直到该任务队列到最后一个任务为止。 而事件循环每次只会入栈一个macrotask,主线程执行完成该任务后又会检查microtasks队列并完成里面的所有任务后再执行macrotask的任务。 以及macrotask应该对应的是check队列（该行未验证） 123456789101112131415161718192021222324252627282930&#x27;use strict&#x27;const delayArray = [];const daPush = (data, expire) =&gt; &#123; delayArray.push(() =&gt; new Promise((resolve,reject) =&gt; &#123; setTimeout(() =&gt; &#123; if(data) &#123; console.log(&#x27;data is &#x27; + data + &#x27; and expire is &#x27; + expire); resolve(true); &#125; else&#123; reject(&#x27;there is nodata&#x27;); &#125; &#125;, expire * 1000); &#125;));&#125;;daPush(1, 4);//2 secondsdaPush(2, 5);(async () =&gt; &#123; for (const da of delayArray) &#123; da().then((value)=&gt;&#123; // console.log(value); &#125;).catch((value)=&gt;&#123; console.log(value); &#125;); //没有28-33，只35行也可以 // await da(); &#125;&#125;)();]]></content>
  </entry>
  <entry>
    <title><![CDATA[2020-01-07-SetTimeout]]></title>
    <url>%2F2020%2F01%2F07%2F2020-01-07-SetTimeout%2F</url>
    <content type="text"><![CDATA[执行了一下程序： 12345while(true)&#123; setTimeout(()&#x3D;&gt;&#123; console.log(1) &#125;,0)&#125; 返回了一下内容： 123456789101112131415161718192021222324252627&lt;--- Last few GCs ---&gt;[12308:000001E565C2F6F0] 14167 ms: Mark-sweep 1395.9 (1425.2) -&gt; 1395.9 (1423.7) MB, 1754.1 &#x2F; 0.0 ms (+ 0.0 ms in 39 steps since start of marking, biggest step 0.0 ms, walltime since start of marking 1764 ms) (average mu &#x3D; 0.105, current mu &#x3D; 0.020) a[12308:000001E565C2F6F0] 14175 ms: Scavenge 1397.3 (1423.7) -&gt; 1397.3 (1425.2) MB, 7.0 &#x2F; 0.0 ms (average mu &#x3D; 0.105, current mu &#x3D; 0.020) allocation failure&lt;--- JS stacktrace ---&gt;&#x3D;&#x3D;&#x3D;&#x3D; JS stack trace &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; 0: ExitFrame [pc: 000002AFCABDC5C1]Security context: 0x037b5391e6e9 &lt;JSObject&gt; 1: &#x2F;* anonymous *&#x2F; [0000016D4360B9A1] [D:\working\h3yun\test.3.js:~1] [pc&#x3D;000002AFCAC7210F](this&#x3D;0x016d4360bad1 &lt;Object map &#x3D; 000001F79EE82571&gt;,exports&#x3D;0x016d4360bad1 &lt;Object map &#x3D; 000001F79EE82571&gt;,require&#x3D;0x016d4360ba91 &lt;JSFunction require (sfi &#x3D; 00000397F3EC6A31)&gt;,module&#x3D;0x016d4360ba09 &lt;Module map &#x3D; 000001F79EED3DA1&gt;,__filename&#x3D;0x0397f3ece219 &lt;Strin...FATAL ERROR: Ineffective mark-compacts near heap limit Allocation failed - JavaScript heap out of memory 1: 00007FF7C7BFC6AA v8::internal::GCIdleTimeHandler::GCIdleTimeHandler+4506 2: 00007FF7C7BD7416 node::MakeCallback+4534 3: 00007FF7C7BD7D90 node_module_register+2032 4: 00007FF7C7EF189E v8::internal::FatalProcessOutOfMemory+846 5: 00007FF7C7EF17CF v8::internal::FatalProcessOutOfMemory+639 6: 00007FF7C80D7F94 v8::internal::Heap::MaxHeapGrowingFactor+9620 7: 00007FF7C80CEF76 v8::internal::ScavengeJob::operator&#x3D;+24550 8: 00007FF7C80CD5CC v8::internal::ScavengeJob::operator&#x3D;+17980 9: 00007FF7C80D6317 v8::internal::Heap::MaxHeapGrowingFactor+232710: 00007FF7C80D6396 v8::internal::Heap::MaxHeapGrowingFactor+245411: 00007FF7C8200637 v8::internal::Factory::NewFillerObject+5512: 00007FF7C827D826 v8::internal::operator&lt;&lt;+7349413: 000002AFCABDC5C1 why因为业务代码阻塞住，没有进入timer_handler的循环，所以1虽然进入了timer的红黑树中，但是不可能输出，不像之前for循环会有一个截止条件，后续的定时器还是可以生效的 另外有一个地方记混了，遍历回调的时候，会执行直到回调为空或者最大执行回调数量，而业务代码只会在这里阻塞不会停止，这也是为何出现GC的日志 whatsetimeout是JS前端常用的控件用来延时执行一个函数（回调），当执行业务代码的时候我们会将settimeout，setImmediate，nextTick，setInterval插入timer_handler的不同队列中（详见左侧node分支，且文章也在更新中），当JS单线程执行完业务代码后，才开始eventloop查找观察者来进行回调，当然也存在延时不精确的可能]]></content>
  </entry>
  <entry>
    <title><![CDATA[2020-01-06-gRPC]]></title>
    <url>%2F2020%2F01%2F06%2F2020-01-06-gRPC%2F</url>
    <content type="text"><![CDATA[whygRPC是任何环境都可以运行的高性能开源框架，他可以通过pluggable support来高效实现负载均衡，心跳检测和授权，他也可以应用于分布式计算的最后一个流程（连接各个端到后端） 简单的服务定义 快速启动易扩展 跨语言，跨平台 双向流和鉴权 feature gRPC可以通过protobuf来定义接口，从而可以有更加严格的接口约束条件。关于protobuf可以参见笔者之前的小文Google Protobuf简明教程 另外，通过protobuf可以将数据序列化为二进制编码，这会大幅减少需要传输的数据量，从而大幅提高性能。 gRPC可以方便地支持流式通信(理论上通过http2.0就可以使用streaming模式, 但是通常web服务的restful api似乎很少这么用，通常的流式数据应用如视频流，一般都会使用专门的协议如HLS，RTMP等，这些就不是我们通常web服务了，而是有专门的服务器应用。） node123456$ # Clone the repository to get the example code$ git clone -b v1.25.0 https:&#x2F;&#x2F;github.com&#x2F;grpc&#x2F;grpc$ # Navigate to the dynamic codegen &quot;hello, world&quot; Node example:$ cd grpc&#x2F;examples&#x2F;node&#x2F;dynamic_codegen$ # Install the example&#39;s dependencies$ npm install]]></content>
      <categories>
        <category>gRPC</category>
      </categories>
      <tags>
        <tag>network</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2020-01-03-SearchInsertPosition]]></title>
    <url>%2F2020%2F01%2F03%2F2020-01-03-SearchInsertPosition%2F</url>
    <content type="text"><![CDATA[LeetCode38Easy Given a sorted array and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order. You may assume no duplicates in the array. Example 1: 12Input: [1,3,5,6], 5Output: 2 Example 2: 12Input: [1,3,5,6], 2Output: 1 Example 3: 12Input: [1,3,5,6], 7Output: 4 Example 4: 12Input: [1,3,5,6], 0Output: 0 离职后的第一题想先简单点热个身（后面有个难的目前还没做出来），就是说给一个target，返回它在数组中的位置 How该题目一上脑子就可以写下如下的代码 12345678910111213141516public int searchInsert(int[] nums, int target) &#123; if (nums == null || nums.length == 0) &#123; return 0; &#125; if (target &gt; nums[nums.length - 1]) &#123; return nums.length; &#125; int pos =1; for(int i =0;i&lt;nums.length-1;i++)&#123; if(nums[i]&lt;target &amp;&amp; nums[i+1]&gt;=target)&#123; pos = ++i; break; &#125; &#125; return pos;&#125; 但转念一想，题目中给定的是一个sorted array这是一个优化的切口，可以将O(n)的复杂度降低到O(logn),通过递归来拆解完成这道题 12345678910111213141516171819private int searchInsert(int[] nums, int target, int low, int high) &#123; int mid = (low+high)/2; if (target &lt; nums[mid]) &#123; if (mid == 0 || target &gt; nums[mid-1]) &#123; return mid; &#125; return searchInsert(nums, target, low, mid-1); &#125; if (target &gt; nums[mid]) &#123; if (mid == nums.length-1 || target &lt; nums[mid+1]) &#123; return mid+1; &#125; return searchInsert(nums, target, mid+1, high); &#125; return mid; &#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>easy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019-12-22-SpringBoot概要]]></title>
    <url>%2F2019%2F12%2F16%2F2019-12-22-SpringBoot%E6%A6%82%E8%A6%81%20%2F</url>
    <content type="text"><![CDATA[含义：spring 的简化配置版本（继承父类依赖，拥有父类的所有配置） 123456789101112131415&lt;!--你的项目pom文件--&gt;&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.0.4.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;&lt;/parent&gt;&lt;!--点开spring-boot-starter-parent，文件相对位置\org\springframework\boot\spring-boot-starter-parent\2.0.4.RELEASE--&gt;&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt; &lt;version&gt;2.0.4.RELEASE&lt;/version&gt; &lt;relativePath&gt;../../spring-boot-dependencies&lt;/relativePath&gt;&lt;/parent&gt; 微服务 AOP 简化部署，可以再pom.xml中配置plugins来实现导出jar包，方便执行 Features: starter 入口类标记@SpringBootApplication SpringBoot配置类@SpringBootConfiguration 配置类@Configuration 开启自动配置@EnableAutoConfiguration 自动配置包@AutoConfigurationPackage 导入组件@Import 疑惑 为什么使用注解 为什么需要AOP 为什么选择springboot]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>introduction</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019-12-22-zookeeper概要]]></title>
    <url>%2F2019%2F12%2F16%2F2019-12-22-zookeeper%E6%A6%82%E8%A6%81%2F</url>
    <content type="text"><![CDATA[含义：动物管理员，管理节点 作用：开源的分布式应用程序协调服务（简单来说，就是一个抽象出来，专门管理各个服务的管理员，发现服务，注册服务，以实现分布式应用的联合工作） feature 树状目录结构，节点称作znode 持久节点（客户端断开仍然存在） 临时节点（断开消失） 节点监听（通过get exists,getchildren来实行监听） 应用： 分布式锁 描述 问题场景 我们有一个服务C，将A系统的订单数据，发送到B系统进行财务处理，但这个服务部C署了三个服务器来进行并发，其中有些数据在传送处理时会new一个objectid，如果不添加锁，该数据可能被两个服务同时调起，在B服务中生成两条记录 解决方案 我们同步数据时候，需要给同一个数据加锁，防止该数据同时被两个服务调起，服务访问某条订单数据时候，需要先获得锁，操作完后释放锁 实现方式 每个服务连接一个znode的下属有序临时节点，并监听上个节点的变化，编号最小的临时节点获得锁，操作资源，来实现 服务注册和发现 问题场景 我们同步数据的服务C（上个表格中描述）,可能是部署在一个机器上的多进程，也可能是部署在多个物理ip上的服务，他是动态变化的，如果没有zookeeper类的软件，可能我每改一次ip，都需要重启一下服务，服务宕机了，也要改ip（不然404） 解决方案 我们需要有个服务来管理应用状态，知道服务的运行状态，这样，当其他服务调起这个服务的时候，才能通过zookeeper提供的地址进行同行 实现方式 服务启动会注册到zookeeper，并保持心跳，其他服务想要调用某服务的时候，询问zookeeper拿到地址，然后发送请求报文（例如RPC） 1.每个应用创建一个持久节点，每个服务在持久节点下建立临时节点，不同应用间会有监听，A服务如果变动，B服务会收到订阅]]></content>
      <categories>
        <category>zookeeper</category>
      </categories>
      <tags>
        <tag>introduction</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019-12-15-@SpringBootApplication]]></title>
    <url>%2F2019%2F12%2F15%2F2019-12-15-SpringBootApplication%2F</url>
    <content type="text"><![CDATA[启动类我们可以见到最简单的springboot的application.java文件如下123456@SpringBootApplicationpublic class SpringTestApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(SpringTestApplication.class, args); &#125; 实际上，SpringApplication的run方法时首先会创建一个SpringApplication类的对象，利用构造方法创建SpringApplication对象时会调用initialize方法 1234567891011public static ConfigurableApplicationContext run(Object source, String... args) &#123; return run(new Object[] &#123; source &#125;, args); &#125; public static ConfigurableApplicationContext run(Object[] sources, String[] args) &#123; return new SpringApplication(sources).run(args); &#125; public SpringApplication(Object... sources) &#123; initialize(sources); &#125; 其中initialize方法如下 1234567891011121314151617`private void initialize(Object[] sources) &#123; // 在sources不为空时，保存配置类 if (sources != null &amp;&amp; sources.length &gt; 0) &#123; this.sources.addAll(Arrays.asList(sources)); &#125; // 判断是否为web应用 this.webEnvironment = deduceWebEnvironment(); // 获取并保存容器初始化类，通常在web应用容器初始化使用 // 利用loadFactoryNames方法从路径MEAT-INF/spring.factories中找到所有的ApplicationContextInitializer setInitializers((Collection) getSpringFactoriesInstances( ApplicationContextInitializer.class)); // 获取并保存监听器 // 利用loadFactoryNames方法从路径MEAT-INF/spring.factories中找到所有的ApplicationListener setListeners((Collection) getSpringFactoriesInstances(ApplicationListener.class)); // 从堆栈信息获取包含main方法的主配置类 this.mainApplicationClass = deduceMainApplicationClass();&#125; 实例化后调用run： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public ConfigurableApplicationContext run(String... args) &#123; StopWatch stopWatch = new StopWatch(); stopWatch.start(); ConfigurableApplicationContext context = null; FailureAnalyzers analyzers = null; // 配置属性 configureHeadlessProperty(); // 获取监听器 // 利用loadFactoryNames方法从路径MEAT-INF/spring.factories中找到所有的SpringApplicationRunListener SpringApplicationRunListeners listeners = getRunListeners(args); // 启动监听 // 调用每个SpringApplicationRunListener的starting方法 listeners.starting(); try &#123; // 将参数封装到ApplicationArguments对象中 ApplicationArguments applicationArguments = new DefaultApplicationArguments( args); // 准备环境 // 触发监听事件——调用每个SpringApplicationRunListener的environmentPrepared方法 ConfigurableEnvironment environment = prepareEnvironment(listeners, applicationArguments); // 从环境中取出Banner并打印 Banner printedBanner = printBanner(environment); // 依据是否为web环境创建web容器或者普通的IOC容器 context = createApplicationContext(); analyzers = new FailureAnalyzers(context); // 准备上下文 // 1.将environment保存到容器中 // 2.触发监听事件——调用每个SpringApplicationRunListeners的contextPrepared方法 // 3.调用ConfigurableListableBeanFactory的registerSingleton方法向容器中注入applicationArguments与printedBanner // 4.触发监听事件——调用每个SpringApplicationRunListeners的contextLoaded方法 prepareContext(context, environment, listeners, applicationArguments, printedBanner); // 刷新容器，完成组件的扫描，创建，加载等 refreshContext(context); afterRefresh(context, applicationArguments); // 触发监听事件——调用每个SpringApplicationRunListener的finished方法 listeners.finished(context, null); stopWatch.stop(); if (this.logStartupInfo) &#123; new StartupInfoLogger(this.mainApplicationClass) .logStarted(getApplicationLog(), stopWatch); &#125; // 返回容器 return context; &#125; catch (Throwable ex) &#123; handleRunFailure(context, listeners, analyzers, ex); throw new IllegalStateException(ex); &#125;&#125; 为了建立调用逻辑画了一张图，比较粗糙 总结SpringApplication.run一共做了两件事 创建SpringApplication对象；在对象初始化时保存事件监听器，容器初始化类以及判断是否为web应用，保存包含main方法的主配置类。 调用run方法；准备spring的上下文，完成容器的初始化，创建，加载等。会在不同的时机触发监听器的不同事件 https://www.cnblogs.com/davidwang456/p/5846513.html]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>annotation</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019-12-14-分布式系统]]></title>
    <url>%2F2019%2F12%2F14%2F2019-12-14-%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%2F</url>
    <content type="text"><![CDATA[[TOC] 分布式锁原因：目的： 数据库唯一索引redis 的SETNXredis的RedLock分布式事务CAPBASEPaxosRaft]]></content>
      <categories>
        <category>Distribution</category>
      </categories>
      <tags>
        <tag>KnowageTree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019-10-27-DynamicProgramming动态规划]]></title>
    <url>%2F2019%2F10%2F27%2F2019-10-27-DynamicProgramming%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%2F</url>
    <content type="text"><![CDATA[what动态规划是通过组合子问题的解里求解原问题，一般被用来求最优化问题 1.刻画一个最优解的结构特征 2.递归定义最优解的值 3.计算最优解 4.计算的信息构造最优解]]></content>
      <categories>
        <category>Algorithms</category>
      </categories>
      <tags>
        <tag>DynamicProgramming</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019-09-21-中台是什么]]></title>
    <url>%2F2019%2F09%2F21%2F2019-09-21-%E4%B8%AD%E5%8F%B0%E6%98%AF%E4%BB%80%E4%B9%88%2F</url>
    <content type="text"><![CDATA[why公司最近上了一套中台服务，因为好奇所以查了一下资料，中台是为了提高开发效率，将各个服务中共同的组织，资源集中管理，作为一个整体服务，宏观上我们可以把淘宝客户端，盒马生鲜，饿了么看做大前端，而他们有一部分共享数据，比如用户信息，支付功能，搜索功能等 又比如我们公司的电商平台，核心系统包括，ERP（企业资源计划即 ERP Enterprise Resource Planning），WMS（仓库管理系统Warehouse Management System）以及一套交付系统（包含购买，安装服务，维修服务，代理商管理等），他们需要共享商品信息，ERP需要用来算账，WMS需要用来发货，交付系统需要用来记录他的生命周期，就在中台配置一套信息，就可以达到三套系统都可以访问的效果。 what中台也可以分类： 业务中台（如上举例我们公司的业务） 技术中台（如淘宝的中台，当然也有偏业务的部分，主要目的防止重复造轮子） 数据中台（包括建模，日志分析，profile） 算法中台（推荐算法，搜索算法等） feature目前中台还是比较烧钱的吧，公司没有到达一定的规模，这个东西还是没有什么卵用，我们目前上了一套ERP，一套中台，级别在千万吧，还需要各个部门进行配合，进行系统整合（以前都是各干各的，系统间几乎没有交互，重复造轮子）。恶心的我啊，加了10117了三个月才大体上能用了 不过我觉得中台的发展历史可能和服务一样，一个整体的服务臃肿，后续的中台还是会变成中心化，即一个核心业务，其他做成微服务，分布式的架构，是目前技术潮流的前进方向]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[2019-09-14Node日志感受]]></title>
    <url>%2F2019%2F09%2F14%2F2019-09-14-Node%E6%97%A5%E5%BF%97%E6%84%9F%E5%8F%97%2F</url>
    <content type="text"><![CDATA[why日志是用来记录程序运行重要的工具 记录请求日志，关键节点打上日志，可以追踪问题（生产） 方便调试，定位故障 监控应用的运行状态 what(egg.js为例)日志分为： appLogger应用日志，也是我们自定义的日志 coreLogger核心框架，插件日志 errorLogger agentLogger用于监控agent日志 日志级别： ctx.logger.debug() ctx.logger.info() ctx.logger.warn() ctx.logger.error() 以appLogger为例，一共4*4种 日志编码： 默认utf-8 feature目前日志都支持切割，每天一个文件，以.log.2019-09-14为尾缀（小时切割和文件大小切割实用性不高），编写日志的时候我们也需要注意如下几点： 在关键请求关键位置打好日志 打印日志注明这是哪个文件哪个方法处理的日志 logger.debug(`&gt;&gt;&gt;&gt; Entering yourMethod(month = $&#123;month&#125;, count= $&#123;count&#125;"); //通过日志 &gt;&gt;&gt;&gt; 和 &lt;&lt;&lt;&lt; 将给出函数输入和退出的信息 日志不能太多，一个是查问题日志太多，第二个是对硬盘写入日志也有一定性能影响（egg是写入内存，每秒保存一次硬盘） 合理使用try-catch来进行日志输出 日志写法一定要避免简洁，不要日志再抛错（正常打印参数，打印处理结果） 日志不能具备除了日志以外的功能 正确把握日志级别，info记录信息（最主要的），debug显示调试信息，warn显示警告，error保存数据库请求类型的报错 尽量使用ctx.logger而并非console.log，后者将会把所有日志打印在stdout中，无法关闭或打开调试信息，并且不区分级别]]></content>
      <categories>
        <category>Node</category>
      </categories>
      <tags>
        <tag>logs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[绍兴游记]]></title>
    <url>%2F2019%2F05%2F06%2F2019-05-05-%E7%BB%8D%E5%85%B4%E6%B8%B8%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[5月1日搭车去了绍兴，一个是自己毕业后其实既没有毕业旅行，也没有去哪里玩儿，所以想补偿自己一下，第二个是我表姐给我买了票了，想着还是去吧。 因为最后一个工作日加了个班，然后又起得很早，读着东野圭吾的《嫌疑人X的献身》，中午饿了就在高铁上买了15元的盒饭，拿着kindle强行盖了会儿，，锁屏突然推送了广告，这几个字，读了好几遍，好是喜欢。耳机刚好播放到最近很是喜欢的《你的酒馆对我打了样》，我调整了椅子，时速307km逃离着这座有你的城市。 杭州高楼鳞次栉比，穿过一栋栋高楼就来到了绍兴，这个城市不是很繁华，倒也是一个保留的很好的江南古镇，我很喜欢这里，火车站，背着包，司机师傅操着一口流畅的普通话礼貌的问着我去哪儿，一边介绍着风景名胜，满满的都是对这个城市的热爱，有风景名胜兰亭，壮阔的东湖，一个慢节奏的小城市，除却了对金钱的渴望，连揽客都变得那么悠闲。 吃过饭，和侄子一起去了仓桥直街，其实可以理解为低配版的南锣鼓巷，人不算特别多吧，但是风景却很好的保留了江南的风味，一轮明月（非p30pro），以及灯光的烘托，让江南的夜晚，似乎比白天更加的夺目。陈旧的街巷保留了最初的最原始的石板街，街边的店家还是很古旧的撑着旗帜，还是过去那种一个很大的门（2m高*7个木板）还有很多过去的宣传标语，当然也有很多小吃。 第二天的行程主要就是鲁迅故居了，其实并没有什么让我眼前一亮的地方，因为这里的人实在太多了，我早上九点半抵达景点，到11点才排队进入了鲁迅祖居，倒也很是沮丧，而且祖居里其实并没有什么值得参考的，游人们看长安花一样，参观者一个一个的房间。然后我又排队了40分钟进入了百草园，想一看鲁迅童年最快乐的地方，但却也什么也没有看到，一个不是很好看的花园，料理的和我爷爷的菜地一样，不过或许树人童年就是在这么一块地方进行玩耍的，很多游人围着百草园的一块大石头上合影留恋，排着队，各种姿势摆拍，令我觉得很是不舒服（我也没有拍到）。 倒也怎么看，鲁迅的童年应该也很是无聊，强行找着自己的乐子吧，后来排了30分钟的队伍去了三味书屋，其实我当时的心情是抗拒的，但还是忍着烈日，走上了不归的队伍，书屋的景点其实很小，一个小的教室，两边是家长的坐席，中间是学生的座位，图片可以看到鲁迅其实是坐在讲台左边的，看来他小时候也是个先生特别关照的对象鸭。 其实每逛完一个景点都是非常长的商业街，路的两边充斥着特产豆腐，黄酒产品，虽然我不是很反感这种景点恰饭情景，但是满街飘着臭豆腐的味道，回荡在鲁迅故居的上空，但多少也是有点违和，第二天的行程是安昌古镇，其实也没有什么特别的。 历史的前轮碾压而过，很多东西都因为商业化而丢失了曾经的自己，不过总体来讲我还是比较喜欢吃过午饭，在江南的水边走着，遇到一位94岁的奶奶晒太阳，打了个招呼，他居住在这里三十年了，每次节假日，这里都会来很多人，之前就在这河里洗衣服，打水，后来腿脚不方便了，就搬把凳子坐在这里，听着繁华的声音，晒着太阳，看着船夫送走一个又一个人，这里的瓦年龄都很大，之前屋子的瓦还坏过一个，他折腾了好久才暂时不滴水了，她涛涛不觉的讲着，沉醉在这个小镇带给他的快乐和烦恼中 两天的行程不是很满，不是很累，也不是很轻松（到哪儿，哪儿都排队），回去没有抢到票，从绍兴一直站着回了北京，小说确实也没有读的下去，我看着窗外的风景，思念着一个人，认识这么久，我还没和你一起旅游过]]></content>
  </entry>
  <entry>
    <title><![CDATA[2019-04-24-Nodejs12]]></title>
    <url>%2F2019%2F04%2F24%2F2019-04-24-Nodejs12%2F</url>
    <content type="text"><![CDATA[Introducing Node.js 12raw article Apr 24 This blog was written by Bethany Griggs and Michael Dawson, with additional contributions from the Node.js Release Team and Technical Steering committee. We are excited to announce Node.js 12 today. Highlighted updates and features include faster startup and better default heap limits, updates to V8, TLS, llhttp, new features including diagnostic report, bundled heap dump capability and updates to Worker Threads, N-API and ES6 module support and more. The Node.js 12 release replaces version 11 in our current release line. The Node.js release line will become a Node.js Long Term Support (LTS) release in Oct 2019 (more details on LTS strategy here). V8 Gets an Upgrade: V8 update to V8 7.4As always a new version of the V8 JavaScript engine brings performance tweaks and improvements as well as keeping Node.js up with the ongoing improvements in the language and runtime. Highlights include: Async stack traces: https://v8.dev/blog/v8-release-72#async-stack-traces Faster calls with arguments mismatch: https://v8.dev/blog/v8-release-74#faster-calls-with-arguments-mismatch Faster await: https://v8.dev/blog/v8-release-73#faster-await Faster javascript parsing: https://v8.dev/blog/v8-release-72#javascript-parsing Read more about V8 at their official blog. Hello TLS 1.3 Node.js 12 is introducing TLS1.3 support and making it the default max protocol, while also supporting CLI/NODE_OPTIONS switches to disable it if necessary. TLS1.3 is a major update to the TLS protocol, with many security enhancements and should be used over TLS1.2 whenever possible. TLS1.3 is different enough that even though the OpenSSL APIs are technically API/ABI compatible when TLS1.3 is negotiated, changes in the timing of protocol records and of callbacks broke assumptions hard-coded into the ‘tls’ module. This change introduces no API incompatibilities when TLS1.2 is negotiated. It is the intention that it be backported to current and LTS release lines with the default maximum TLS protocol reset to ‘TLSv1.2’. This will allow users of those lines to explicitly enable TLS1.3 if they want. If you want to read more you can check out these related articles:https://developer.ibm.com/blogs/openssl-111-has-landed-in-nodejs-master-and-why-its-important-for-nodejs-lts-releases/, https://developer.ibm.com/blogs/tls13-is-coming-to-nodejs/ Properly configure default heap limitsThis update will configure the JavaScript heap size based on available memory instead of using defaults that were set by V8 for use with browsers. In previous releases, unless configured, V8 defaulted to limiting the max heap size to 700 MB or 1400MB on 32 and 64-bit platforms respectively. Configuring the heap size based on available memory ensures that Node.js does not try to use more memory than is available and terminating when its memory is exhausted. This is particularly useful when processing large data-sets. As before, it will still be possible to set — max-old-space-size to use a different limit if the default is not appropriate for your application. Switch default http parser to llhttpNode.js 12 will also switch the default parser to llhttp. This will be beneficial in that it will make testing and comparing the new llhttp-based implementation easier. First introduced as llhttp experimental in v11.2.0, llhttp will be taken out of experimental in this release. Making Native Modules Easier — progress continuesNode.js 12 continues the trend of making building and supporting native modules easier. Changes include better support for native modules in combination with Worker threads, as well as N-API (https://nodejs.org/api/n-api.html#n_api_n_api) version 4 (which has also been backported to 8.x and 10.x) which makes it easier to use your own threads for native asynchronous functions. You can read more about this and how you can leverage it in your modules in this great article here: https://medium.com/the-node-js-collection/new-features-bring-native-add-ons-close-to-being-on-par-with-js-modules-cd4f9b8e4b4 Worker ThreadsWorker Threads (https://nodejs.org/api/worker_threads.html), while not new in this release, are still seeing progress. The use of Workers Threads no longer requires the use of a flag and they are progressing well towards moving out of experimental. While Node.js already performs well with the single-threaded event loop, there are some use-cases where additional threads can be leveraged for better results. We’d like you to try them out and let us know what use cases you have where they are helpful. For a quick introduction check out this great article: https://medium.com/@Trott/using-worker-threads-in-node-js-80494136dbb6. Diagnostic ReportsNode.js 12 brings with it a new experimental feature “Diagnostic report.” This allows you to generate a report on demand or when certain events occur. This report contains information that can be useful to help diagnose problems in production including crashes, slow performance, memory leaks, high CPU usage, unexpected errors and more. You can read more about it in this great article: https://medium.com/the-node-js-collection/easily-identify-problems-in-node-js-applications-with-diagnostic-report-dc82370d8029. Heap DumpsIf you ever needed to generate heap dumps in order to investigate memory issues but were slowed down by having to install a new module into production, the good news is that Node.js 12 brings integrated heap dump capability out of the box. You can check out the documentation in https://github.com/nodejs/node/pull/27133 and https://github.com/nodejs/node/pull/26501 to learn more. Startup ImprovementsIn Node.js 11 we shipped built-in code cache support in workers — when loading built-in libraries written in JavaScript, if the library was previously compiled on the main thread, the worker thread no longer needs to compile it from scratch but can reuse the v8 code cache generated by the main thread to speed up compilation. Similarly, the main thread can reuse the cache generated by workers. This gave a roughly 60% speedup for the startup of workers. Now in Node.js 12 we generate the code cache for built-in libraries in advance at build time, and embed it in the binary, so in the final release, the main thread can use the code cache to start up the initial load of any built-in library written in JavaScript. This gives a ~30% speedup in startup time for the main thread. ES6 Module SupportNode.js 12 brings an updated experimental version of support for ES6 modules. It is an important step toward a supported implementation and we’d like you to try it out and give us feedback. For more details check out this great blog post. New compiler and platform minimumsNode.js and V8 continue to embrace newer C++ features and take advantage of newer compiler optimizations and security enhancements. With the release of Node.js 12, the codebase now requires a minimum of GCC 6 and glibc 2.17 on platforms other than macOS and Windows. Binaries released at Node.js org use this new toolchain minimum and therefore include new compile-time performance and security enhancements. The increment in minimum compiler and libc requirements also increments minimums in supported platforms. Platforms using glibc (most platforms other than macOS and Windows) must now include a minimum version of 2.17. Common Linux platforms compatible with this version include Enterprise Linux 7 (RHEL and CentOS), Debian 8 and Ubuntu 14.04. Binaries available from nodejs.org will be compatible with these systems. Users needing to compile their own binaries on systems not natively supporting GCC 6 may need to use a custom toolchain. Even though Node.js 12.0.0 may compile with older compilers, expect the Node.js 12 codebase (including V8) to rapidly adopt C++ features supported by GCC 6 during the pre-LTS timeframe. Windows minimums remain the same as Node.js 11, requiring at least Windows 7, 2008 R2 or 2012 R2 and a minimum compiler of Visual Studio 2017. macOS users needing to compile Node.js will require a minimum of Xcode 8 and Node.js binaries made available on nodejs.org will only support a minimum of macOS 10.10 “Yosemite”. Further details are available in the Node.js BUILDING.md. Thank you!A big thank you to everyone who made this release come together, whether you submitted a pull request, helped with our benchmarking efforts, or you were in charge of one of the release versions. We’d also like to thank the Node.js Build Working Group for ensuring we have the infrastructure to create and test releases. The release manager for Node.js 12 is Bethany Griggs. For a full list of the release team members head here. You can read more about the complete list of features here. If you are interested in contributing to Node.js, we welcome you. Learn more via our contributor guidelines.]]></content>
  </entry>
  <entry>
    <title><![CDATA[2019-04-20-rentingHouse]]></title>
    <url>%2F2019%2F04%2F20%2F2019-04-20-rentingHouse%2F</url>
    <content type="text"><![CDATA[快要毕业了，朋友圈里洋溢着，毕业的快乐，直系学弟们也返校进行了毕业论文的最终答辩，也希望他们都取得一个好的成绩，能在回首大学四年时候，不因为碌碌无为而后悔，能够在社一中，找到一份合适的工作，并感谢曾经那个在大学奋斗的自己。 毕业季第一道坎就是租房（家里有矿的，这篇文章你就可以关掉了），总体来说，在京就业，房租确实很贵的，不过对于计算机专业来说，应该还是可以的。我们熟知的计算机区域 望京SOHO（小企业居多） 中关村 中关村软件园（大厂） 对应的租房地点可以选择： 孙河（就可能地铁站远一点） 上地附近 回龙观，朱辛庄 主要平台（按推荐顺序）： 自如（个人选择项，应届生有特权） 豆瓣小组 闲鱼 相如&gt;蛋壳=贝壳 应届生可能囊中羞涩，所以建议选择自如，分期月付（应届免押金，分起费120附近），不过计算机专业的应届生薪资理论上是&gt;=7k，所以我觉得应该马马虎虎可以生存下来了。之所以不推荐其他的中介，是因为你可能租房后，对于维修，舍友抽烟，养的宠物半夜狂叫，又退不了租，陷入麻烦中。（自如麻烦来结一下广告费） 另外整理一下招聘的软件（按推荐顺序）： （个人软件工程，仅供参考） BOSS 拉钩 智联招聘 脉脉 希望这些资料对刚毕业的你有所帮助，其余想起来的，再直接更新]]></content>
  </entry>
  <entry>
    <title><![CDATA[2019-04-17-日记]]></title>
    <url>%2F2019%2F04%2F17%2F2019-04-17-%E6%97%A5%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[经历了连续9*13小时的工作后，我终于得到了一天的调休计划，昨晚十一点半打车从五棵松到家 洗了个热水澡，关了手机闹铃，打开了Alexa的环境噪音，难的踏实的进入了梦中。 但是！！ 我Alexa的闹钟忘记关了，七点被吵醒后一直没有睡着，所以起床热了杯牛奶，弄了张煎饼，涂了点番茄酱就凑合吃了，后来外出和朋友聊了会儿天，倒确实点出了一些目前存在的问题 一个好的技术不仅要知其然，更要知其所以然，多挖掘他背后的源码，去思考如何实现，这样才能在高并发时，将200ms优化到100ms，才是一个高级程序员应该具备的素质之一 Node学习分为三年，第一年知其语法，会写应用，第二年知其框架，高级开发，第三年，读其源码，知其原理 多用语言去写一些工具类，多去学习和参考优质轮子，而不是写一些玩具，别人都写烂的东西 （重要的应该就这么多了） 朋友的话很对，我也进行了思考，自己在JS的道路上，摸着黑走路，对于源码其实要读，但是之前打开看过一眼就一脸懵逼的状态，所以还是需要有时间学习一下优质的GitHub，撕开一个口子，然后进入到正轨，自己去多写一些方法区调用，然后一点点去琢磨，他的实现过程。 4月底的计划就是 尽量换一份工作，受不了8117，薪资还不如麦当劳的临时工 自如租约到期了，搬家到朱辛庄或者霍营 没换工作的话，买一本书通勤看会儿，换工作的话，抽个零碎的时间读，顺便整理笔记，更博（暂定这个月读一下v8的gc） 五一出去旅游，暂时想去杭州看看 买点竹筒，想做竹筒饭]]></content>
      <categories>
        <category>life</category>
      </categories>
      <tags>
        <tag>diary</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[暂停更新通告[作废]]]></title>
    <url>%2F2019%2F04%2F13%2F2019-04-13-%E6%9A%82%E5%81%9C%E6%9B%B4%E6%96%B0%E9%80%9A%E5%91%8A%2F</url>
    <content type="text"><![CDATA[自今日起，博客开始停更 996.icu年后开始，互联网似乎过得都不好，从七陌被裁（也有个人原因吧），到被航天二院，知网，中电科因为学历卡住入职（BOSS直聘，面试完了，技术找人事审核不通过），后来遇到了一系列傲慢的中科软系列面试，无限加班的创业公司，还有那种以培训机构为目标招人的小公司。最终未能收获一个满意的offer，最终舔狗选择了一家说是不加班的某所，然，现在才发现，实在太忙，包括现在也刚刚到家，工作也没有pc，没有网络，所以也很不方便随时学习，可能有一些手写笔记，但经历有限，所以最近会停止更新 年后996冲上了榜首，让世界都在反思为什么中国的加班为什么如此疯狂，但话题热度很快下降，因为没有人会去放下手中的工作去抵制，毕竟生活总要继续下去 生活总是这样，起起落落落 努力不一定有回报，但不努力一定很（mei）舒（hui）服(bao) 晚安~hexo]]></content>
  </entry>
  <entry>
    <title><![CDATA[PermutationSequence-60]]></title>
    <url>%2F2019%2F04%2F09%2F2019-04-09-PermutationSequence%2F</url>
    <content type="text"><![CDATA[ProblemThe set [1,2,3,...,*n*] contains a total of n! unique permutations. By listing and labeling all of the permutations in order, we get the following sequence for n = 3: &quot;123&quot; &quot;132&quot; &quot;213&quot; &quot;231&quot; &quot;312&quot; &quot;321&quot; Given n and k, return the kth permutation sequence. Note: Given n will be between 1 and 9 inclusive. Given k will be between 1 and n! inclusive. Example 1: 12Input: n &#x3D; 3, k &#x3D; 3Output: &quot;213&quot; Example 2: 12Input: n &#x3D; 4, k &#x3D; 9Output: &quot;2314&quot; keysolutionperfect]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Medium</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[https与http]]></title>
    <url>%2F2019%2F04%2F06%2F2019-04-06-https%E4%B8%8Ehttp%2F</url>
    <content type="text"><![CDATA[whatadvantage客户端在使用HTTPS方式与Web服务器通信时有以下几个步骤，如图所示。 （1）客户使用https的URL访问Web服务器，要求与Web服务器建立SSL连接。 （2）Web服务器收到客户端请求后，会将网站的证书信息（证书中包含公钥）传送一份给客户端。 （3）客户端的浏览器与Web服务器开始协商SSL连接的安全等级，也就是信息加密的等级。 （4）客户端的浏览器根据双方同意的安全等级，建立会话密钥，然后利用网站的公钥将会话密钥加密，并传送给网站。 （5）Web服务器利用自己的私钥解密出会话密钥。 （6）Web服务器利用会话密钥加密与客户端之间的通信。]]></content>
  </entry>
  <entry>
    <title><![CDATA[SpiralMatrix2-59]]></title>
    <url>%2F2019%2F04%2F06%2F2019-04-06-SpiralMatrix2%2F</url>
    <content type="text"><![CDATA[problem Given a positive integer n, generate a square matrix filled with elements from 1 to n2 in spiral order. Example: 1234567&gt;Input: 3&gt;Output:&gt;[[ 1, 2, 3 ],[ 8, 9, 4 ],[ 7, 6, 5 ]&gt;] key虽然标了medium，但是确实很简单，形成一个口字型闭环，一层层去处理就好了，然后再主要就是控制口字循环时候的边界，以及最后一个元素的判断 solution12345678910111213141516171819202122232425262728public int[][] generateMatrix(int n) &#123; int [][]res &#x3D; new int[n][n]; int left &#x3D; 0; int right &#x3D; n-1; int top &#x3D; 0; int bottom &#x3D; n-1; int index &#x3D; 1; int quit &#x3D; n*n; while(index&lt;&#x3D;quit)&#123; for(int i&#x3D;left;i&lt;&#x3D;right;i++) &#123; res[top][i] &#x3D; (index++); &#125; top++; for(int i&#x3D;top;i&lt;&#x3D;bottom;i++)&#123; res[i][right] &#x3D; (index++); &#125; right--; for(int i&#x3D;right;i&gt;&#x3D;left;i--) &#123; res[bottom][i]&#x3D;(index++); &#125; bottom--; for(int i&#x3D;bottom;i&gt;&#x3D;top;i--) &#123; res[i][left]&#x3D;(index++); &#125; left++; &#125; return res; &#125; perfectno]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Medium</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LengthofLastWord]]></title>
    <url>%2F2019%2F04%2F06%2F2019-04-06-LengthofLastWord%2F</url>
    <content type="text"><![CDATA[problem Given a string s consists of upper/lower-case alphabets and empty space characters &#39; &#39;, return the length of last word in the string. If the last word does not exist, return 0. Note: A word is defined as a character sequence consists of non-space characters only. Example: 12Input: &quot;Hello World&quot;Output: 5 key该方法调用了java的String.split(regex)所以在复杂度上回很高，大概仅仅beat了6%的玩家，但解决很快，正确的算法思维就倒序遍历，最后开始查往前，最后一个非空格查到空格结束 solution123456789101112//7mspublic int lengthOfLastWord(String s) &#123; if(s.length()&lt;=0)return 0; String[] tmp = s.split(&quot;\\s&quot;); int lastIndex = tmp.length-1; if(lastIndex&lt;0) &#123; return 0; &#125;else &#123; return tmp[lastIndex].length(); &#125; &#125; perfect1234567891011121314151617181920212223class Solution &#123; public int lengthOfLastWord(String s) &#123; int n &#x3D; s.length() - 1; int length &#x3D; 0; for(int i &#x3D; n; i &gt;&#x3D; 0; i--) &#123; if(length &#x3D;&#x3D; 0) &#123; if(s.charAt(i) &#x3D;&#x3D; &#39; &#39;) &#123; continue; &#125;else &#123; length++; &#125; &#125;else &#123; if(s.charAt(i) &#x3D;&#x3D; &#39; &#39;) &#123; break; &#125; else &#123; length++; &#125; &#125; &#125; return length; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>easy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[eventLoop]]></title>
    <url>%2F2019%2F04%2F04%2F2019-04-04-eventLoop%2F</url>
    <content type="text"><![CDATA[whatEvent Loop是一个程序结构，用于等待和发送消息和事件 a programming construct that waits for and dispatches events or messages in a program. 简单说，就是在程序中设置两个线程：一个负责程序本身的运行，称为”主线程”；另一个负责主线程与其他进程（主要是各种I/O操作）的通信，被称为”Event Loop线程”（可以译为”消息线程”）。 由上图可以清楚知道Node的单线程指的是主线程为单线程 异步执行1234567&#x2F;&#x2F; test.jssetTimeout(() &#x3D;&gt; console.log(1));setImmediate(() &#x3D;&gt; console.log(2));process.nextTick(() &#x3D;&gt; console.log(3));&#x2F;&#x2F;异步最快Promise.resolve().then(() &#x3D;&gt; console.log(4));(() &#x3D;&gt; console.log(5))();&#x2F;&#x2F;同步任务最早执行&#x2F;&#x2F;53412 异步分为两种： 本轮循环：process.nextTick(),Promise 次轮循环:setTimeout(),setInterval,setImmediate 每一次循环中，setTimeout等次轮循环在timers阶段执行，而本轮循环就在check阶段执行，所以会先展示]]></content>
  </entry>
  <entry>
    <title><![CDATA[春节12响]]></title>
    <url>%2F2019%2F04%2F04%2F2019-04-04-%E6%98%A5%E8%8A%8212%E5%93%8D%2F</url>
    <content type="text"><![CDATA[1234567891011121314151617181920212223242526272829303132&#x2F;&#x2F; File: twelve_biubiu.c&#x2F;&#x2F; Permission: CN-2082-2&#x2F;&#x2F; Author: Li.YiYi&#x2F;&#x2F; Dept: PE-362, UG&#x2F;&#x2F; Origin: TI-352132&#x2F;&#x2F; 春节十二响 biu biu biu!#env &quot;planet_engine&quot;int init() &#123; set_engine_number_mask(ENGINE_ALL); set_funeral_level(FUNERAL_FULL); &#x2F;&#x2F; 允许误差10秒以内 if (unix_time() &lt; make_unix_time(2082, 1, 28, 23, 59, 60-10)) return ERR_ENGIN_ENV; return engine_check_init(); &#x2F;&#x2F; after compile and before real run&#125;int main() &#123; set_curve(CURVE_NATURAL); &#x2F;&#x2F; 自然曲线耗费燃料最少 for (int i :range(0, 12, 1)) &#123; engine_start(); wait_engine(ENGINE_STATE_CHAGNE); sleep(2000); engin_stop(); wait_engine(ENGINE_STATE_CHAGNE); sleep(4000); &#x2F;&#x2F; 这个时长在模拟器里听起来更像心跳 &#125; return 0;&#125;int final() &#123; engine_ensure_shutdown();&#125;]]></content>
      <categories>
        <category>life</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[各种Java中锁]]></title>
    <url>%2F2019%2F04%2F04%2F2019-04-04-%E5%90%84%E7%A7%8DJava%E4%B8%AD%E9%94%81%2F</url>
    <content type="text"><![CDATA[悲观锁：先锁后用每次读数据都悲观认为会被其他操作修改，应用于synchroized , ReentrantLock，因为悲观所以开销大，会阻塞其他线程 乐观锁：先用后判断每次读数据乐观认为没有被其他操作修改，应用于java.util.concurrent.atomic,使用版本号和CAS算法实现 适用于多读的应用类型，提高吞吐量 公平锁：多个线程按申请所顺序取锁无 非公平锁多个线程不按申请顺序取锁，提高吞吐量 可入锁外层使用锁后，内层仍可以使用，而且不会死锁 不可重入锁独享锁共享锁互斥锁 读写锁 分段锁 偏向锁 轻量级锁 重量级锁 自旋锁]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>lock</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MinStack]]></title>
    <url>%2F2019%2F03%2F24%2F2019-03-24-MinStack%2F</url>
    <content type="text"><![CDATA[problem Design a stack that supports push, pop, top, and retrieving the minimum element in constant time. push(x) – Push element x onto stack. pop() – Removes the element on top of the stack. top() – Get the top element. getMin() – Retrieve the minimum element in the stack. Example: 12345678MinStack minStack &#x3D; new MinStack();minStack.push(-2);minStack.push(0);minStack.push(-3);minStack.getMin(); --&gt; Returns -3.minStack.pop();minStack.top(); --&gt; Returns 0.minStack.getMin(); --&gt; Returns -2.]]></content>
  </entry>
  <entry>
    <title><![CDATA[FindMinimumInRotatedSortedArrayII]]></title>
    <url>%2F2019%2F03%2F23%2F2019-03-23-FindMinimumInRotatedSortedArrayII%2F</url>
    <content type="text"><![CDATA[problem Find Minimum in Rotated Sorted Array II Hard Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand. (i.e., [0,1,2,4,5,6,7] might become [4,5,6,7,0,1,2]). Find the minimum element. The array may contain duplicates. Example 1: 12&gt;Input: [1,3,5]&gt;Output: 1 Example 2: 12&gt;Input: [2,2,2,0,1]&gt;Output: 0 Note: This is a follow up problem to Find Minimum in Rotated Sorted Array. Would allow duplicates affect the run-time complexity? How and why? key??? solution12345678910class Solution &#123; public int findMin(int[] nums) &#123; for (int i = 0; i &lt; nums.length - 1; i++) &#123; if (nums[i] &gt; nums[i + 1]) &#123; return nums[i + 1]; &#125; &#125; return nums[0]; &#125;&#125; perfect]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Hard</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[FindMinimumInRotatedSortedArray]]></title>
    <url>%2F2019%2F03%2F23%2F2019-03-23-FindMinimumInRotatedSortedArray%2F</url>
    <content type="text"><![CDATA[problem Find Minimum in Rotated Sorted Array Medium Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand. (i.e., [0,1,2,4,5,6,7] might become [4,5,6,7,0,1,2]). Find the minimum element. You may assume no duplicate exists in the array. Example 1: 12&gt;Input: [3,4,5,1,2] &gt;Output: 1 Example 2: 12&gt;Input: [4,5,6,7,0,1,2]&gt;Output: 0 keysolution12345678public int findMin(int[] nums) &#123; for (int i = 0; i &lt; nums.length - 1; i++) &#123; if (nums[i] &gt; nums[i + 1]) &#123; return nums[i + 1]; &#125; &#125; return nums[0]; &#125; perfect12I&#39;m the perfectbut this problem will harder in the next problem]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Medium</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[安全防范]]></title>
    <url>%2F2019%2F03%2F23%2F2019-03-23-%E5%AE%89%E5%85%A8%E9%98%B2%E8%8C%83%2F</url>
    <content type="text"><![CDATA[分类 XSS 攻击：对 Web 页面注入脚本，使用 JavaScript 窃取用户信息，诱导用户操作。 CSRF 攻击：伪造用户请求向网站发起恶意请求。 钓鱼攻击：利用网站的跳转链接或者图片制造钓鱼陷阱。 HTTP参数污染：利用对参数格式验证的不完善，对服务器进行参数注入攻击。 远程代码执行：用户通过浏览器提交执行命令，由于服务器端没有针对执行函数做过滤，导致在没有指定绝对路径的情况下就执行命令。 XSS攻击cross-site-scripting跨域脚本攻击]]></content>
      <categories>
        <category>security</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[mysql事务]]></title>
    <url>%2F2019%2F03%2F23%2F2019-03-23-mysql%E4%BA%8B%E5%8A%A1%2F</url>
    <content type="text"><![CDATA[whatMYSQL事务主要用于保证一串事情要么都成功，要么就回滚，例如付款后，要先写入支付订单表，再个人信息中加入会员权益。这两个操作要么顺序执行成功，要么就回滚 原则ACID Atomicity原子性 确保事务内的所有操作都成功完成，否则事务将被中止在故障点，以前的操作将回滚到以前的状态。 Consistency一致性 数据库的修改是一致的 Isolation隔离性 事务是彼此独立的 Durability可靠性 确保事务提交后，结果永久存在 隔离性 隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括 读未提交（Read uncommitted）–不严格 读提交（read committed） 可重复读（repeatable read）–默认级别（避免幻读） 串行化（Serializable）–最严格 没有隔离性的问题1.脏读12update account set money&#x3D;money+100 where name&#x3D;’B’;update account set money&#x3D;money - 100 where name&#x3D;’A’; 当执行第一条语句的时候，事务没有提交，那么来读B的账户钱都多了100块 脏读：读取了另一个事务未提交的数据 2.不可重复读情景：多次读同一个数据的时候，这个数据被别人改了，导致结果不一致 3.幻读幻读和不可重复读一样，读取到了另外一条已经提交的事务，所不同的是它针对的是一批数据的整体 实现方式自动方式beginTransactionScope(scope, ctx) 1234567const result &#x3D; await app.mysql.beginTransactionScope(async conn &#x3D;&gt; &#123; &#x2F;&#x2F; don&#39;t commit or rollback by yourself await conn.insert(table, row1); await conn.update(table, row2); return &#123; success: true &#125;;&#125;, ctx); &#x2F;&#x2F; if error throw on scope, will auto rollback 手动方式beginTransaction 12345678910const conn &#x3D; await app.mysql.beginTransaction(); &#x2F;&#x2F; 初始化事务try &#123; await conn.insert(table, row1); &#x2F;&#x2F; 第一步操作 await conn.update(table, row2); &#x2F;&#x2F; 第二步操作 await conn.commit(); &#x2F;&#x2F; 提交事务&#125; catch (err) &#123; &#x2F;&#x2F; error, rollback await conn.rollback(); &#x2F;&#x2F; 一定记得捕获异常后回滚事务！！ throw err;&#125; 表达式Literalapp.mysql.literals.now 查看数据库事务隔离性级别 1select @@tx_isolation;]]></content>
      <categories>
        <category>mysql</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[bashrc]]></title>
    <url>%2F2019%2F03%2F15%2F2019-03-15-bashrc%2F</url>
    <content type="text"><![CDATA[where通常在home目录下的一个隐藏文件，访问可以1vim ~&#x2F;.bashrc whatbash 在每次启动时都会加载 .bashrc 文件的内容。每个用户的 home 目录都有这个 shell 脚本。它用来存储并加载你的终端配置和环境变量 end12&#x2F;&#x2F;更新修改source ~&#x2F;.bashrc]]></content>
  </entry>
  <entry>
    <title><![CDATA[安装mysql服务以及常见问题解决]]></title>
    <url>%2F2019%2F03%2F14%2F2019-03-14-ubuntu%E5%AE%89%E8%A3%85mysql%E6%9C%8D%E5%8A%A1%E4%BB%A5%E5%8F%8A%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%2F</url>
    <content type="text"><![CDATA[安装sudo apt-get update sudo apt-get install mysql-server 解决远程连接 tips本人使用环境ubuntu16 完成安装后，远程连接你会发现2003报错，此时，你对 /etc/mysql/mysql.conf.d/ 文件夹中打开 mysqld.cnf文件修改即可 修改内容将#bind-address = 127.0.0.1 原本没有注释，进行注释 然后你重新远程连接mysql直接变成1130的拒绝访问服务，接下来你要在服务器端登录mysql，执行 进入数据库 mysql -u root -p 切换数据库, mysql&gt;use mysql; 查看root账号的登录权限, mysql&gt;select host, user from user; 修改登录权限 mysql&gt;update user set host = ‘%’ where user = ‘root’; 刷新,生效,最后一步,至关重要 mysql&gt;flush privileges;]]></content>
  </entry>
  <entry>
    <title><![CDATA[SpringbootMQ]]></title>
    <url>%2F2019%2F03%2F13%2F2019-03-13-SpringbootMQ%2F</url>
    <content type="text"><![CDATA[what is MQ如果想知道MQ的详细知识可以看我之前的为什么使用消息队列MQ 这里选择最重要的提一下：MQ即消息队列，用来实现程序的异步和解耦，起到消息缓冲，消息分发。通俗来讲就是一个医院（服务器）里面有多个医生（线程或进程），让病人都排队（消息缓冲），有的去A部门，有的去B部门（消息分发）。 成员RabbitMQRabbitMQ是实现AMQP（高级消息队列协议Advanced Message Queuing Protocol）的消息中间件的一种，Feature就是组件之间解耦，病人排他的队，医生看他的病人，至于怎么排，医生不用操心，至于怎么看病，病人不用操心，都交给MQ 术语：面向消息，队列，路由（点对点/发布订阅），可靠安全]]></content>
      <categories>
        <category>high_availability</category>
      </categories>
      <tags>
        <tag>MQ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java问题排查工具]]></title>
    <url>%2F2019%2F03%2F13%2F2019-03-13-Java%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5%E5%B7%A5%E5%85%B7%2F</url>
    <content type="text"><![CDATA[一下文字摘自JAVA公众号 Linux命令类tail最常用的tail -f 1tail -300f shopbase.log #倒数300行并进入实时监听文件写入模式 grep12345678910grep forest f.txt #文件查找grep forest f.txt cpf.txt #多文件查找grep &#39;log&#39; &#x2F;home&#x2F;admin -r -n #目录下查找所有符合关键字的文件cat f.txt | grep -i shopbase grep &#39;shopbase&#39; &#x2F;home&#x2F;admin -r -n --include *.&#123;vm,java&#125; #指定文件后缀grep &#39;shopbase&#39; &#x2F;home&#x2F;admin -r -n --exclude *.&#123;vm,java&#125; #反匹配seq 10 | grep 5 -A 3 #上匹配seq 10 | grep 5 -B 3 #下匹配seq 10 | grep 5 -C 3 #上下匹配，平时用这个就妥了cat f.txt | grep -c &#39;SHOPBASE&#39; awk1 基础命令 123456awk &#39;&#123;print $4,$6&#125;&#39; f.txtawk &#39;&#123;print NR,$0&#125;&#39; f.txt cpf.txt awk &#39;&#123;print FNR,$0&#125;&#39; f.txt cpf.txtawk &#39;&#123;print FNR,FILENAME,$0&#125;&#39; f.txt cpf.txtawk &#39;&#123;print FILENAME,&quot;NR&#x3D;&quot;NR,&quot;FNR&#x3D;&quot;FNR,&quot;$&quot;NF&quot;&#x3D;&quot;$NF&#125;&#39; f.txt cpf.txtecho 1:2:3:4 | awk -F: &#39;&#123;print $1,$2,$3,$4&#125;&#39; 2 匹配 1234awk &#39;&#x2F;ldb&#x2F; &#123;print&#125;&#39; f.txt #匹配ldbawk &#39;!&#x2F;ldb&#x2F; &#123;print&#125;&#39; f.txt #不匹配ldbawk &#39;&#x2F;ldb&#x2F; &amp;&amp; &#x2F;LISTEN&#x2F; &#123;print&#125;&#39; f.txt #匹配ldb和LISTENawk &#39;$5 ~ &#x2F;ldb&#x2F; &#123;print&#125;&#39; f.txt #第五列匹配ldb 3 内建变量 NR:NR表示从awk开始执行后，按照记录分隔符读取的数据次数，默认的记录分隔符为换行符，因此默认的就是读取的数据行数，NR可以理解为Number of Record的缩写。 FNR:在awk处理多个输入文件的时候，在处理完第一个文件后，NR并不会从1开始，而是继续累加，因此就出现了FNR，每当处理一个新文件的时候，FNR就从1开始计数，FNR可以理解为File Number of Record。 NF: NF表示目前的记录被分割的字段的数目，NF可以理解为Number of Field。 find12345678910111213sudo -u admin find &#x2F;home&#x2F;admin &#x2F;tmp &#x2F;usr -name \*.log(多个目录去找)find . -iname \*.txt(大小写都匹配)find . -type d(当前目录下的所有子目录)find &#x2F;usr -type l(当前目录下所有的符号链接)find &#x2F;usr -type l -name &quot;z*&quot; -ls(符号链接的详细信息 eg:inode,目录)find &#x2F;home&#x2F;admin -size +250000k(超过250000k的文件，当然+改成-就是小于了)find &#x2F;home&#x2F;admin f -perm 777 -exec ls -l &#123;&#125; \; (按照权限查询文件)find &#x2F;home&#x2F;admin -atime -1 1天内访问过的文件find &#x2F;home&#x2F;admin -ctime -1 1天内状态改变过的文件 find &#x2F;home&#x2F;admin -mtime -1 1天内修改过的文件find &#x2F;home&#x2F;admin -amin -1 1分钟内访问过的文件find &#x2F;home&#x2F;admin -cmin -1 1分钟内状态改变过的文件 find &#x2F;home&#x2F;admin -mmin -1 1分钟内修改过的文件 pgm批量查询vm-shopbase满足条件的日志 1pgm -A -f vm-shopbase &#39;cat &#x2F;home&#x2F;admin&#x2F;shopbase&#x2F;logs&#x2F;shopbase.log.2017-01-17|grep 2069861630&#39; tsartsar是咱公司自己的采集工具。很好用, 将历史收集到的数据持久化在磁盘上，所以我们快速来查询历史的系统数据。当然实时的应用情况也是可以查询的啦。大部分机器上都有安装。 1tsar ##可以查看最近一天的各项指标 1tsar --live ##可以查看实时指标，默认五秒一刷 1tsar -d 20161218 ##指定查看某天的数据，貌似最多只能看四个月的数据 1234tsar --memtsar --loadtsar --cpu##当然这个也可以和-d参数配合来查询某天的单个指标的情况 toptop除了看一些基本信息之外，剩下的就是配合来查询vm的各种问题了 123ps -ef | grep javatop -H -p pid 获得线程10进制转16进制后jstack去抓看这个线程到底在干啥 其他12netstat -nat|awk &#39;&#123;print $6&#125;&#39;|sort|uniq -c|sort -rn #查看当前连接，注意close_wait偏高的情况，比如如下 排查利器btrace首当其冲的要说的是btrace。真是生产环境&amp;预发的排查问题大杀器。 简介什么的就不说了。直接上代码干 查看当前谁调用了ArrayList的add方法，同时只打印当前ArrayList的size大于500的线程调用栈 @OnMethod(clazz = “java.util.ArrayList”, method=”add”, location = @Location(value = Kind.CALL, clazz = “/./“, method = “/./“))public static void m(@ProbeClassName String probeClass, @ProbeMethodName String probeMethod, @TargetInstance Object instance, @TargetMethodOrField String method) { 1234567if(getInt(field(&quot;java.util.ArrayList&quot;, &quot;size&quot;), instance) &gt; 479)&#123; println(&quot;check who ArrayList.add method:&quot; + probeClass + &quot;#&quot; + probeMethod + &quot;, method:&quot; + method + &quot;, size:&quot; + getInt(field(&quot;java.util.ArrayList&quot;, &quot;size&quot;), instance)); jstack(); println(); println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;); println();&#125; } 监控当前服务方法被调用时返回的值以及请求的参数 @OnMethod(clazz = “com.taobao.sellerhome.transfer.biz.impl.C2CApplyerServiceImpl”, method=”nav”, location = @Location(value = Kind.RETURN))public static void mt(long userId, int current, int relation, String check, String redirectUrl, @Return AnyType result) { 1println(&quot;parameter# userId:&quot; + userId + &quot;, current:&quot; + current + &quot;, relation:&quot; + relation + &quot;, check:&quot; + check + &quot;, redirectUrl:&quot; + redirectUrl + &quot;, result:&quot; + result); } 其他功能集团的一些工具或多或少都有，就不说了。感兴趣的请移步。https://github.com/btraceio/btrace 注意: 经过观察，1.3.9的release输出不稳定，要多触发几次才能看到正确的结果 正则表达式匹配trace类时范围一定要控制，否则极有可能出现跑满CPU导致应用卡死的情况 由于是字节码注入的原理，想要应用恢复到正常情况，需要重启应用。 GreysGreys是@杜琨的大作吧。说几个挺棒的功能(部分功能和btrace重合): sc -df xxx: 输出当前类的详情,包括源码位置和classloader结构 trace class method: 相当喜欢这个功能! 很早前可以早JProfiler看到这个功能。打印出当前方法调用的耗时情况，细分到每个方法。对排查方法性能时很有帮助，比如我之前这篇就是使用了trace命令来的:http://www.atatech.org/articles/52947。 其他功能部分和btrace重合，可以选用，感兴趣的请移步。http://www.atatech.org/articles/26247 另外相关联的是arthas，他是基于Greys的，感兴趣的再移步http://mw.alibaba-inc.com/products/arthas/docs/middleware-container/arthas.wiki/home.html?spm=a1z9z.8109794.header.32.1lsoMc javOSize就说一个功能classes：通过修改了字节码，改变了类的内容，即时生效。 所以可以做到快速的在某个地方打个日志看看输出，缺点是对代码的侵入性太大。但是如果自己知道自己在干嘛，的确是不错的玩意儿。 其他功能Greys和btrace都能很轻易做的到，不说了。 可以看看我之前写的一篇javOSize的简介http://www.atatech.org/articles/38546官网请移步http://www.javosize.com/ JProfiler之前判断许多问题要通过JProfiler，但是现在Greys和btrace基本都能搞定了。再加上出问题的基本上都是生产环境(网络隔离)，所以基本不怎么使用了，但是还是要标记一下。官网请移步https://www.ej-technologies.com/products/jprofiler/overview.html 大杀器eclipseMAT可作为eclipse的插件，也可作为单独的程序打开。详情请移步http://www.eclipse.org/mat/ zprofiler集团内的开发应该是无人不知无人不晓了。简而言之一句话:有了zprofiler还要mat干嘛详情请移步zprofiler.alibaba-inc.com java三板斧，噢不对，是七把jps我只用一条命令： 1sudo -u admin &#x2F;opt&#x2F;taobao&#x2F;java&#x2F;bin&#x2F;jps -mlvV jstack普通用法: 1sudo -u admin &#x2F;opt&#x2F;taobao&#x2F;install&#x2F;ajdk-8_1_1_fp1-b52&#x2F;bin&#x2F;jstack 2815 native+java栈: 1sudo -u admin &#x2F;opt&#x2F;taobao&#x2F;install&#x2F;ajdk-8_1_1_fp1-b52&#x2F;bin&#x2F;jstack -m 2815 jinfo可看系统启动的参数，如下 1sudo -u admin &#x2F;opt&#x2F;taobao&#x2F;install&#x2F;ajdk-8_1_1_fp1-b52&#x2F;bin&#x2F;jinfo -flags 2815 jmap两个用途 1.查看堆的情况 1sudo -u admin &#x2F;opt&#x2F;taobao&#x2F;install&#x2F;ajdk-8_1_1_fp1-b52&#x2F;bin&#x2F;jmap -heap 2815 2.dump 1sudo -u admin &#x2F;opt&#x2F;taobao&#x2F;install&#x2F;ajdk-8_1_1_fp1-b52&#x2F;bin&#x2F;jmap -dump:live,format&#x3D;b,file&#x3D;&#x2F;tmp&#x2F;heap2.bin 2815 或者 1sudo -u admin &#x2F;opt&#x2F;taobao&#x2F;install&#x2F;ajdk-8_1_1_fp1-b52&#x2F;bin&#x2F;jmap -dump:format&#x3D;b,file&#x3D;&#x2F;tmp&#x2F;heap3.bin 2815 3.看看堆都被谁占了? 再配合zprofiler和btrace，排查问题简直是如虎添翼 1sudo -u admin &#x2F;opt&#x2F;taobao&#x2F;install&#x2F;ajdk-8_1_1_fp1-b52&#x2F;bin&#x2F;jmap -histo 2815 | head -10 jstatjstat参数众多，但是使用一个就够了 1sudo -u admin &#x2F;opt&#x2F;taobao&#x2F;install&#x2F;ajdk-8_1_1_fp1-b52&#x2F;bin&#x2F;jstat -gcutil 2815 1000 jdb时至今日，jdb也是经常使用的。jdb可以用来预发debug,假设你预发的java_home是/opt/taobao/java/，远程调试端口是8000.那么sudo -u admin /opt/taobao/java/bin/jdb -attach 8000. 出现以上代表jdb启动成功。后续可以进行设置断点进行调试。具体参数可见oracle官方说明http://docs.oracle.com/javase/7/docs/technotes/tools/windows/jdb.html CHLSDBCHLSDB感觉很多情况下可以看到更好玩的东西，不详细叙述了。 查询资料听说jstack和jmap等工具就是基于它的。 1sudo -u admin &#x2F;opt&#x2F;taobao&#x2F;java&#x2F;bin&#x2F;java -classpath &#x2F;opt&#x2F;taobao&#x2F;java&#x2F;lib&#x2F;sa-jdi.jar sun.jvm.hotspot.CLHSDB 更详细的可见R大此贴http://rednaxelafx.iteye.com/blog/1847971 plugin of intellij ideakey promoter快捷键一次你记不住，多来几次你总能记住了吧？ maven helper分析maven依赖的好帮手。 VM options 你的类到底是从哪个文件加载进来的？ 123-XX:+TraceClassLoading结果形如[Loaded java.lang.invoke.MethodHandleImpl$Lazy from D:\programme\jdk\jdk8U74\jre\lib\rt.jar] 应用挂了输出dump文件 12-XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath&#x3D;&#x2F;home&#x2F;admin&#x2F;logs&#x2F;java.hprof集团的vm参数里边基本都有这个选项 jar包冲突把这个单独写个大标题不过分吧？每个人或多或少都处理过这种烦人的case。我特么下边这么多方案不信就搞不定你? mvn dependency:tree &gt; ~/dependency.txt打出所有依赖 mvn dependency:tree -Dverbose -Dincludes=groupId:artifactId只打出指定groupId和artifactId的依赖关系 -XX:+TraceClassLoadingvm启动脚本加入。在tomcat启动脚本中可见加载类的详细信息 -verbosevm启动脚本加入。在tomcat启动脚本中可见加载类的详细信息 greys:scgreys的sc命令也能清晰的看到当前类是从哪里加载过来的 tomcat-classloader-locate通过以下url可以获知当前类是从哪里加载的curl http://localhost:8006/classloader/locate?class=org.apache.xerces.xs.XSObject ALI-TOMCAT带给我们的惊喜(感谢@务观) 列出容器加载的jar列表 curl http://localhost:8006/classloader/jars 列出当前当当前类加载的实际jar包位置，解决类冲突时有用 curl http://localhost:8006/classloader/locate?class=org.apache.xerces.xs.XSObject 其他gprefhttp://www.atatech.org/articles/33317 dmesg如果发现自己的java进程悄无声息的消失了，几乎没有留下任何线索，那么dmesg一发，很有可能有你想要的。 1sudo dmesg|grep -i kill|less 去找关键字oom_killer。找到的结果类似如下: 12345[6710782.021013] java invoked oom-killer: gfp_mask&#x3D;0xd0, order&#x3D;0, oom_adj&#x3D;0, oom_scoe_adj&#x3D;0[6710782.070639] [&lt;ffffffff81118898&gt;] ? oom_kill_process+0x68&#x2F;0x140 [6710782.257588] Task in &#x2F;LXC011175068174 killed as a result of limit of &#x2F;LXC011175068174 [6710784.698347] Memory cgroup out of memory: Kill process 215701 (java) score 854 or sacrifice child [6710784.707978] Killed process 215701, UID 679, (java) total-vm:11017300kB, anon-rss:7152432kB, file-rss:1232kB 以上表明，对应的java进程被系统的OOM Killer给干掉了，得分为854.解释一下OOM killer（Out-Of-Memory killer），该机制会监控机器的内存资源消耗。当机器内存耗尽前，该机制会扫描所有的进程（按照一定规则计算，内存占用，时间等），挑选出得分最高的进程，然后杀死，从而保护机器。 dmesg日志时间转换公式:log实际时间=格林威治1970-01-01+(当前时间秒数-系统启动至今的秒数+dmesg打印的log时间)秒数： 1date -d &quot;1970-01-01 UTC &#96;echo &quot;$(date +%s)-$(cat &#x2F;proc&#x2F;uptime|cut -f 1 -d&#39; &#39;)+12288812.926194&quot;|bc &#96; seconds&quot; 剩下的，就是看看为什么内存这么大，触发了OOM-Killer了。 新技能getRateLimiter想要精细的控制QPS? 比如这样一个场景，你调用某个接口，对方明确需要你限制你的QPS在400之内你怎么控制？这个时候RateLimiter就有了用武之地。详情可移步http://ifeve.com/guava-ratelimite]]></content>
  </entry>
  <entry>
    <title><![CDATA[JumpGame]]></title>
    <url>%2F2019%2F03%2F13%2F2019-03-13-JumpGame%2F</url>
    <content type="text"><![CDATA[problem Given an array of non-negative integers, you are initially positioned at the first index of the array. Each element in the array represents your maximum jump length at that position. Determine if you are able to reach the last index. Example 1: 123Input: [2,3,1,1,4]Output: trueExplanation: Jump 1 step from index 0 to 1, then 3 steps to the last index. Example 2: 1234Input: [3,2,1,0,4]Output: falseExplanation: You will always arrive at index 3 no matter what. Its maximum jump length is 0, which makes it impossible to reach the last index. key本题有两个易理解错的地方 达到最后一个index或者超过最后一个index是可以的 【2,5,0,0】第一个2可以跳两步，然后我们在5的基础上跳五步 本题采用贪心算法，算出局部最优解就可以了，当然也可以考虑dp，但本题没有这个必要 solution123456public boolean canJump(int[] nums) &#123; int reach = nums[0]; for(int i = 1; i &lt; nums.length &amp;&amp; reach &gt;= i; i++) if(i + nums[i] &gt; reach) reach = i + nums[i]; return reach &gt;= (nums.length-1) ? true : false; &#125; perfect1I&#39;m the perfect]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Medium</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpiralMatrix]]></title>
    <url>%2F2019%2F03%2F12%2F2019-03-12-SpiralMatrix%2F</url>
    <content type="text"><![CDATA[54.problem Given a matrix of m x n elements (m rows, n columns), return all elements of the matrix in spiral order. Example 1: 1234567Input:[ [ 1, 2, 3 ], [ 4, 5, 6 ], [ 7, 8, 9 ]]Output: [1,2,3,6,9,8,7,4,5] Example 2: 1234567Input:[ [1, 2, 3, 4], [5, 6, 7, 8], [9,10,11,12]]Output: [1,2,3,4,8,12,11,10,9,5,6,7] key很简单的循环输出的例子，从【0,0】的位置顺时针扫一圈，然后缩小一圈，继续扫描，不过有一个细节就是第三次第四循环前，要判断一下,防止最后一层循环只有一行 solution123456789101112131415161718192021222324252627282930public List&lt;Integer&gt; spiralOrder(int[][] matrix) &#123; List&lt;Integer&gt; ans = new ArrayList&lt;Integer&gt;(); if (matrix.length == 0) return ans; int rs = 0, re = matrix.length - 1;// rowStart rowEnd int cs = 0, ce = matrix[0].length - 1;// columnStart columnEnd while (rs &lt;= re &amp;&amp; cs &lt;= ce) &#123; for (int i = cs; i &lt;= ce; i++) &#123; ans.add(matrix[rs][i]); &#125; for(int j=rs+1;j&lt;=re;j++) &#123; ans.add(matrix[j][ce]); &#125; if(rs&lt;re&amp;&amp;cs&lt;ce) &#123; for(int k=ce-1;k&gt;cs;k--) &#123; ans.add(matrix[re][k]); &#125; for(int l=re;l&gt;rs;l--) &#123; ans.add(matrix[l][cs]); &#125; &#125; rs++; re--; cs++; ce--; &#125; return ans; &#125; perfect1yehh,I&#39;m the perfect]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Medium</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何设置hexo的favico]]></title>
    <url>%2F2019%2F03%2F12%2F2019-03-12-%E5%A6%82%E4%BD%95%E8%AE%BE%E7%BD%AEhexo%E7%9A%84favico%2F</url>
    <content type="text"><![CDATA[solutionsource 下放置32*32的favico.icon文件并在根目录的_config.yml中设置 favicon: /favicon.ico]]></content>
      <categories>
        <category>others</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[如何将域名绑定到hexo]]></title>
    <url>%2F2019%2F03%2F12%2F2019-03-12-%E5%A6%82%E4%BD%95%E5%B0%86%E5%9F%9F%E5%90%8D%E7%BB%91%E5%AE%9A%E5%88%B0hexo%2F</url>
    <content type="text"><![CDATA[problem很多人可能都有hexo博客，会有一个githubname.github.io的地址，然后自己可能想去买一个域名，方便记忆，但是解析后迟迟用不了，该文章就来详细描述一下步骤。 solution1.拥有一个githubname.github.io可以正常访问的域名，如我的GitHub博客：https://shawngoethe.github.io 2.购买域名，个人推荐阿里云，首年年费比较便宜，适合个人折腾，博客建议com,me,info,pro（专家）,mobi(kindle电子书的格式)，再不济可以选择tech，cc之类的，国外可以参考Linost之类的网页 3.购买域名进行实名认证，否则无法使用 4.进行解析：记录类型CNAME（进行转发），主机记录@（避免主机记录选择www，输入域名要多写www），记录值为shawngoethe.github.io,TTL选择10分钟就可以了 上述方法属于将我购买的zehai.info转发到了shawngoethe.github.io,还可以“记录类型”选择“A”来填写IPv4的地址，地址可以通过ping shawngoethe.github.io 来获得 5.修改代码：很多人忽视了要在源代码/hexoblog/source/目录下添加CNAME文件（注意没有尾缀），然后在该文件下填写zehai.info（可以兼容，www.zehai.info 和 zehai.info 两种访问方式，但如果填写 www.zehai.info 则只支持 www.zehai.info 一种访问方式） 6.等十分钟左右，让解析生效，好了，你可以访问我的hexo获取更多内容]]></content>
      <categories>
        <category>others</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[MaximumSubarray]]></title>
    <url>%2F2019%2F03%2F10%2F2019-03-10-MaximumSubarray%2F</url>
    <content type="text"><![CDATA[problem Maximum Subarray Easy Given an integer array nums, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum. Example: 123Input: [-2,1,-3,4,-1,2,1,-5,4],Output: 6Explanation: [4,-1,2,1] has the largest sum &#x3D; 6. Follow up: If you have figured out the O(n) solution, try coding another solution using the divide and conquer approach, which is more subtle. key我们定义一个和为第一位数，然后用curSum来保存递增量 ps ans–&gt;answer cur–&gt;cursor solution12345678910111213class Solution &#123; public int maxSubArray(int[] nums) &#123; int ans=nums[0], curSum=0; for (int i=0; i&lt;nums.length; i++) &#123; curSum = curSum + nums[i]; ans = Math.max(ans, curSum); curSum = Math.max(0, curSum); &#125; return ans; &#125;&#125; perfect12345678910class Solution &#123; public int maxSubArray(int[] nums) &#123; int dp = nums[0], maxSum=nums[0]; for (int i=1; i&lt;nums.length; i++) &#123; dp = dp&lt;0?nums[i]:nums[i]+dp; maxSum=Math.max(maxSum, dp); &#125; return maxSum; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[pow(x,n)]]></title>
    <url>%2F2019%2F03%2F10%2F2019-03-10-pow-x-n%2F</url>
    <content type="text"><![CDATA[problem \50. Pow(x, n) Medium Implement pow(x, n), which calculates x raised to the power n (xn). Example 1: 12Input: 2.00000, 10Output: 1024.00000 Example 2: 12Input: 2.10000, 3Output: 9.26100 Example 3: 123Input: 2.00000, -2Output: 0.25000Explanation: 2-2 &#x3D; 1&#x2F;22 &#x3D; 1&#x2F;4 &#x3D; 0.25 Note: -100.0 &lt; x &lt; 100.0 n is a 32-bit signed integer, within the range [−231, 231 − 1] solution12345678910111213141516171819202122public double myPow(double x, int n) &#123; long N = n; if (N &lt; 0) &#123; x = 1 / x; N = -N; &#125; double ans = 1; double cur = x;//2 for (long i = N; i &gt; 0; i /= 2) &#123; if (i % 2 == 1) ans = ans * cur; cur = cur * cur; &#125; return ans; &#125;//偷懒方法public double myPow(double x, int n) &#123; return Math.pow(x, n); &#125; key其实先使用了偷懒的方法，调用Math库的pow方法，然后写过一版 123for(long i=N;i&gt;0;i--) &#123; ans=ans*cur;&#125; 这个会直接报超时的错误，因为的计算量会非常大，在计算（-1.00000，-2147483648）时候超时了，虽然我们可以通过判断x来避免这一个超时，但是我想到了，可以通过n/2来迅速减少相乘的次数。时间大概是8ms perfect1234567891011121314151617181920212223242526272829class Solution &#123; public double findPower(double x,long n)&#123; if(n == Long.valueOf(1)) return x; if(n % 2 == 0)&#123; double half_pow = findPower(x,n/2); return half_pow * half_pow; &#125;else&#123; double half_pow = findPower(x,(n-1)/2); return half_pow * half_pow * x; &#125; &#125; public double myPow(double x, int n) &#123; if( n==0 ) return 1; long n_long = (long) n; if( n &gt; 0 ) return findPower(x,n); x = 1 / x; long n_long_abs = (long) Math.abs((long)n); if(n_long_abs == 1) return x; return findPower(x,n_long_abs); &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[我在一个不属于我的地方游荡]]></title>
    <url>%2F2019%2F03%2F06%2F2019-03-06-%E6%88%91%E5%9C%A8%E4%B8%80%E4%B8%AA%E4%B8%8D%E5%B1%9E%E4%BA%8E%E6%88%91%E7%9A%84%E5%9C%B0%E6%96%B9%E6%B8%B8%E8%8D%A1%2F</url>
    <content type="text"><![CDATA[我在一个不属于我的地方游荡2019年的3月6日，距离我上一份工作离职，已经37天，日子过得虽然不好，但也不算差，好消息是阿len还陪着我，坏消息是一直过着异地恋的生活，不知道是为什么，是我进入了焦虑的状态，每天的日常就是投简历，思考人生，发呆，看up主秀恩爱 其实回顾前三次的找工作经历，哪次不是觉得自己快要变成咸鱼了，然后收到了一两个offer，不过今年的不同点就是，有三家，我已经过了用人单位的面试，却被卡在了人力资源部门的审核上，我时常恨自己的学历，却无法去原谅曾经高考的自己，写这篇文章的时候，我刚刚从清华的北门进入校园，下午两点半的宿舍区，没有一点噪音，天空的乌鸦鸣叫在空旷的校园回荡，仿佛，在感叹今日的好天气，阳光那么明亮，洒在光秃秃的树枝上。 17年考研复习期间埋下来的雷，最终还是爆炸了，18年，19年，20年，似乎时间过得很快，我丢失了那一次机会后，我似乎再也没有机会去投入身心去复习，每天的大脑里更多的是，好累啊，好烦啊，什么时候发工资啊。越生是怀念起无忧无虑的本科生活，天天不用担心我是谁，我在哪儿，学什么，可能唯一需要费点脑经的就是，中午吃啥 而现在，我走在一个不属于我的世界里，熟悉又陌生，我什么都不知道，因为我不知道我要干嘛，前方一个是找不到工作的工作方向，一个是会饿死的考研方向，世界很精彩，我却显得那么渺小，就深深想起来用人部门发信息和我说： 从技术层面上，我认为从工作年限上，你的水平是够的。对于候选人的学历背景上，央企有自身的痼疾，用人部门的话语权不一定大于人力部门，这个你也无须介怀。 工作的前三年对于一个工程师来说是至关重要的，如果喜欢这条路，就多花点时间，加油！江湖不大，有缘再见！ 不知道接下来应该做什么，或许这就是应试教育的悲哀，我也只能许愿，三月份能够拿到一个不错的offer，先活下来，我是子苏，一个快要得抑郁症的人。]]></content>
      <categories>
        <category>mood</category>
      </categories>
      <tags>
        <tag>diary</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[docker+springboot]]></title>
    <url>%2F2019%2F03%2F05%2F2019-03-05-docker-springboot%2F</url>
    <content type="text"><![CDATA[what在 pom.xml-properties中添加 Docker 镜像名称 123&lt;properties&gt; &lt;docker.image.prefix&gt;springboot&lt;&#x2F;docker.image.prefix&gt;&lt;&#x2F;properties&gt; plugins 中添加 Docker 构建插件： 1234567891011121314151617181920212223242526&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;&#x2F;artifactId&gt; &lt;&#x2F;plugin&gt; &lt;!-- Docker maven plugin --&gt; &lt;plugin&gt; &lt;groupId&gt;com.spotify&lt;&#x2F;groupId&gt; &lt;artifactId&gt;docker-maven-plugin&lt;&#x2F;artifactId&gt; &lt;version&gt;1.0.0&lt;&#x2F;version&gt; &lt;configuration&gt; &lt;imageName&gt;$&#123;docker.image.prefix&#125;&#x2F;$&#123;project.artifactId&#125;&lt;&#x2F;imageName&gt; &lt;dockerDirectory&gt;src&#x2F;main&#x2F;docker&lt;&#x2F;dockerDirectory&gt; &lt;resources&gt; &lt;resource&gt; &lt;targetPath&gt;&#x2F;&lt;&#x2F;targetPath&gt; &lt;directory&gt;$&#123;project.build.directory&#125;&lt;&#x2F;directory&gt; &lt;include&gt;$&#123;project.build.finalName&#125;.jar&lt;&#x2F;include&gt; &lt;&#x2F;resource&gt; &lt;&#x2F;resources&gt; &lt;&#x2F;configuration&gt; &lt;&#x2F;plugin&gt; &lt;!-- Docker maven plugin --&gt; &lt;&#x2F;plugins&gt;&lt;&#x2F;build&gt; 在目录src/main/docker下创建 Dockerfile 文件，Dockerfile 文件用来说明如何来构建镜像。 1234FROM openjdk:8-jdk-alpineVOLUME &#x2F;tmpADD spring-boot-docker-1.0.jar app.jarENTRYPOINT [&quot;java&quot;,&quot;-Djava.security.egd&#x3D;file:&#x2F;dev&#x2F;.&#x2F;urandom&quot;,&quot;-jar&quot;,&quot;&#x2F;app.jar&quot;] 这个 Dockerfile 文件很简单，构建 Jdk 基础环境，添加 Spring Boot Jar 到镜像中，简单解释一下: FROM ，表示使用 Jdk8 环境 为基础镜像，如果镜像不是本地的会从 DockerHub 进行下载 VOLUME ，VOLUME 指向了一个/tmp的目录，由于 Spring Boot 使用内置的Tomcat容器，Tomcat 默认使用/tmp作为工作目录。这个命令的效果是：在宿主机的/var/lib/docker目录下创建一个临时文件并把它链接到容器中的/tmp目录 ADD ，拷贝文件并且重命名 ENTRYPOINT ，为了缩短 Tomcat 的启动时间，添加java.security.egd的系统属性指向/dev/urandom作为 ENTRYPOINT 这样 Spring Boot 项目添加 Docker 依赖就完成了。]]></content>
      <categories>
        <category>docker</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[dockerfile]]></title>
    <url>%2F2019%2F03%2F04%2F2019-03-04-dockerfile%2F</url>
    <content type="text"><![CDATA[what通过dockerfile写入程序、库、资源、配置参数等，来生成image文件，可以类比node的package.json或者nginx.conf的文件 format1234567891011121314151617181920## Dockerfile文件格式# This dockerfile uses the ubuntu image# VERSION 2 - EDITION 1# Author: docker_user# Command format: Instruction [arguments / command] .. # 1、第一行必须指定 基础镜像信息FROM ubuntu # 2、维护者信息MAINTAINER docker_user docker_user@email.com # 3、镜像操作指令RUN echo &quot;deb http://archive.ubuntu.com/ubuntu/ raring main universe&quot; &gt;&gt; /etc/apt/sources.listRUN apt-get update &amp;&amp; apt-get install -y nginxRUN echo &quot;\ndaemon off;&quot; &gt;&gt; /etc/nginx/nginx.conf # 4、容器启动执行指令CMD /usr/sbin/nginx build image1docker build 运行该命令时，根据dockerfile文件及上下文构建新的docker镜像，其中上下文是指dockerfile所在的本地路径或者网络路径url。 ps:dokcer build时候，会在后台守护进程daemon中进行，而不是cli（common line interface）中，构建前，构建进程将全部内容递归放到守护进程，将dockerfile文件放在（本就在空目录下构建）该目录下 还可以通过.dockerignore的文件来忽略上下文目录中的部分文件和目录，同.gitignore 通过-f命令指定文件位置，如： 1docker buid -f /path/to/dockerfile . image tag镜像标签docker build -t ngix/v3 cacheDocker 守护进程会一条一条的执行 Dockerfile 中的指令，而且会在每一步提交并生成一个新镜像，最后会输出最终镜像的ID。生成完成后，Docker 守护进程会自动清理你发送的上下文。 Dockerfile文件中的每条指令会被独立执行，并会创建一个新镜像，RUN cd /tmp等命令不会对下条指令产生影响。 Docker 会重用已生成的中间镜像，以加速docker build的构建速度。 example12345678910111213141516171819mkdir mynginxcd mynginxvi Dockerfile//制作dokcerfileFROM nginxRUN echo &#x27;&lt;h1&gt;Hello, Docker!&lt;/h1&gt;&#x27; &gt; /usr/share/nginx/html/index.html//save &amp;&amp; run this code in mynginxdocker build -t nginx:v1 .//v1 后面有一个空格和一个点//点代表当前目录//查看imagedokcer images//rundokcer run --name docker_nginx_v1 -d -p 80:80 nginx:v1//docker_nginx_v1为容器名//nginx:v1为image名]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NoSql-introduction]]></title>
    <url>%2F2019%2F03%2F04%2F2019-03-04-NoSql-introduction%2F</url>
    <content type="text"><![CDATA[why nosqlNoSql可以处理结构化，非结构化的数据，可以水平伸缩，在实时和批量数据分析中具有优势 difference]]></content>
      <categories>
        <category>database</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[docker]]></title>
    <url>%2F2019%2F03%2F04%2F2019-03-04-docker%2F</url>
    <content type="text"><![CDATA[why docker 解决“在我的机子上可以正常工作”的问题 运维更好地管理服务 更好地迁移和拓展（任意平台运行） what is dockerdocker属于Linux容器的一种封装，和VM类似，但他不像VM一样虚拟在操作系统之上，而是和操作系统平级，程序运行在容器里，就和在真实的物理机上面运行一样 简单一点理解就是：程序运行在docker上和真机上几乎误差，将程序包装起来管理 名词解释 daemon：守护进程 Client：命令行 image：镜像，用来创建容器 container：运行组件，启动的image就是容器 registry：管理image的地方 install #ubuntu $ sudo apt-get install docker-ce docker-ce-cli containerd.io HelloWorld 123sudo docker container run hello-world//他会先找本地，然后再去仓库下载//该过程将image变成容器，即image文件产生container文件 常用命令 docker pull image_name//拉取镜像 docker images//本地镜像 docker rmi xxx//remove image docker ps//view what docker is running docker ps -a //以下使用cn代替 container_name/container_id docker start|stop|restart cn docker attach cn//启动后进入容器 dokcer rm cn docker info docker search nginx]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LineageOS16.0-RELEASE]]></title>
    <url>%2F2019%2F03%2F02%2F2019-03-02-LineageOS16-0-RELEASE%2F</url>
    <content type="text"><![CDATA[16.0正式发布我们从去年八月开始，努力将我们LineageOs的新特性移植到新版本的安卓上，非常感谢之前版本中的工作者们，我们才能够在这次的版本新特性中投入更多的精力，尤其是，隐私守护（Privacy Guard）和插件（su addon）上收到了了大量的提升建议。通过对Styles API的一些细微更改，他现在可以兼容安卓暗黑模式的默认实现，在未来，越来越多的三方应用将遵循系统风格，这意味着Styles API将允许在跨应用程序时获得更一致的体验。正如我们发布夏季第二次调研结果那样，我们将介绍Trust的新特性，首先是设备锁定时阻止新USB设备连接。请注意，由于基于底层，所以这个特性必须在每个设备底层中启用。Trebuchet现在还可以隐藏app以及在打开app前进行身份验证。该限制也仅在Trebuchet中，并非系统范围。我们认为16.0的分支已经达到了15.1版本的特性测试并做好了发布准备。随着16.0分支成为最新最活跃的分支，在2019.3.1，它将开始日更新构建，并且15.1将会移动到周更新。16.0版本将会从小部分机器开始运行，一些其他的机子如果准备好了，我们也会做一些小改动，开始构建，并通过改动构建脚本来更好地处理我们最新手机的，独特feature，以及由此产生的复杂问题 支持更新名单 Asus BQ Fairphone Google HTC Huawei LeEco Lenovo LG Moto Nextbit Nubia Nvdia OnePlus(my oneplus 5T receive 16.0) Oppo Samsung Sony Wileyfox Wingtech Xiaomi YU ZTE Zuk more 其他热门的ROM MoKee] crDroid MIUI Flyme PixelExperience 原文 Hello LineageOS 16.0We’ve been working hard since August to port our unique features to this new version of Android. Thanks to the major cleanup and refactoring done in the previous version, we were able to focus more on features and reliability this time; in particular, both Privacy Guard and the su addon received a sizeable amount of improvements. With some minor changes made to the Styles API, it is now compatible with what will eventually become the default implementation of dark mode in Android. In the future, more and more third party apps will follow the system style, meaning our Styles API will allow you to have a more coherent experience across apps. As we announced when the Summer Survey 2 results were posted, we will be introducing new features to Trust, beginning with the ability to block new USB device connections when device is locked. Please note that this feature has to be enabled on a per-device basis due to the layer at which this was implemented. Trebuchet is also now able to hide apps and require authentication before opening them. Please note that this restriction is limited to Trebuchet and is not system-wide. We feel that the 16.0 branch has reached feature parity with 15.1 and is ready for initial release. With 16.0 being the most recent and most actively-developed branch, on March 1st, 2019 it will begin receiving builds nightly and 15.1 will be moved to weekly builds. LineageOS 16.0 will be launching with a small selection of devices. Additional devices will begin receiving builds as they are ready and after we make minor change to our build scripts to better handle the unique features, and resulting complications, of the most modern devices. Upgrading to LineageOS 16.0 (Optional) Make a backup of your important data Download the build either from download portal or built in Updater app You can export the downloaded package from the Updater app to the sdcard by long-pressing it and then selecting “Export” in the popup menu Download proper addons packages (GApps, su…) for Android 9.0/Lineage OS 16.0 Make sure your recovery and firmware are up to date Format your system partition Follow the “Installing LineageOS from recovery” section on your device’s installation page Please note that if you’re currently on an official build, you DO NOT need to wipe your device. If you are installing from an unofficial build, you MUST wipe data from recovery before installing.]]></content>
      <categories>
        <category>phones</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[java类的加载机制]]></title>
    <url>%2F2019%2F03%2F02%2F2019-03-02-java%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[写在最前面：该文章为笔记，来自纯洁的微笑 what is the loading of class类加载即： 将编译class文件中的二进制数据读到内存中方法区，然后在堆区通过java.lang.Class实例化对象，对方法区的数据进行操作 该加载过程包含首次使用加载，以及预加载 加载class文件的方式 本地 网络 zip，jar文件中 数据库 动态编译 类的生命周期]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[ShoppingOffers]]></title>
    <url>%2F2019%2F03%2F02%2F2019-03-02-ShoppingOffers%2F</url>
    <content type="text"><![CDATA[problem In LeetCode Store, there are some kinds of items to sell. Each item has a price. However, there are some special offers, and a special offer consists of one or more different kinds of items with a sale price. You are given the each item’s price, a set of special offers, and the number we need to buy for each item. The job is to output the lowest price you have to pay for exactly certain items as given, where you could make optimal use of the special offers. Each special offer is represented in the form of an array, the last number represents the price you need to pay for this special offer, other numbers represents how many specific items you could get if you buy this offer. You could use any of special offers as many times as you want. examples Example 1: 1234567Input: [2,5], [[3,0,5],[1,2,10]], [3,2]Output: 14Explanation: There are two kinds of items, A and B. Their prices are $2 and $5 respectively. In special offer 1, you can pay $5 for 3A and 0BIn special offer 2, you can pay $10 for 1A and 2B. You need to buy 3A and 2B, so you may pay $10 for 1A and 2B (special offer #2), and $4 for 2A. Example 2: 1234567Input: [2,3,4], [[1,1,0,4],[2,2,1,9]], [1,2,1]Output: 11Explanation: The price of A is $2, and $3 for B, $4 for C. You may pay $4 for 1A and 1B, and $9 for 2A ,2B and 1C. You need to buy 1A ,2B and 1C, so you may pay $4 for 1A and 1B (special offer #1), and $3 for 1B, $4 for 1C. You cannot add more items, though only $9 for 2A ,2B and 1C. solution123456789101112131415161718192021222324252627282930313233343536373839404142434445import java.util.ArrayList;import java.util.Arrays;import java.util.List;public class ShoppingOffers &#123; public static void main(String[] args) &#123; /*以下贴出测试方式，因为对ArrayList不熟悉，如有更好的方式，欢迎指出*/ List&lt;Integer&gt; price = new ArrayList&lt;Integer&gt;(); List&lt;List&lt;Integer&gt;&gt; special = new ArrayList&lt;List&lt;Integer&gt;&gt;(); List&lt;Integer&gt; needs = new ArrayList&lt;Integer&gt;(); price.add(0, 2);price.add(1, 5); Integer[][] arr = new Integer[][] &#123;&#123;3,0,5&#125;,&#123;1,2,10&#125;&#125;; special.add((List&lt;Integer&gt;)Arrays.asList(arr[0])); special.add((List&lt;Integer&gt;)Arrays.asList(arr[1])); needs.add(0,3);needs.add(1,2); ShoppingOffers so = new ShoppingOffers(); int res = so.shoppingOffers(price, special, needs); System.out.println(res); &#125; public int shoppingOffers(List &lt; Integer &gt; price, List &lt; List &lt; Integer &gt;&gt; special, List &lt; Integer &gt; needs) &#123; return shopping(price, special, needs); &#125; public int shopping(List &lt; Integer &gt; price, List &lt; List &lt; Integer &gt;&gt; special, List &lt; Integer &gt; needs) &#123; int j = 0, res = dot(needs, price); for (List &lt; Integer &gt; s: special) &#123; ArrayList &lt; Integer &gt; clone = new ArrayList &lt; &gt; (needs); for (j = 0; j &lt; needs.size(); j++) &#123; int diff = clone.get(j) - s.get(j); if (diff &lt; 0) break; clone.set(j, diff); &#125; if (j == needs.size()) res = Math.min(res, s.get(j) + shopping(price, special, clone)); &#125; return res; &#125; public int dot(List &lt; Integer &gt; needs, List &lt; Integer &gt; price) &#123; int sum = 0; for (int i = 0; i &lt; needs.size(); i++) &#123; sum += needs.get(i) * price.get(i); &#125; return sum; &#125;&#125; key本题目采用动态规划的思路，我们带入测试样例1的 1234&gt;Input: [2,5], [[3,0,5],[1,2,10]], [3,2]&gt;即A&#x3D;$2,B&#x3D;$5&gt;3A&#x3D;5$,1A+2B&#x3D;10$&gt;需购买3A+2B 尝试 price 1:单买 16 2单买302套餐，还差2个B，则先算出2B的res为10，先试305套餐，A买超了，则退出305套餐，此时还有1210套餐，A买多了，退出套餐，两个套餐试完了，得到了单买两个B，$10的套餐，总价就为15元， 15（覆盖16） 3单买1210套餐，还差2A，0B，费用目前10元，先单买2A，费用4元，总价14元，然后先尝试305套餐，发现超，然后再试1210套餐，发现B超了，得到目前最低费用为14元 14（覆盖15） 问题的关键就在于clone的精髓之处，用来记录还需要多少零件的个数，使用递归，进行操作。如果不符合，（如买超了）直接break后，重新计算clone，直到special方法都试完了，然后才返回，如果一直都是break的状态则会返回单买的价格。 perfect123456789101112131415161718192021222324252627282930313233343536373839404142class Solution &#123; private Integer res; public int shoppingOffers(List&lt;Integer&gt; price, List&lt;List&lt;Integer&gt;&gt; special, List&lt;Integer&gt; needs) &#123; res=Integer.MAX_VALUE; int[] parr=new int[price.size()]; int[] aarr=new int[needs.size()]; for(int i=0;i&lt;parr.length; i++)&#123; parr[i]=price.get(i); aarr[i]=needs.get(i); &#125; findMinimum(special, 0, aarr, parr, 0); return res; &#125; private void findMinimum(List&lt;List&lt;Integer&gt;&gt; special, int curOffer, int[] remain, int[] single, int total)&#123; if(total&gt;=res||curOffer==special.size()) return; int buyNow=buySingle(remain, single, total); if(buyNow&lt;res) res=buyNow; int[] newRemain=remainAfterUse(special.get(curOffer), remain); if(newRemain!=null) findMinimum(special, curOffer, newRemain, single, total+special.get(curOffer).get(remain.length)); findMinimum(special, curOffer+1, remain, single, total); &#125; private int[] remainAfterUse(List&lt;Integer&gt; special, int[] remain)&#123; int[] res=new int[remain.length]; for(int i=0;i&lt;remain.length;i++)&#123; res[i]=remain[i]-special.get(i); if(res[i]&lt;0) return null; &#125; return res; &#125; private int buySingle(int[] remain, int[] single, int total)&#123; for(int i=0; i&lt;remain.length; i++)&#123; total+=remain[i]*single[i]; &#125; return total; &#125; &#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Node10值得关注的升级]]></title>
    <url>%2F2019%2F02%2F23%2F2019-02-23-Node10%E5%80%BC%E5%BE%97%E5%85%B3%E6%B3%A8%E7%9A%84%E5%8D%87%E7%BA%A7%2F</url>
    <content type="text"><![CDATA[http2优势 更有效的网络利用率 引入 HTTP Header 压缩减小报文体积 在同一个连接中支持多路并发 支持 Server Push 多路复用（Multiplexing）由于HTTP连接，起初有要求限制同一域名下的请求有数量限制，超过则被阻塞，而HTTP2可以发起多重请求，如同时请求样式文件和脚本文件 二进制分帧 HTTP/2 通过让所有数据流共用同一个连接，可以更有效地使用 TCP 连接，让高带宽也能真正的服务于 HTTP 的性能提升。 http2.0的格式定义更接近tcp层的方式，这张二机制的方式十分高效且精简。length定义了整个frame的开始到结束，type定义frame的类型（一共10种），flags用bit位定义一些重要的参数，stream id用作流控制，剩下的payload就是request的正文了。 server Pushhttp2.0能通过push的方式将客户端需要的内容预先推送过去 首部压缩（Header Compression) BigInt *fs.mkdir 和 fs.mkdirSync 支持递归参数 CLI Flag 自动补全 Windows 安装包优化]]></content>
  </entry>
  <entry>
    <title><![CDATA[Egg支持JS智能提醒]]></title>
    <url>%2F2019%2F02%2F23%2F2019-02-23-Egg%E6%94%AF%E6%8C%81JSTS%E6%99%BA%E8%83%BD%E6%8F%90%E9%86%92%2F</url>
    <content type="text"><![CDATA[本文章思路来自https://zhuanlan.zhihu.com/p/56780733 定位其实由于Egg本身的动态加载机制，所以JavaScript很难去做智能提醒（如变量定义检查），本次借鉴TS的动态生成d.ts，使用ts的Declaration Merging（声明合并）特性，读取JSDoc注释。 获取 更新egg-bin模块 package.json 添加 “egg”: { “declarations”: true } 实操，升级个人GitHub项目chum,执行 npm i egg-bin 将其从4.9.0–&gt;4.11.0并在package.json的尾部加上上述egg的kv，在根目录下生成tpyping文件夹，将app目录下的controller，model，以及根目录下的index，config目录都进行了ts文件生成 其实egg原生支持JavaScript，对于TS只是支持不推荐的态度，并没有使用TS去重构，本次智能提醒，应该是对JS一个劣势的补齐，解决方案也似乎借鉴了TS的方式，但又保留了人们书写JS的习惯]]></content>
      <categories>
        <category>framework</category>
      </categories>
      <tags>
        <tag>egg</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ThreeSum]]></title>
    <url>%2F2019%2F02%2F19%2F2019-02-19-15ThreeSum%2F</url>
    <content type="text"><![CDATA[Problem123456789101112131415Given an array nums of n integers, are there elements a, b, c in nums such that a + b + c &#x3D; 0? Find all unique triplets in the array which gives the sum of zero.Note:The solution set must not contain duplicate triplets.Example:Given array nums &#x3D; [-1, 0, 1, 2, -1, -4],A solution set is:[ [-1, 0, 1], [-1, -1, 2]] Solution123456789101112131415161718192021222324252627282930313233343536373839public class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) &#123; Arrays.sort(nums); ArrayList&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;List&lt;Integer&gt;&gt;(); for(int i = 0; i &lt; nums.length - 2; i++)&#123; // 跳过重复元素 if(i &gt; 0 &amp;&amp; nums[i] == nums[i-1]) continue; // 计算2Sum ArrayList&lt;List&lt;Integer&gt;&gt; curr = twoSum(nums, i, 0 - nums[i]); res.addAll(curr); &#125; return res; &#125; private ArrayList&lt;List&lt;Integer&gt;&gt; twoSum(int[] nums, int i, int target)&#123; int left = i + 1, right = nums.length - 1; ArrayList&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;List&lt;Integer&gt;&gt;(); while(left &lt; right)&#123; if(nums[left] + nums[right] == target)&#123; ArrayList&lt;Integer&gt; curr = new ArrayList&lt;Integer&gt;(); curr.add(nums[i]); curr.add(nums[left]); curr.add(nums[right]); res.add(curr); do &#123; left++; &#125;while(left &lt; nums.length &amp;&amp; nums[left] == nums[left-1]); do &#123; right--; &#125; while(right &gt;= 0 &amp;&amp; nums[right] == nums[right+1]); &#125; else if (nums[left] + nums[right] &gt; target)&#123; right--; &#125; else &#123; left++; &#125; &#125; return res; &#125;&#125; Keytips：很久没有写Java了，花了点时间去整理了一些知识，所以上面的算法其实是ctrl+v的，现在整理一下list相关的知识： 1.List&lt;List&gt;为嵌套的list集合，声明方式 List&lt;List&gt; list = new Array() or List&lt;List&gt; list = new ArrayList&lt;&gt;();//recomend 2.List是一个接口，而ArrayList是List接口的一个实现类 List list = new List();//是错误的用法 List list = new ArrayList();//list会丢失ArrayList的trimToSize()方法 ArrayList list=newArrayList() 3.然后明天再回来重新写这道题]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[缓存]]></title>
    <url>%2F2019%2F02%2F19%2F2019-02-19-%E7%BC%93%E5%AD%98%2F</url>
    <content type="text"><![CDATA[缓存why 高性能 例如：把查完的值缓存，下次直接访问 高并发 例如：把请求排队 difference（vs memcached) 特征 redis memchched 数据结构 更复杂的数据结构，更丰富的数据操作 集群 支持 不支持 性能 单核 多核 redis线程模型redis 内部使用文件事件处理器 file event handler，这个文件事件处理器是单线程的，所以 redis 才叫做单线程的模型。它采用 IO 多路复用机制同时监听多个 socket，根据 socket 上的事件来选择对应的事件处理器进行处理。 假设一个 Redis 服务器正在运作， 那么这个服务器的监听套接字的 AE_READABLE 事件应该正处于监听状态之下， 而该事件所对应的处理器为连接应答处理器。 如果这时有一个 Redis 客户端向服务器发起连接， 那么监听套接字将产生 AE_READABLE 事件， 触发连接应答处理器执行： 处理器会对客户端的连接请求进行应答， 然后创建客户端套接字， 以及客户端状态， 并将客户端套接字的 AE_READABLE 事件与命令请求处理器进行关联， 使得客户端可以向主服务器发送命令请求。 之后， 假设客户端向主服务器发送一个命令请求， 那么客户端套接字将产生 AE_READABLE 事件， 引发命令请求处理器执行， 处理器读取客户端的命令内容， 然后传给相关程序去执行。 执行命令将产生相应的命令回复， 为了将这些命令回复传送回客户端， 服务器会将客户端套接字的 AE_WRITABLE 事件与命令回复处理器进行关联： 当客户端尝试读取命令回复的时候， 客户端套接字将产生 AE_WRITABLE 事件， 触发命令回复处理器执行， 当命令回复处理器将命令回复全部写入到套接字之后， 服务器就会解除客户端套接字的 AE_WRITABLE 事件与命令回复处理器之间的关联。]]></content>
      <categories>
        <category>high_availability</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[联合索引]]></title>
    <url>%2F2019%2F02%2F19%2F2019-02-19-%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95%2F</url>
    <content type="text"><![CDATA[key当具备多个索引的时候，如：KEY 联合索引 (a,b,c)为索引，除(b,c)条件索引不会触发该索引表外，(a,b),(a,c),(a,b,c)均会触发上述联合索引，具体可参见explain的key类型，理论应该显示联立索引 如： EXPLAIN SELECT FROM TABLENAME WHERE a=’2222’ AND b=‘222’* 如果你设置多个单列索引，在explain下，key的值就为其单列的索引，如上述的a列]]></content>
      <categories>
        <category>database</category>
      </categories>
      <tags>
        <tag>sql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[树的后序遍历]]></title>
    <url>%2F2019%2F02%2F19%2F2019-02-19-%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%2F</url>
    <content type="text"><![CDATA[definition1234567891011121314151617181920private static class BinaryNode&lt;AnyType&gt;&#123; BinaryNode(AnyType theElement) &#123; this(theElement, null, null); &#125; BinaryNode(AnyType theElement, BinaryNode&lt;AnyType&gt; lt, BinaryNode&lt;AnyType&gt; rt) &#123; element &#x3D; theElement; left &#x3D; lt; right &#x3D; rt; &#125; AnyType element; BinaryNode&lt;AnyType&gt; left; BinaryNode&lt;AnyType&gt; right;&#125;private BinaryNode&lt;AnyType&gt; root; posOrder123456789public void posOrder(BinaryNode&lt;AnyType&gt; Node) &#123; if (Node != null) &#123; posOrder(Node.left); posOrder(Node.right); System.out.print(Node.element + &quot; &quot;); &#125; &#125; 1234567891011121314151617181920212223242526272829public void posOrder(BinaryNode&lt;AnyType&gt; Node)&#123; Stack&lt;BinaryNode&gt; stack1 &#x3D; new Stack&lt;&gt;(); Stack&lt;Integer&gt; stack2 &#x3D; new Stack&lt;&gt;(); int i &#x3D; 1; while(Node !&#x3D; null || !stack1.empty()) &#123; while (Node !&#x3D; null) &#123; stack1.push(Node); stack2.push(0); Node &#x3D; Node.left; &#125; while(!stack1.empty() &amp;&amp; stack2.peek() &#x3D;&#x3D; i) &#123; stack2.pop(); System.out.print(stack1.pop().element + &quot; &quot;); &#125; if(!stack1.empty()) &#123; stack2.pop(); stack2.push(1); Node &#x3D; stack1.peek(); Node &#x3D; Node.right; &#125; &#125;&#125;]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[表内关联]]></title>
    <url>%2F2019%2F02%2F19%2F2019-02-19-%E8%A1%A8%E5%86%85%E5%85%B3%E8%81%94%2F</url>
    <content type="text"><![CDATA[Inner Join SELECT column_listFROM t1INNER JOIN t2 ON join_condition1INNER JOIN t3 ON join_condition2…WHERE where_conditions; Example id name parentid 1 北京市 0 2 海淀区 1 3 北京xx大学 2 select a.name 市,b.name 区,c.name 名from address ajoin address b on b.parentid = a.idjoin address c on c.parentid = b.idjoin address d on d.parentid = c.id]]></content>
      <categories>
        <category>database</category>
      </categories>
      <tags>
        <tag>sql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LongestCommonPrefix]]></title>
    <url>%2F2019%2F02%2F18%2F2019-02-18-LongestCommonPrefix%2F</url>
    <content type="text"><![CDATA[Problem Write a function to find the longest common prefix string amongst an array of strings. If there is no common prefix, return an empty string &quot;&quot;. Example 1: 12Input: [&quot;flower&quot;,&quot;flow&quot;,&quot;flight&quot;]Output: &quot;fl&quot; Example 2: 123Input: [&quot;dog&quot;,&quot;racecar&quot;,&quot;car&quot;]Output: &quot;&quot;Explanation: There is no common prefix among the input strings. Note: All given inputs are in lowercase letters a-z. solution12345678910111213141516171819202122232425262728293031323334class Solution &#123; public String longestCommonPrefix(String[] strs) &#123; int minLength = minLength(strs); String same = &quot;&quot;; boolean isSame=false; outer:for(int i=0;i&lt;minLength;i++) &#123; char sameCharacter = strs[0].charAt(i); isSame = false; for(int j=0;j&lt;strs.length;j++) &#123; if(strs[j].charAt(i)==sameCharacter) &#123; isSame = true; &#125;else &#123; isSame = false; break outer; &#125; &#125; if(isSame=true)same+=sameCharacter; &#125; return same; &#125; private int minLength(String[] strs) &#123; // TODO Auto-generated method stub if(strs.length==0) &#123; return 0; &#125; int min = strs[0].length(); for(int i=1;i&lt;strs.length;i++) &#123; if(strs[i].length()&lt;min) &#123; min = strs[i].length(); &#125; &#125; return min; &#125;&#125; key数学题，没什么关键，但是这个解法，还是存在优化空间 Perfect123456789101112131415161718192021class Solution &#123; public String longestCommonPrefix(String[] strs) &#123; if (strs == null || strs.length == 0) &#123; return &quot;&quot;; &#125; String prefix = strs[0]; for (int i = 1; i &lt; strs.length; ++i) &#123; while (!strs[i].startsWith(prefix)) &#123; prefix = prefix.substring(0, prefix.length() - 1); if (prefix.isEmpty()) &#123; break; &#125; &#125; &#125; return prefix; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[ReverseInteger]]></title>
    <url>%2F2019%2F02%2F17%2F2019-02-17-ReverseInteger%2F</url>
    <content type="text"><![CDATA[ProblemGiven a 32-bit signed integer, reverse digits of an integer. Example 1: Input: 123Output: 321Example 2: Input: -123Output: -321Example 3: Input: 120Output: 21Note:Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: [−231, 231 − 1]. For the purpose of this problem, assume that your function returns 0 when the reversed integer overflows. Solution1234567891011121314151617181920class Solution &#123; public int reverse(int x) &#123; if (x == 0) &#123; return 0; &#125; int result =0; long result_l = 0; while (x != 0) &#123; result_l = result_l * 10 + x % 10; x = x / 10; &#125; if(result_l &gt;= Integer.MAX_VALUE||result_l &lt;= Integer.MIN_VALUE) &#123; return 0; &#125;else &#123; result = (int) result_l; &#125; return result; &#125;&#125; keys1.倒序很简单，取余赋给新数就可以了，不过注意JavaScript或者Python的int–&gt;float的情况 2.题目下面其实提示了int的范围，改题目1032个测试数据，有大概7个是超范围的验证数据，所以java中可以巧利用Integer.MAX来进行处理。 perfect12345678public int reverse(int x) &#123; long res = 0; while (x != 0) &#123; res = res * 10 + x % 10; x = x / 10; &#125; return (int)res == res ? (int)res : 0; &#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Easy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何生成tag和categories]]></title>
    <url>%2F2019%2F02%2F17%2F2019-02-17-%E5%A6%82%E4%BD%95%E7%94%9F%E6%88%90tag%E5%92%8Ccategories%2F</url>
    <content type="text"><![CDATA[12hexo new page tagshexo new page categories]]></content>
      <categories>
        <category>others</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[为什么使用消息队列MQ]]></title>
    <url>%2F2019%2F01%2F24%2F2019-01-24-%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97MQ%2F</url>
    <content type="text"><![CDATA[从实习到后来的两份工作也写了不少的项目，在最近的一份工作用到了大量的消息队列（客服系统，会有大量的访客咨询消息），让我重新回顾了一下在大数据面前，为什么要用消息队列，怎么用好消息队列 理由 解耦 异步 削峰 解耦通过一个 MQ，Pub/Sub 发布订阅消息这么一个模型，不同微服务之间通信会更加解耦，A给BCDEF发送消息的时候，就不需要考虑他们是否宕机，如何重发等，只需要将信息发送到队列里，让他们自己去取就好了 异步假设用户请求需要写表，那么吧任务放进队列里，等待写入，前端可以先返回，可以减少用户的等待时间，或者采用多个机器同时写数据的不同部分，加快数据的处理 削峰就和平时用电一样，晚上电网的压力肯定会很大，如果直接把大量请求压到服务器，会直接宕机，但如果把请求排成队列，然后服务器从里面顺序取，虽然会增加延迟，但是不会宕机，满负荷运作而已 实际生产环境咨询系统大致分为：咨询核心，端模块，微信模块，分配模块等等，访客发送的咨询信息（web）可能先经过端模块，在咨询核心模块处理前进入队列，然后，分配模块根据用户的设置，如接入客服还是机器人，按什么权重进行分配，分配给哪一个业务组进行操作，来减轻咨询核心的压力 缺点1.系统可用性降低（MQ挂了咋整） 2.复杂度提升（消息没有重复消费，不会丢失） 3.一致性问题有待解决 特性 ActiveMQ RabbitMQ RocketMQ Kafka 单机吞吐量 万级，比 RocketMQ、Kafka 低一个数量级 同 ActiveMQ 10 万级，支撑高吞吐 10 万级，高吞吐，一般配合大数据类的系统来进行实时数据计算、日志采集等场景 topic 数量对吞吐量的影响 topic 可以达到几百/几千的级别，吞吐量会有较小幅度的下降，这是 RocketMQ 的一大优势，在同等机器下，可以支撑大量的 topic topic 从几十到几百个时候，吞吐量会大幅度下降，在同等机器下，Kafka 尽量保证 topic 数量不要过多，如果要支撑大规模的 topic，需要增加更多的机器资源 时效性 ms 级 微秒级，这是 RabbitMQ 的一大特点，延迟最低 ms 级 延迟在 ms 级以内 可用性 高，基于主从架构实现高可用 同 ActiveMQ 非常高，分布式架构 非常高，分布式，一个数据多个副本，少数机器宕机，不会丢失数据，不会导致不可用 消息可靠性 有较低的概率丢失数据 基本不丢 经过参数优化配置，可以做到 0 丢失 同 RocketMQ 功能支持 MQ 领域的功能极其完备 基于 erlang 开发，并发能力很强，性能极好，延时很低 MQ 功能较为完善，还是分布式的，扩展性好 功能较为简单，主要支持简单的 MQ 功能，在大数据领域的实时计算以及日志采集被大规模使用 所以中小型公司，用 RabbitMQ 是不错的选择 大型公司，基础架构研发实力较强，用 RocketMQ 是很好的选择 如果是大数据领域的实时计算、日志采集等场景，用 Kafka 是业内标准的，绝对没问题，社区活跃度很高，绝对不会黄，何况几乎是全世界这个领域的事实性规范。]]></content>
      <categories>
        <category>high_availability</category>
      </categories>
      <tags>
        <tag>MQ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[递归优化]]></title>
    <url>%2F2019%2F01%2F23%2F2019-01-23-%E9%80%92%E5%BD%92%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[递归优化原因：在 Java 中，每个线程都有独立的 Java 虚拟机栈。栈具有后入先出的特点，递归调用也是需要后调用的方法先返回，因此使用栈来存储递归调用的信息。这些信息存储在栈帧中，每个 Java 方法在执行时都会创建一个栈帧，用来存储局部变量表、操作数栈、常量池引用等信息。在调用方法时，对应着一个栈帧入栈，而方法返回时，对应着一个栈帧出栈。 随着栈帧frame的增多，将会导致Stack Overflow的报错，例如 1234567int f(int i)&#123; if(i == 1 || i == 2) return 1; else return (f(i - 1) + f(i - 2));&#125; 解决方法1：递归–&gt;非递归其实很简单，就是用一个临时变量，来保存中间的值，而不是压入堆栈中， 1234567891011//费波纳列数列，前两位是1，之后没位数是前两位数的和private static void fibonacci(int n) &#123; int temp1=1,temp2=1,temp; for (int i = 1; i &lt;=n ; i++) &#123; temp=temp1+temp2; temp1=temp2; temp2=temp; &#125; System.out.println();&#125;//粘贴于网上 解决办法2：递归–&gt;尾递归尾递归就是当函数在最后一步（尾部）调用自身，如： 123function f(x)&#123; return g(x);&#125; 以下算法来自阮一峰教程： 123456function factorial(n) &#123; if (n === 1) return 1; return n * factorial(n - 1);&#125;factorial(5) // 120 该算法并非是尾递归，因为其在返回值的时候进行了一个乘法操作，所以还是普通的递归，复杂度为O(n)，而如果改成尾递归，则： 123456function factorial(n, total) &#123; if (n === 1) return total; return factorial(n - 1, n * total);&#125;factorial(5, 1) // 120 该算法只需要计算 factorial(5,1) factorial(4,5) factorial(3,20) factorial(2,60) factorial(1,120) 在进入新的递归函数时，尾递归不再需要使用栈帧保存数据，允许抛弃旧的栈帧，那么只需要保存一个栈帧即可 参考资料： [阮一峰尾递归]（http://www.ruanyifeng.com/blog/2015/04/tail-call.html）]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>regreesion</tag>
      </tags>
  </entry>
</search>
